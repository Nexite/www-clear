# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

"A Field Group registered by ACF"
interface BlogAcfFieldGroup {
    "The name of the ACF Field Group"
    fieldGroupName: String
}

"The author of a comment"
interface BlogCommenter {
    "Identifies the primary key from the database."
    databaseId: Int!
    "The email address of the author of a comment."
    email: String
    "The globally unique identifier for the comment author."
    id: ID!
    "Whether the author information is considered restricted. (not fully public)"
    isRestricted: Boolean
    "The name of the author of a comment."
    name: String
    "The url of the author of a comment."
    url: String
}

"Nodes used to manage content"
interface BlogContentNode {
    "Connection between the ContentNode type and the ContentType type"
    contentType: BlogContentNodeToContentTypeConnectionEdge
    "The name of the Content Type the node belongs to"
    contentTypeName: String!
    "The ID of the node in the database."
    databaseId: Int!
    "Post publishing date."
    date: String
    "The publishing date set in GMT."
    dateGmt: String
    "The desired slug of the post"
    desiredSlug: String
    "If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds"
    editingLockedBy: BlogContentNodeToEditLockConnectionEdge
    "The RSS enclosure for the object"
    enclosure: String
    "Connection between the ContentNode type and the EnqueuedScript type"
    enqueuedScripts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogContentNodeToEnqueuedScriptConnection
    "Connection between the ContentNode type and the EnqueuedStylesheet type"
    enqueuedStylesheets(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogContentNodeToEnqueuedStylesheetConnection
    "The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table."
    guid: String
    "The unique resource identifier path"
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether the object is a node in the preview state"
    isPreview: Boolean
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Whether the node is a Term"
    isTermNode: Boolean!
    "The user that most recently edited the node"
    lastEditedBy: BlogContentNodeToEditLastConnectionEdge
    "The permalink of the post"
    link: String
    "The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time."
    modified: String
    "The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT."
    modifiedGmt: String
    "The database id of the preview node"
    previewRevisionDatabaseId: Int
    "Whether the object is a node in the preview state"
    previewRevisionId: ID
    "The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table."
    slug: String
    "The current status of the object"
    status: String
    "The template assigned to a node of content"
    template: BlogContentTemplate
    "The unique resource identifier path"
    uri: String
}

"The template assigned to a node of content"
interface BlogContentTemplate {
    "The name of the template"
    templateName: String
}

"Object that can be identified with a Database ID"
interface BlogDatabaseIdentifier {
    "The unique identifier stored in the database"
    databaseId: Int!
}

"Asset enqueued by the CMS"
interface BlogEnqueuedAsset {
    "@todo"
    args: Boolean
    "Dependencies needed to use this asset"
    dependencies: [BlogEnqueuedScript]
    "Extra information needed for the script"
    extra: String
    "The handle of the enqueued asset"
    handle: String
    "The ID of the enqueued asset"
    id: ID!
    "The source of the asset"
    src: String
    "The version of the enqueued asset"
    version: String
}

"Content node with hierarchical (parent/child) relationships"
interface BlogHierarchicalContentNode {
    "Returns ancestors of the node. Default ordered as lowest (closest to the child) to highest (closest to the root)."
    ancestors(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogHierarchicalContentNodeToContentNodeAncestorsConnectionWhereArgs
    ): BlogHierarchicalContentNodeToContentNodeAncestorsConnection
    "Connection between the HierarchicalContentNode type and the ContentNode type"
    children(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogHierarchicalContentNodeToContentNodeChildrenConnectionWhereArgs
    ): BlogHierarchicalContentNodeToContentNodeChildrenConnection
    "The parent of the node. The parent object can be of various types"
    parent: BlogHierarchicalContentNodeToParentContentNodeConnectionEdge
    "Database id of the parent node"
    parentDatabaseId: Int
    "The globally unique identifier of the parent node."
    parentId: ID
}

"Term node with hierarchical (parent/child) relationships"
interface BlogHierarchicalTermNode {
    "Database id of the parent node"
    parentDatabaseId: Int
    "The globally unique identifier of the parent node."
    parentId: ID
}

"Nodes that can be linked to as Menu Items"
interface BlogMenuItemLinkable {
    "The unique resource identifier path"
    databaseId: Int!
    "The unique resource identifier path"
    id: ID!
    "The unique resource identifier path"
    uri: String
}

"An object with an ID"
interface BlogNode {
    "The globally unique ID for the object"
    id: ID!
}

"A node that can have an author assigned to it"
interface BlogNodeWithAuthor {
    "The database identifier of the author of the node"
    authorDatabaseId: Int
    "The globally unique identifier of the author of the node"
    authorId: ID
    "Connection between the NodeWithAuthor type and the User type"
    wpAuthor: BlogNodeWithAuthorToUserConnectionEdge
}

"A node that can have comments associated with it"
interface BlogNodeWithComments {
    "The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility."
    commentCount: Int
    "Whether the comments are open or closed for this particular post."
    commentStatus: String
}

"A node that supports the content editor"
interface BlogNodeWithContentEditor {
    "The content of the post."
    content(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
}

"A node that can have an excerpt"
interface BlogNodeWithExcerpt {
    "The excerpt of the post."
    excerpt(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
}

"A node that can have a featured image set"
interface BlogNodeWithFeaturedImage {
    "Connection between the ContentNode type and the ContentType type"
    contentType: BlogContentNodeToContentTypeConnectionEdge
    "The name of the Content Type the node belongs to"
    contentTypeName: String!
    "The unique identifier stored in the database"
    databaseId: Int!
    "Post publishing date."
    date: String
    "The publishing date set in GMT."
    dateGmt: String
    "The desired slug of the post"
    desiredSlug: String
    "If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds"
    editingLockedBy: BlogContentNodeToEditLockConnectionEdge
    "The RSS enclosure for the object"
    enclosure: String
    "Connection between the ContentNode type and the EnqueuedScript type"
    enqueuedScripts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogContentNodeToEnqueuedScriptConnection
    "Connection between the ContentNode type and the EnqueuedStylesheet type"
    enqueuedStylesheets(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogContentNodeToEnqueuedStylesheetConnection
    "Connection between the NodeWithFeaturedImage type and the MediaItem type"
    featuredImage: BlogNodeWithFeaturedImageToMediaItemConnectionEdge
    "The database identifier for the featured image node assigned to the content node"
    featuredImageDatabaseId: Int
    "Globally unique ID of the featured image assigned to the node"
    featuredImageId: ID
    "The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table."
    guid: String
    "The unique resource identifier path"
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether the object is a node in the preview state"
    isPreview: Boolean
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Whether the node is a Term"
    isTermNode: Boolean!
    "The user that most recently edited the node"
    lastEditedBy: BlogContentNodeToEditLastConnectionEdge
    "The permalink of the post"
    link: String
    "The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time."
    modified: String
    "The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT."
    modifiedGmt: String
    "The database id of the preview node"
    previewRevisionDatabaseId: Int
    "Whether the object is a node in the preview state"
    previewRevisionId: ID
    "The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table."
    slug: String
    "The current status of the object"
    status: String
    "The template assigned to a node of content"
    template: BlogContentTemplate
    "The unique resource identifier path"
    uri: String
}

"A node that can have page attributes"
interface BlogNodeWithPageAttributes {
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int
}

"A node that can have revisions"
interface BlogNodeWithRevisions {
    "True if the node is a revision of another node"
    isRevision: Boolean
    "If the current node is a revision, this field exposes the node this is a revision of. Returns null if the node is not a revision of another node."
    revisionOf: BlogNodeWithRevisionsToContentNodeConnectionEdge
}

"A node that can have a template associated with it"
interface BlogNodeWithTemplate {
    "The template assigned to the node"
    template: BlogContentTemplate
}

"A node that NodeWith a title"
interface BlogNodeWithTitle {
    "The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made."
    title(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
}

"A node that can have trackbacks and pingbacks"
interface BlogNodeWithTrackbacks {
    "Whether the pings are open or closed for this particular post."
    pingStatus: String
    "URLs that have been pinged."
    pinged: [String]
    "URLs queued to be pinged."
    toPing: [String]
}

"Terms are nodes within a Taxonomy, used to group and relate other nodes."
interface BlogTermNode {
    "The number of objects connected to the object"
    count: Int
    "Identifies the primary key from the database."
    databaseId: Int!
    "The description of the object"
    description: String
    "Connection between the TermNode type and the EnqueuedScript type"
    enqueuedScripts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogTermNodeToEnqueuedScriptConnection
    "Connection between the TermNode type and the EnqueuedStylesheet type"
    enqueuedStylesheets(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogTermNodeToEnqueuedStylesheetConnection
    "The unique resource identifier path"
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Whether the node is a Term"
    isTermNode: Boolean!
    "The link to the term"
    link: String
    "The human friendly name of the object."
    name: String
    "An alphanumeric identifier for the object unique to its type."
    slug: String
    "The name of the taxonomy that the object is associated with"
    taxonomyName: String
    "The ID of the term group that this term object belongs to"
    termGroupId: Int
    "The taxonomy ID that the object is associated with"
    termTaxonomyId: Int
    "The unique resource identifier path"
    uri: String
}

"Any node that has a URI"
interface BlogUniformResourceIdentifiable {
    "The unique resource identifier path"
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether the node is a Term"
    isTermNode: Boolean!
    "The unique resource identifier path"
    uri: String
}

interface CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    sys: CmsSys!
}

interface LearnEntry {
    contentfulMetadata: LearnContentfulMetadata!
    sys: LearnSys!
}

"A union of Content Node Types that support revisions"
union BlogContentRevisionUnion = BlogPage | BlogPost

"Deprecated in favor of MenuItemLinkeable Interface"
union BlogMenuItemObjectUnion = BlogCategory | BlogPage | BlogPost | BlogTag

type AccountDiscordInformation {
    avatar: String
    discriminator: String!
    handle: String!
    tag: String!
    username: String!
}

type AccountDiscordUser {
    badges(displayed: Boolean): [AccountDiscordUserBadge]
    bio: String
    discordId: String
    id: ID!
    name: String
    pronoun: String
    username: String
}

type AccountDiscordUserBadge {
    displayed: Boolean
    expiresUtc: String
    id: ID!
    order: Int
}

type AccountMutation {
    addRole(id: ID!, roleId: ID!): Boolean
    addRoleByCode(code: String!, where: AccountUserSingleInput!): Boolean
    grantBadge(badge: AccountUserBadgeInput!, where: AccountUserSingleInput!): Boolean
    linkDiscord(discordId: String!, userId: ID!): Boolean
    pizzaOrTurtleCult(pizzaOrTurtle: AccountPizzaOrTurtle!, where: AccountUserSingleInput!): Boolean
    revokeBadge(badge: AccountUserBadgeInput!, where: AccountUserSingleInput!): Boolean
    setDisplayedBadges(badges: [AccountDisplayedUserBadgeInput!], where: AccountUserSingleInput): Boolean
    unlinkDiscord(userId: ID!): Boolean
    updateUser(updates: AccountUpdateUserInput!, username: String): Boolean
    uploadProfilePicture(upload: Upload!, where: AccountUserSingleInput): String
}

type AccountQuery {
    getDiscordUsers: [AccountDiscordUser]!
    getUser(fresh: Boolean, where: AccountUserSingleInput!): AccountUser
    roleUsers(roleId: String!): [AccountUser]!
    roles: [AccountRole]!
    searchUsers(where: AccountUserSearch!): [AccountUser]!
    userRoles(id: ID!): [AccountRole]
}

type AccountRole {
    description: String
    id: ID!
    name: String!
}

type AccountSubscriptionBadge {
    badge: AccountUserBadge!
    type: String
    user: AccountSubscriptionUser!
}

type AccountSubscriptionUser {
    badges: [AccountUserBadge]
    bio: String
    discordId: String
    id: ID!
    name: String
    picture(transform: AccountUserPictureTransformInput): String
    pronoun: String
    roles: [AccountRole]
    username: String
}

type AccountUser {
    acceptTos: Boolean
    badges(displayed: Boolean): [AccountUserBadge]
    bio: String
    blocked: Boolean
    discordId: String
    discordInformation: AccountDiscordInformation
    displayNameFormat: String
    email: String
    familyName: String
    givenName: String
    id: ID!
    name: String
    phoneNumber: String
    picture(transform: AccountUserPictureTransformInput): String
    pronoun: String
    roles: [AccountRole]
    sites: [CmsSite]
    title: String
    username: String
}

type AccountUserBadge {
    details: CmsBadge
    displayed: Boolean
    expiresUtc: String
    id: ID!
    order: Int
}

type AdvisorsEventParticipation {
    awardIds: [String!]!
    eventId: String!
    id: String!
    profile: AdvisorsProfile!
}

type AdvisorsMutation {
    createAdvisor(data: AdvisorsAdvisorCreateInput!): Boolean!
    createEventParticipation(data: AdvisorsEventParticipationCreateInput!, username: String!): AdvisorsEventParticipation!
    createProfile(data: AdvisorsProfileCreateInput!, username: String): AdvisorsProfile!
    createRecommendation(authorUsername: String, data: AdvisorsRecommendationCreateInput!, username: String!): AdvisorsRecommendation!
    createRequest(email: String!, familyName: String!, givenName: String!, resume: Upload, type: AdvisorsRequestType!): Boolean!
    createTag(data: AdvisorsTagCreateInput!): AdvisorsTag!
    deleteTag(id: String!): Boolean!
    editAdvisorLimits(limits: AdvisorsAdvisorLimitInput!, where: AdvisorsAdvisorWhereInput!): Boolean!
    editProfile(data: AdvisorsProfileEditInput!, username: String): AdvisorsProfile!
    editRecommendation(data: AdvisorsRecommendationEditInput!, id: String!): AdvisorsRecommendation!
}

type AdvisorsPendingRequests {
    pendingRequests: Float!
    requestType: AdvisorsRequestType!
}

type AdvisorsProfile {
    bio: String
    createdAt: AdvisorsDateTime!
    email: String!
    eventParticipation: [AdvisorsEventParticipation!]!
    experience: [AdvisorsTag!]!
    familyName: String!
    givenName: String!
    gradHighSchoolAt: AdvisorsDateTime
    gradUniversityAt: AdvisorsDateTime
    recommendations: [AdvisorsRecommendation!]!
    searchFullTimeAt: AdvisorsDateTime
    searchInternships: Boolean!
    searchOpen: Boolean!
    underrepresentedEthnicity: Boolean!
    underrepresentedGender: Boolean!
    updatedAt: AdvisorsDateTime!
    urlGithub: String
    urlLinkedIn: String
    urlResume: String
    urlWebsite: String
    username: String!
    workFteAt: AdvisorsDateTime
    workInternAt: AdvisorsDateTime
}

type AdvisorsQuery {
    buildResumePackage(username: String!): String!
    pendingRequests: [AdvisorsPendingRequests!]!
    profile(username: String): AdvisorsProfile!
    remainingRequests: [AdvisorsRemainingRequestsType!]!
    servedRequests(where: AdvisorsRequestCountWhereInput): [AdvisorsRequestCount!]!
    submittedRequests(where: AdvisorsRequestCountWhereInput): [AdvisorsRequestCount!]!
    tags(type: AdvisorsTagType): [AdvisorsTag!]!
}

type AdvisorsRecommendation {
    createdAt: AdvisorsDateTime!
    employer: String!
    familyName: String!
    givenName: String!
    id: String!
    profile: AdvisorsProfile!
    recommendation: String
    relation: String!
    skillEngineering: AdvisorsRecommendationRating
    skillInterpersonal: AdvisorsRecommendationRating
    skillTechnical: AdvisorsRecommendationRating
    title: String!
    updatedAt: AdvisorsDateTime!
    username: String
}

type AdvisorsRemainingRequestsByAdvisorType {
    advisorType: AdvisorsAdvisorType!
    remainingRequests: Float!
}

type AdvisorsRemainingRequestsType {
    advisorTypes: [AdvisorsRemainingRequestsByAdvisorType!]!
    requestType: AdvisorsRequestType!
    totalRemainingRequests: Float!
}

type AdvisorsRequestCount {
    email: String!
    familyName: String!
    givenName: String!
    practiceInterviews: Float!
    resumeReviews: Float!
    username: String
}

type AdvisorsTag {
    displayName: String!
    id: String!
    profiles: [AdvisorsProfile!]!
    type: AdvisorsTagType!
}

"Avatars are profile images for users. WordPress by default uses the Gravatar service to host and fetch avatars from."
type BlogAvatar {
    "URL for the default image or a default type. Accepts &#039;404&#039; (return a 404 instead of a default image), &#039;retro&#039; (8bit), &#039;monsterid&#039; (monster), &#039;wavatar&#039; (cartoon face), &#039;indenticon&#039; (the &#039;quilt&#039;), &#039;mystery&#039;, &#039;mm&#039;, or &#039;mysteryman&#039; (The Oyster Man), &#039;blank&#039; (transparent GIF), or &#039;gravatar_default&#039; (the Gravatar logo)."
    default: String
    "HTML attributes to insert in the IMG element. Is not sanitized."
    extraAttr: String
    "Whether to always show the default image, never the Gravatar."
    forceDefault: Boolean
    "Whether the avatar was successfully found."
    foundAvatar: Boolean
    "Height of the avatar image."
    height: Int
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "What rating to display avatars up to. Accepts &#039;G&#039;, &#039;PG&#039;, &#039;R&#039;, &#039;X&#039;, and are judged in that order."
    rating: String
    "Type of url scheme to use. Typically HTTP vs. HTTPS."
    scheme: String
    "The size of the avatar in pixels. A value of 96 will match a 96px x 96px gravatar image."
    size: Int
    "URL for the gravatar image source."
    url: String
    "Width of the avatar image."
    width: Int
}

"The category type"
type BlogCategory implements BlogDatabaseIdentifier & BlogHierarchicalTermNode & BlogMenuItemLinkable & BlogNode & BlogTermNode & BlogUniformResourceIdentifiable {
    "The ancestors of the node. Default ordered as lowest (closest to the child) to highest (closest to the root)."
    ancestors(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogCategoryToAncestorsCategoryConnection
    "The id field matches the WP_Post-&gt;ID field."
    categoryId: Int @deprecated(reason : "Deprecated in favor of databaseId")
    "Connection between the category type and the category type"
    children(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogCategoryToCategoryConnectionWhereArgs
    ): BlogCategoryToCategoryConnection
    "Connection between the category type and the ContentNode type"
    contentNodes(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogCategoryToContentNodeConnectionWhereArgs
    ): BlogCategoryToContentNodeConnection
    "The number of objects connected to the object"
    count: Int
    "The unique resource identifier path"
    databaseId: Int!
    "The description of the object"
    description: String
    "Added to the GraphQL Schema because the ACF Field Group &quot;Display&quot; was set to Show in GraphQL."
    display: BlogCategory_Display
    "Connection between the TermNode type and the EnqueuedScript type"
    enqueuedScripts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogTermNodeToEnqueuedScriptConnection
    "Connection between the TermNode type and the EnqueuedStylesheet type"
    enqueuedStylesheets(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogTermNodeToEnqueuedStylesheetConnection
    "The unique resource identifier path"
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Whether the node is a Term"
    isTermNode: Boolean!
    "The link to the term"
    link: String
    "The human friendly name of the object."
    name: String
    "Connection between the category type and the category type"
    parent: BlogCategoryToParentCategoryConnectionEdge
    "Database id of the parent node"
    parentDatabaseId: Int
    "The globally unique identifier of the parent node."
    parentId: ID
    "Connection between the category type and the post type"
    posts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogCategoryToPostConnectionWhereArgs
    ): BlogCategoryToPostConnection
    "An alphanumeric identifier for the object unique to its type."
    slug: String
    "Connection between the category type and the Taxonomy type"
    taxonomy: BlogCategoryToTaxonomyConnectionEdge
    "The name of the taxonomy that the object is associated with"
    taxonomyName: String
    "The ID of the term group that this term object belongs to"
    termGroupId: Int
    "The taxonomy ID that the object is associated with"
    termTaxonomyId: Int
    "The unique resource identifier path"
    uri: String
}

"Connection between the category type and the category type"
type BlogCategoryToAncestorsCategoryConnection {
    "Edges for the CategoryToAncestorsCategoryConnection connection"
    edges: [BlogCategoryToAncestorsCategoryConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogCategory]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogCategoryToAncestorsCategoryConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogCategory
}

"Connection between the category type and the category type"
type BlogCategoryToCategoryConnection {
    "Edges for the CategoryToCategoryConnection connection"
    edges: [BlogCategoryToCategoryConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogCategory]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogCategoryToCategoryConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogCategory
}

"Connection between the category type and the ContentNode type"
type BlogCategoryToContentNodeConnection {
    "Edges for the CategoryToContentNodeConnection connection"
    edges: [BlogCategoryToContentNodeConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogContentNode]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogCategoryToContentNodeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogContentNode
}

"Connection between the category type and the category type"
type BlogCategoryToParentCategoryConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogCategory
}

"Connection between the category type and the post type"
type BlogCategoryToPostConnection {
    "Edges for the CategoryToPostConnection connection"
    edges: [BlogCategoryToPostConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPost]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogCategoryToPostConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPost
}

"Connection between the category type and the Taxonomy type"
type BlogCategoryToTaxonomyConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogTaxonomy
}

"Field Group"
type BlogCategory_Display implements BlogAcfFieldGroup {
    color: String
    "The name of the ACF Field Group"
    fieldGroupName: String
}

"A Comment object"
type BlogComment implements BlogDatabaseIdentifier & BlogNode {
    "User agent used to post the comment. This field is equivalent to WP_Comment-&gt;comment_agent and the value matching the &quot;comment_agent&quot; column in SQL."
    agent: String
    "The approval status of the comment. This field is equivalent to WP_Comment-&gt;comment_approved and the value matching the &quot;comment_approved&quot; column in SQL."
    approved: Boolean
    "The author of the comment"
    author: BlogCommentToCommenterConnectionEdge
    "IP address for the author. This field is equivalent to WP_Comment-&gt;comment_author_IP and the value matching the &quot;comment_author_IP&quot; column in SQL."
    authorIp: String
    "ID for the comment, unique among comments."
    commentId: Int @deprecated(reason : "Deprecated in favor of databaseId")
    "Connection between the Comment type and the ContentNode type"
    commentedOn: BlogCommentToContentNodeConnectionEdge
    "Content of the comment. This field is equivalent to WP_Comment-&gt;comment_content and the value matching the &quot;comment_content&quot; column in SQL."
    content(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
    "The unique identifier stored in the database"
    databaseId: Int!
    "Date the comment was posted in local time. This field is equivalent to WP_Comment-&gt;date and the value matching the &quot;date&quot; column in SQL."
    date: String
    "Date the comment was posted in GMT. This field is equivalent to WP_Comment-&gt;date_gmt and the value matching the &quot;date_gmt&quot; column in SQL."
    dateGmt: String
    "The globally unique identifier for the comment object"
    id: ID!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Karma value for the comment. This field is equivalent to WP_Comment-&gt;comment_karma and the value matching the &quot;comment_karma&quot; column in SQL."
    karma: Int
    "Connection between the Comment type and the Comment type"
    parent(
        "Arguments for filtering the connection"
        where: BlogCommentToParentCommentConnectionWhereArgs
    ): BlogCommentToParentCommentConnectionEdge
    "The database id of the parent comment node or null if it is the root comment"
    parentDatabaseId: Int
    "The globally unique identifier of the parent comment node."
    parentId: ID
    "Connection between the Comment type and the Comment type"
    replies(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogCommentToCommentConnectionWhereArgs
    ): BlogCommentToCommentConnection
    "Type of comment. This field is equivalent to WP_Comment-&gt;comment_type and the value matching the &quot;comment_type&quot; column in SQL."
    type: String
}

"A Comment Author object"
type BlogCommentAuthor implements BlogCommenter & BlogNode {
    "Identifies the primary key from the database."
    databaseId: Int!
    "The email for the comment author"
    email: String
    "The globally unique identifier for the comment author object"
    id: ID!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "The name for the comment author."
    name: String
    "The url the comment author."
    url: String
}

"Connection between the Comment type and the Comment type"
type BlogCommentToCommentConnection {
    "Edges for the CommentToCommentConnection connection"
    edges: [BlogCommentToCommentConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogComment]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogCommentToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogComment
}

"Connection between the Comment type and the Commenter type"
type BlogCommentToCommenterConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogCommenter
}

"Connection between the Comment type and the ContentNode type"
type BlogCommentToContentNodeConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogContentNode
}

"Connection between the Comment type and the Comment type"
type BlogCommentToParentCommentConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogComment
}

"Connection between the ContentNode type and the ContentType type"
type BlogContentNodeToContentTypeConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogContentType
}

"Connection between the ContentNode type and the User type"
type BlogContentNodeToEditLastConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogUser
}

"Connection between the ContentNode type and the User type"
type BlogContentNodeToEditLockConnectionEdge {
    "The timestamp for when the node was last edited"
    lockTimestamp: String
    "The node of the connection, without the edges"
    node: BlogUser
}

"Connection between the ContentNode type and the EnqueuedScript type"
type BlogContentNodeToEnqueuedScriptConnection {
    "Edges for the ContentNodeToEnqueuedScriptConnection connection"
    edges: [BlogContentNodeToEnqueuedScriptConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogEnqueuedScript]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogContentNodeToEnqueuedScriptConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogEnqueuedScript
}

"Connection between the ContentNode type and the EnqueuedStylesheet type"
type BlogContentNodeToEnqueuedStylesheetConnection {
    "Edges for the ContentNodeToEnqueuedStylesheetConnection connection"
    edges: [BlogContentNodeToEnqueuedStylesheetConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogEnqueuedStylesheet]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogContentNodeToEnqueuedStylesheetConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogEnqueuedStylesheet
}

"An Post Type object"
type BlogContentType implements BlogNode & BlogUniformResourceIdentifiable {
    "Whether this content type should can be exported."
    canExport: Boolean
    "Connection between the ContentType type and the Taxonomy type"
    connectedTaxonomies(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogContentTypeToTaxonomyConnection
    "Connection between the ContentType type and the ContentNode type"
    contentNodes(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogContentTypeToContentNodeConnectionWhereArgs
    ): BlogContentTypeToContentNodeConnection
    "Whether content of this type should be deleted when the author of it is deleted from the system."
    deleteWithUser: Boolean
    "Description of the content type."
    description: String
    "Whether to exclude nodes of this content type from front end search results."
    excludeFromSearch: Boolean
    "The plural name of the content type within the GraphQL Schema."
    graphqlPluralName: String
    "The singular name of the content type within the GraphQL Schema."
    graphqlSingleName: String
    "Whether this content type should have archives. Content archives are generated by type and by date."
    hasArchive: Boolean
    "Whether the content type is hierarchical, for example pages."
    hierarchical: Boolean
    "The globally unique identifier of the post-type object."
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether this page is set to the static front page."
    isFrontPage: Boolean!
    "Whether this page is set to the blog posts page."
    isPostsPage: Boolean!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Whether the node is a Term"
    isTermNode: Boolean!
    "Display name of the content type."
    label: String
    "Details about the content type labels."
    labels: BlogPostTypeLabelDetails
    "The name of the icon file to display as a menu icon."
    menuIcon: String
    "The position of this post type in the menu. Only applies if show_in_menu is true."
    menuPosition: Int
    "The internal name of the post type. This should not be used for display purposes."
    name: String
    "Whether a content type is intended for use publicly either via the admin interface or by front-end users. While the default settings of exclude_from_search, publicly_queryable, show_ui, and show_in_nav_menus are inherited from public, each does not rely on this relationship and controls a very specific intention."
    public: Boolean
    "Whether queries can be performed on the front end for the content type as part of parse_request()."
    publiclyQueryable: Boolean
    "Name of content type to display in REST API &quot;wp/v2&quot; namespace."
    restBase: String
    "The REST Controller class assigned to handling this content type."
    restControllerClass: String
    "Makes this content type available via the admin bar."
    showInAdminBar: Boolean
    "Whether to add the content type to the GraphQL Schema."
    showInGraphql: Boolean
    "Where to show the content type in the admin menu. To work, $show_ui must be true. If true, the post type is shown in its own top level menu. If false, no menu is shown. If a string of an existing top level menu (eg. &quot;tools.php&quot; or &quot;edit.php?post_type=page&quot;), the post type will be placed as a sub-menu of that."
    showInMenu: Boolean
    "Makes this content type available for selection in navigation menus."
    showInNavMenus: Boolean
    "Whether the content type is associated with a route under the the REST API &quot;wp/v2&quot; namespace."
    showInRest: Boolean
    "Whether to generate and allow a UI for managing this content type in the admin."
    showUi: Boolean
    "The unique resource identifier path"
    uri: String
}

"Connection between the ContentType type and the ContentNode type"
type BlogContentTypeToContentNodeConnection {
    "Edges for the ContentTypeToContentNodeConnection connection"
    edges: [BlogContentTypeToContentNodeConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogContentNode]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogContentTypeToContentNodeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogContentNode
}

"Connection between the ContentType type and the Taxonomy type"
type BlogContentTypeToTaxonomyConnection {
    "Edges for the ContentTypeToTaxonomyConnection connection"
    edges: [BlogContentTypeToTaxonomyConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogTaxonomy]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogContentTypeToTaxonomyConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogTaxonomy
}

"The payload for the createCategory mutation"
type BlogCreateCategoryPayload {
    "The created category"
    category: BlogCategory
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
}

"The payload for the createComment mutation"
type BlogCreateCommentPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The comment that was created"
    comment: BlogComment
    "Whether the mutation succeeded. If the comment is not approved, the server will not return the comment to a non authenticated user, but a success message can be returned if the create succeeded, and the client can optimistically add the comment to the client cache"
    success: Boolean
}

"The payload for the createMediaItem mutation"
type BlogCreateMediaItemPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The MediaItem object mutation type."
    mediaItem: BlogMediaItem
}

"The payload for the createPage mutation"
type BlogCreatePagePayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The Post object mutation type."
    page: BlogPage
}

"The payload for the createPostFormat mutation"
type BlogCreatePostFormatPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The created post_format"
    postFormat: BlogPostFormat
}

"The payload for the createPost mutation"
type BlogCreatePostPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The Post object mutation type."
    post: BlogPost
}

"The payload for the createTag mutation"
type BlogCreateTagPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The created post_tag"
    tag: BlogTag
}

"The payload for the createUser mutation"
type BlogCreateUserPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The User object mutation type."
    user: BlogUser
}

"The template assigned to the node"
type BlogDefaultTemplate implements BlogContentTemplate {
    "The name of the template"
    templateName: String
}

"The payload for the deleteCategory mutation"
type BlogDeleteCategoryPayload {
    "The deteted term object"
    category: BlogCategory
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the deleted object"
    deletedId: ID
}

"The payload for the deleteComment mutation"
type BlogDeleteCommentPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The deleted comment object"
    comment: BlogComment
    "The deleted comment ID"
    deletedId: ID
}

"The payload for the deleteMediaItem mutation"
type BlogDeleteMediaItemPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the deleted mediaItem"
    deletedId: ID
    "The mediaItem before it was deleted"
    mediaItem: BlogMediaItem
}

"The payload for the deletePage mutation"
type BlogDeletePagePayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the deleted object"
    deletedId: ID
    "The object before it was deleted"
    page: BlogPage
}

"The payload for the deletePostFormat mutation"
type BlogDeletePostFormatPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the deleted object"
    deletedId: ID
    "The deteted term object"
    postFormat: BlogPostFormat
}

"The payload for the deletePost mutation"
type BlogDeletePostPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the deleted object"
    deletedId: ID
    "The object before it was deleted"
    post: BlogPost
}

"The payload for the deleteTag mutation"
type BlogDeleteTagPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the deleted object"
    deletedId: ID
    "The deteted term object"
    tag: BlogTag
}

"The payload for the deleteUser mutation"
type BlogDeleteUserPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the user that you just deleted"
    deletedId: ID
    "The deleted user object"
    user: BlogUser
}

"The discussion setting type"
type BlogDiscussionSettings {
    "Allow people to submit comments on new posts."
    defaultCommentStatus: String
    "Allow link notifications from other blogs (pingbacks and trackbacks) on new articles."
    defaultPingStatus: String
}

"Script enqueued by the CMS"
type BlogEnqueuedScript implements BlogEnqueuedAsset & BlogNode {
    "@todo"
    args: Boolean
    "Dependencies needed to use this asset"
    dependencies: [BlogEnqueuedScript]
    "Extra information needed for the script"
    extra: String
    "The handle of the enqueued asset"
    handle: String
    "The ID of the enqueued asset"
    id: ID!
    "The source of the asset"
    src: String
    "The version of the enqueued asset"
    version: String
}

"Stylesheet enqueued by the CMS"
type BlogEnqueuedStylesheet implements BlogEnqueuedAsset & BlogNode {
    "@todo"
    args: Boolean
    "Dependencies needed to use this asset"
    dependencies: [BlogEnqueuedScript]
    "Extra information needed for the script"
    extra: String
    "The handle of the enqueued asset"
    handle: String
    "The ID of the enqueued asset"
    id: ID!
    "The source of the asset"
    src: String
    "The version of the enqueued asset"
    version: String
}

"The general setting type"
type BlogGeneralSettings {
    "A date format for all date strings."
    dateFormat: String
    "Site tagline."
    description: String
    "This address is used for admin purposes, like new user notification."
    email: String
    "WordPress locale code."
    language: String
    "A day number of the week that the week should start on."
    startOfWeek: Int
    "A time format for all time strings."
    timeFormat: String
    "A city in the same timezone as you."
    timezone: String
    "Site title."
    title: String
    "Site URL."
    url: String
}

"Connection between the HierarchicalContentNode type and the ContentNode type"
type BlogHierarchicalContentNodeToContentNodeAncestorsConnection {
    "Edges for the HierarchicalContentNodeToContentNodeAncestorsConnection connection"
    edges: [BlogHierarchicalContentNodeToContentNodeAncestorsConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogContentNode]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogHierarchicalContentNodeToContentNodeAncestorsConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogContentNode
}

"Connection between the HierarchicalContentNode type and the ContentNode type"
type BlogHierarchicalContentNodeToContentNodeChildrenConnection {
    "Edges for the HierarchicalContentNodeToContentNodeChildrenConnection connection"
    edges: [BlogHierarchicalContentNodeToContentNodeChildrenConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogContentNode]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogHierarchicalContentNodeToContentNodeChildrenConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogContentNode
}

"Connection between the HierarchicalContentNode type and the ContentNode type"
type BlogHierarchicalContentNodeToParentContentNodeConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogContentNode
}

"File details for a Media Item"
type BlogMediaDetails {
    "The filename of the mediaItem"
    file: String
    "The height of the mediaItem"
    height: Int
    "Meta information associated with the mediaItem"
    meta: BlogMediaItemMeta
    "The available sizes of the mediaItem"
    sizes: [BlogMediaSize]
    "The width of the mediaItem"
    width: Int
}

"The mediaItem type"
type BlogMediaItem implements BlogContentNode & BlogDatabaseIdentifier & BlogHierarchicalContentNode & BlogNode & BlogNodeWithAuthor & BlogNodeWithComments & BlogNodeWithTemplate & BlogNodeWithTitle & BlogUniformResourceIdentifiable {
    "Alternative text to display when resource is not displayed"
    altText: String
    "Returns ancestors of the node. Default ordered as lowest (closest to the child) to highest (closest to the root)."
    ancestors(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogHierarchicalContentNodeToContentNodeAncestorsConnectionWhereArgs
    ): BlogHierarchicalContentNodeToContentNodeAncestorsConnection
    "The database identifier of the author of the node"
    authorDatabaseId: Int
    "The globally unique identifier of the author of the node"
    authorId: ID
    "The caption for the resource"
    caption(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
    "Connection between the HierarchicalContentNode type and the ContentNode type"
    children(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogHierarchicalContentNodeToContentNodeChildrenConnectionWhereArgs
    ): BlogHierarchicalContentNodeToContentNodeChildrenConnection
    "The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility."
    commentCount: Int
    "Whether the comments are open or closed for this particular post."
    commentStatus: String
    "Connection between the mediaItem type and the Comment type"
    comments(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogMediaItemToCommentConnectionWhereArgs
    ): BlogMediaItemToCommentConnection
    "Connection between the ContentNode type and the ContentType type"
    contentType: BlogContentNodeToContentTypeConnectionEdge
    "The name of the Content Type the node belongs to"
    contentTypeName: String!
    "The unique identifier stored in the database"
    databaseId: Int!
    "Post publishing date."
    date: String
    "The publishing date set in GMT."
    dateGmt: String
    "Description of the image (stored as post_content)"
    description(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
    "The desired slug of the post"
    desiredSlug: String
    "If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds"
    editingLockedBy: BlogContentNodeToEditLockConnectionEdge
    "The RSS enclosure for the object"
    enclosure: String
    "Connection between the ContentNode type and the EnqueuedScript type"
    enqueuedScripts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogContentNodeToEnqueuedScriptConnection
    "Connection between the ContentNode type and the EnqueuedStylesheet type"
    enqueuedStylesheets(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogContentNodeToEnqueuedStylesheetConnection
    "The filesize in bytes of the resource"
    fileSize(
        "Size of the MediaItem to return"
        size: BlogMediaItemSizeEnum
    ): Int
    "The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table."
    guid: String
    "The globally unique identifier of the attachment object."
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether the object is a node in the preview state"
    isPreview: Boolean
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Whether the node is a Term"
    isTermNode: Boolean!
    "The user that most recently edited the node"
    lastEditedBy: BlogContentNodeToEditLastConnectionEdge
    "The permalink of the post"
    link: String
    "Details about the mediaItem"
    mediaDetails: BlogMediaDetails
    "The id field matches the WP_Post-&gt;ID field."
    mediaItemId: Int! @deprecated(reason : "Deprecated in favor of the databaseId field")
    "Url of the mediaItem"
    mediaItemUrl: String
    "Type of resource"
    mediaType: String
    "The mime type of the mediaItem"
    mimeType: String
    "The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time."
    modified: String
    "The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT."
    modifiedGmt: String
    "The parent of the node. The parent object can be of various types"
    parent: BlogHierarchicalContentNodeToParentContentNodeConnectionEdge
    "Database id of the parent node"
    parentDatabaseId: Int
    "The globally unique identifier of the parent node."
    parentId: ID
    "The database id of the preview node"
    previewRevisionDatabaseId: Int
    "Whether the object is a node in the preview state"
    previewRevisionId: ID
    "The sizes attribute value for an image."
    sizes(
        "Size of the MediaItem to calculate sizes with"
        size: BlogMediaItemSizeEnum
    ): String
    "The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table."
    slug: String
    "Url of the mediaItem"
    sourceUrl(
        "Size of the MediaItem to return"
        size: BlogMediaItemSizeEnum
    ): String
    "The srcset attribute specifies the URL of the image to use in different situations. It is a comma separated string of urls and their widths."
    srcSet(
        "Size of the MediaItem to calculate srcSet with"
        size: BlogMediaItemSizeEnum
    ): String
    "The current status of the object"
    status: String
    "The template assigned to the node"
    template: BlogContentTemplate
    "The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made."
    title(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
    "The unique resource identifier path"
    uri: String
    "Connection between the NodeWithAuthor type and the User type"
    wpAuthor: BlogNodeWithAuthorToUserConnectionEdge
}

"Meta connected to a MediaItem"
type BlogMediaItemMeta {
    "Aperture measurement of the media item."
    aperture: Float
    "Information about the camera used to create the media item."
    camera: String
    "The text string description associated with the media item."
    caption: String
    "Copyright information associated with the media item."
    copyright: String
    "The date/time when the media was created."
    createdTimestamp: Int
    "The original creator of the media item."
    credit: String
    "The focal length value of the media item."
    focalLength: Float
    "The ISO (International Organization for Standardization) value of the media item."
    iso: Int
    "List of keywords used to describe or identfy the media item."
    keywords: [String]
    "The vertical or horizontal aspect of the media item."
    orientation: String
    "The shutter speed information of the media item."
    shutterSpeed: Float
    "A useful title for the media item."
    title: String
}

"Connection between the mediaItem type and the Comment type"
type BlogMediaItemToCommentConnection {
    "Edges for the MediaItemToCommentConnection connection"
    edges: [BlogMediaItemToCommentConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogComment]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogMediaItemToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogComment
}

"Details of an available size for a media item"
type BlogMediaSize {
    "The filename of the referenced size"
    file: String
    "The filesize of the resource"
    fileSize: Int
    "The height of the referenced size"
    height: String
    "The mime type of the referenced size"
    mimeType: String
    "The referenced size name"
    name: String
    "The url of the referenced size"
    sourceUrl: String
    "The width of the referenced size"
    width: String
}

"Menus are the containers for navigation items. Menus can be assigned to menu locations, which are typically registered by the active theme."
type BlogMenu implements BlogDatabaseIdentifier & BlogNode {
    "The number of items in the menu"
    count: Int
    "The unique identifier stored in the database"
    databaseId: Int!
    "The globally unique identifier of the nav menu object."
    id: ID!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "The locations a menu is assigned to"
    locations: [BlogMenuLocationEnum]
    "WP ID of the nav menu."
    menuId: Int @deprecated(reason : "Deprecated in favor of the databaseId field")
    "Connection between the Menu type and the MenuItem type"
    menuItems(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogMenuToMenuItemConnectionWhereArgs
    ): BlogMenuToMenuItemConnection
    "Display name of the menu. Equivalent to WP_Term-&gt;name."
    name: String
    "The url friendly name of the menu. Equivalent to WP_Term-&gt;slug"
    slug: String
}

"Navigation menu items are the individual items assigned to a menu. These are rendered as the links in a navigation menu."
type BlogMenuItem implements BlogDatabaseIdentifier & BlogNode {
    "Connection between the MenuItem type and the MenuItem type"
    childItems(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogMenuItemToMenuItemConnectionWhereArgs
    ): BlogMenuItemToMenuItemConnection
    "Connection from MenuItem to it&#039;s connected node"
    connectedNode: BlogMenuItemToMenuItemLinkableConnectionEdge
    "The object connected to this menu item."
    connectedObject: BlogMenuItemObjectUnion @deprecated(reason : "Deprecated in favor of the connectedNode field")
    "Class attribute for the menu item link"
    cssClasses: [String]
    "The unique identifier stored in the database"
    databaseId: Int!
    "Description of the menu item."
    description: String
    "The globally unique identifier of the nav menu item object."
    id: ID!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Label or title of the menu item."
    label: String
    "Link relationship (XFN) of the menu item."
    linkRelationship: String
    "The locations the menu item&#039;s Menu is assigned to"
    locations: [BlogMenuLocationEnum]
    "The Menu a MenuItem is part of"
    menu: BlogMenuItemToMenuConnectionEdge
    "WP ID of the menu item."
    menuItemId: Int @deprecated(reason : "Deprecated in favor of the databaseId field")
    "Menu item order"
    order: Int
    "The database id of the parent menu item or null if it is the root"
    parentDatabaseId: Int
    "The globally unique identifier of the parent nav menu item object."
    parentId: ID
    "Path for the resource. Relative path for internal resources. Absolute path for external resources."
    path: String
    "Target attribute for the menu item link."
    target: String
    "Title attribute for the menu item link"
    title: String
    "URL or destination of the menu item."
    url: String
}

"Connection between the MenuItem type and the Menu type"
type BlogMenuItemToMenuConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogMenu
}

"Connection between the MenuItem type and the MenuItem type"
type BlogMenuItemToMenuItemConnection {
    "Edges for the MenuItemToMenuItemConnection connection"
    edges: [BlogMenuItemToMenuItemConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogMenuItem]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogMenuItemToMenuItemConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogMenuItem
}

"Connection between the MenuItem type and the MenuItemLinkable type"
type BlogMenuItemToMenuItemLinkableConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogMenuItemLinkable
}

"Connection between the Menu type and the MenuItem type"
type BlogMenuToMenuItemConnection {
    "Edges for the MenuToMenuItemConnection connection"
    edges: [BlogMenuToMenuItemConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogMenuItem]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogMenuToMenuItemConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogMenuItem
}

"Connection between the NodeWithAuthor type and the User type"
type BlogNodeWithAuthorToUserConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogUser
}

"Connection between the NodeWithFeaturedImage type and the MediaItem type"
type BlogNodeWithFeaturedImageToMediaItemConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogMediaItem
}

"Connection between the NodeWithRevisions type and the ContentNode type"
type BlogNodeWithRevisionsToContentNodeConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogContentNode
}

"The page type"
type BlogPage implements BlogContentNode & BlogDatabaseIdentifier & BlogHierarchicalContentNode & BlogMenuItemLinkable & BlogNode & BlogNodeWithAuthor & BlogNodeWithComments & BlogNodeWithContentEditor & BlogNodeWithFeaturedImage & BlogNodeWithPageAttributes & BlogNodeWithRevisions & BlogNodeWithTemplate & BlogNodeWithTitle & BlogUniformResourceIdentifiable {
    "Returns ancestors of the node. Default ordered as lowest (closest to the child) to highest (closest to the root)."
    ancestors(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogHierarchicalContentNodeToContentNodeAncestorsConnectionWhereArgs
    ): BlogHierarchicalContentNodeToContentNodeAncestorsConnection
    "The database identifier of the author of the node"
    authorDatabaseId: Int
    "The globally unique identifier of the author of the node"
    authorId: ID
    "Connection between the HierarchicalContentNode type and the ContentNode type"
    children(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogHierarchicalContentNodeToContentNodeChildrenConnectionWhereArgs
    ): BlogHierarchicalContentNodeToContentNodeChildrenConnection
    "The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility."
    commentCount: Int
    "Whether the comments are open or closed for this particular post."
    commentStatus: String
    "Connection between the page type and the Comment type"
    comments(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPageToCommentConnectionWhereArgs
    ): BlogPageToCommentConnection
    "The content of the post."
    content(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
    "Connection between the ContentNode type and the ContentType type"
    contentType: BlogContentNodeToContentTypeConnectionEdge
    "The name of the Content Type the node belongs to"
    contentTypeName: String!
    "The unique resource identifier path"
    databaseId: Int!
    "Post publishing date."
    date: String
    "The publishing date set in GMT."
    dateGmt: String
    "The desired slug of the post"
    desiredSlug: String
    "If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds"
    editingLockedBy: BlogContentNodeToEditLockConnectionEdge
    "The RSS enclosure for the object"
    enclosure: String
    "Connection between the ContentNode type and the EnqueuedScript type"
    enqueuedScripts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogContentNodeToEnqueuedScriptConnection
    "Connection between the ContentNode type and the EnqueuedStylesheet type"
    enqueuedStylesheets(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogContentNodeToEnqueuedStylesheetConnection
    "Connection between the NodeWithFeaturedImage type and the MediaItem type"
    featuredImage: BlogNodeWithFeaturedImageToMediaItemConnectionEdge
    "The database identifier for the featured image node assigned to the content node"
    featuredImageDatabaseId: Int
    "Globally unique ID of the featured image assigned to the node"
    featuredImageId: ID
    "The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table."
    guid: String
    "The globally unique identifier of the page object."
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether this page is set to the static front page."
    isFrontPage: Boolean!
    "Whether this page is set to the blog posts page."
    isPostsPage: Boolean!
    "Whether the object is a node in the preview state"
    isPreview: Boolean
    "Whether this page is set to the privacy page."
    isPrivacyPage: Boolean!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "True if the node is a revision of another node"
    isRevision: Boolean
    "Whether the node is a Term"
    isTermNode: Boolean!
    "The user that most recently edited the node"
    lastEditedBy: BlogContentNodeToEditLastConnectionEdge
    "The permalink of the post"
    link: String
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int
    "The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time."
    modified: String
    "The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT."
    modifiedGmt: String
    "The id field matches the WP_Post-&gt;ID field."
    pageId: Int! @deprecated(reason : "Deprecated in favor of the databaseId field")
    "The parent of the node. The parent object can be of various types"
    parent: BlogHierarchicalContentNodeToParentContentNodeConnectionEdge
    "Database id of the parent node"
    parentDatabaseId: Int
    "The globally unique identifier of the parent node."
    parentId: ID
    "Connection between the page type and the page type"
    preview: BlogPageToPreviewConnectionEdge
    "The database id of the preview node"
    previewRevisionDatabaseId: Int
    "Whether the object is a node in the preview state"
    previewRevisionId: ID
    "If the current node is a revision, this field exposes the node this is a revision of. Returns null if the node is not a revision of another node."
    revisionOf: BlogNodeWithRevisionsToContentNodeConnectionEdge
    "Connection between the page type and the page type"
    revisions(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPageToRevisionConnectionWhereArgs
    ): BlogPageToRevisionConnection
    "The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table."
    slug: String
    "The current status of the object"
    status: String
    "The template assigned to a node of content"
    template: BlogContentTemplate
    "The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made."
    title(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
    "The unique resource identifier path"
    uri: String
    "Connection between the NodeWithAuthor type and the User type"
    wpAuthor: BlogNodeWithAuthorToUserConnectionEdge
}

"Connection between the page type and the Comment type"
type BlogPageToCommentConnection {
    "Edges for the PageToCommentConnection connection"
    edges: [BlogPageToCommentConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogComment]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogPageToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogComment
}

"Connection between the page type and the page type"
type BlogPageToPreviewConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogPage
}

"Connection between the page type and the page type"
type BlogPageToRevisionConnection {
    "Edges for the pageToRevisionConnection connection"
    edges: [BlogPageToRevisionConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPage]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogPageToRevisionConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPage
}

"An plugin object"
type BlogPlugin implements BlogNode {
    "Name of the plugin author(s), may also be a company name."
    author: String
    "URI for the related author(s)/company website."
    authorUri: String
    "Description of the plugin."
    description: String
    "The globally unique identifier of the plugin object."
    id: ID!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Display name of the plugin."
    name: String
    "Plugin path."
    path: String
    "URI for the plugin website. This is useful for directing users for support requests etc."
    pluginUri: String
    "Current version of the plugin."
    version: String
}

"The post type"
type BlogPost implements BlogContentNode & BlogDatabaseIdentifier & BlogMenuItemLinkable & BlogNode & BlogNodeWithAuthor & BlogNodeWithComments & BlogNodeWithContentEditor & BlogNodeWithExcerpt & BlogNodeWithFeaturedImage & BlogNodeWithRevisions & BlogNodeWithTemplate & BlogNodeWithTitle & BlogNodeWithTrackbacks & BlogUniformResourceIdentifiable {
    author: AccountUser
    "The database identifier of the author of the node"
    authorDatabaseId: Int
    "The globally unique identifier of the author of the node"
    authorId: ID
    "Added to the GraphQL Schema because the ACF Field Group &quot;Author Override&quot; was set to Show in GraphQL."
    authorOverride: BlogPost_Authoroverride
    "Connection between the post type and the category type"
    categories(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostToCategoryConnectionWhereArgs
    ): BlogPostToCategoryConnection
    "The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility."
    commentCount: Int
    "Whether the comments are open or closed for this particular post."
    commentStatus: String
    "Connection between the post type and the Comment type"
    comments(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostToCommentConnectionWhereArgs
    ): BlogPostToCommentConnection
    "The content of the post."
    content(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
    "Connection between the ContentNode type and the ContentType type"
    contentType: BlogContentNodeToContentTypeConnectionEdge
    "The name of the Content Type the node belongs to"
    contentTypeName: String!
    "The unique resource identifier path"
    databaseId: Int!
    "Post publishing date."
    date: String
    "The publishing date set in GMT."
    dateGmt: String
    "The desired slug of the post"
    desiredSlug: String
    "If a user has edited the node within the past 15 seconds, this will return the user that last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds"
    editingLockedBy: BlogContentNodeToEditLockConnectionEdge
    "The RSS enclosure for the object"
    enclosure: String
    "Connection between the ContentNode type and the EnqueuedScript type"
    enqueuedScripts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogContentNodeToEnqueuedScriptConnection
    "Connection between the ContentNode type and the EnqueuedStylesheet type"
    enqueuedStylesheets(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogContentNodeToEnqueuedStylesheetConnection
    "The excerpt of the post."
    excerpt(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
    "Connection between the NodeWithFeaturedImage type and the MediaItem type"
    featuredImage: BlogNodeWithFeaturedImageToMediaItemConnectionEdge
    "The database identifier for the featured image node assigned to the content node"
    featuredImageDatabaseId: Int
    "Globally unique ID of the featured image assigned to the node"
    featuredImageId: ID
    "The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table."
    guid: String
    "The globally unique identifier of the post object."
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether the object is a node in the preview state"
    isPreview: Boolean
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "True if the node is a revision of another node"
    isRevision: Boolean
    "Whether this page is sticky"
    isSticky: Boolean!
    "Whether the node is a Term"
    isTermNode: Boolean!
    "The user that most recently edited the node"
    lastEditedBy: BlogContentNodeToEditLastConnectionEdge
    "The permalink of the post"
    link: String
    "The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time."
    modified: String
    "The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT."
    modifiedGmt: String
    "Whether the pings are open or closed for this particular post."
    pingStatus: String
    "URLs that have been pinged."
    pinged: [String]
    "Connection between the post type and the postFormat type"
    postFormats(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostToPostFormatConnectionWhereArgs
    ): BlogPostToPostFormatConnection
    "The id field matches the WP_Post-&gt;ID field."
    postId: Int! @deprecated(reason : "Deprecated in favor of the databaseId field")
    "Connection between the post type and the post type"
    preview: BlogPostToPreviewConnectionEdge
    "The database id of the preview node"
    previewRevisionDatabaseId: Int
    "Whether the object is a node in the preview state"
    previewRevisionId: ID
    "If the current node is a revision, this field exposes the node this is a revision of. Returns null if the node is not a revision of another node."
    revisionOf: BlogNodeWithRevisionsToContentNodeConnectionEdge
    "Connection between the post type and the post type"
    revisions(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostToRevisionConnectionWhereArgs
    ): BlogPostToRevisionConnection
    "The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table."
    slug: String
    "The current status of the object"
    status: String
    "Connection between the post type and the tag type"
    tags(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostToTagConnectionWhereArgs
    ): BlogPostToTagConnection
    "The template assigned to a node of content"
    template: BlogContentTemplate
    "Connection between the post type and the TermNode type"
    terms(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostToTermNodeConnectionWhereArgs
    ): BlogPostToTermNodeConnection
    "The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made."
    title(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
    "URLs queued to be pinged."
    toPing: [String]
    "The unique resource identifier path"
    uri: String
    "Connection between the NodeWithAuthor type and the User type"
    wpAuthor: BlogNodeWithAuthorToUserConnectionEdge
}

"The postFormat type"
type BlogPostFormat implements BlogDatabaseIdentifier & BlogNode & BlogTermNode & BlogUniformResourceIdentifiable {
    "Connection between the postFormat type and the ContentNode type"
    contentNodes(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostFormatToContentNodeConnectionWhereArgs
    ): BlogPostFormatToContentNodeConnection
    "The number of objects connected to the object"
    count: Int
    "The unique identifier stored in the database"
    databaseId: Int!
    "The description of the object"
    description: String
    "Connection between the TermNode type and the EnqueuedScript type"
    enqueuedScripts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogTermNodeToEnqueuedScriptConnection
    "Connection between the TermNode type and the EnqueuedStylesheet type"
    enqueuedStylesheets(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogTermNodeToEnqueuedStylesheetConnection
    "The unique resource identifier path"
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Whether the node is a Term"
    isTermNode: Boolean!
    "The link to the term"
    link: String
    "The human friendly name of the object."
    name: String
    "The id field matches the WP_Post-&gt;ID field."
    postFormatId: Int @deprecated(reason : "Deprecated in favor of databaseId")
    "Connection between the postFormat type and the post type"
    posts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostFormatToPostConnectionWhereArgs
    ): BlogPostFormatToPostConnection
    "An alphanumeric identifier for the object unique to its type."
    slug: String
    "Connection between the postFormat type and the Taxonomy type"
    taxonomy: BlogPostFormatToTaxonomyConnectionEdge
    "The name of the taxonomy that the object is associated with"
    taxonomyName: String
    "The ID of the term group that this term object belongs to"
    termGroupId: Int
    "The taxonomy ID that the object is associated with"
    termTaxonomyId: Int
    "The unique resource identifier path"
    uri: String
}

"Connection between the postFormat type and the ContentNode type"
type BlogPostFormatToContentNodeConnection {
    "Edges for the PostFormatToContentNodeConnection connection"
    edges: [BlogPostFormatToContentNodeConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogContentNode]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogPostFormatToContentNodeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogContentNode
}

"Connection between the postFormat type and the post type"
type BlogPostFormatToPostConnection {
    "Edges for the PostFormatToPostConnection connection"
    edges: [BlogPostFormatToPostConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPost]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogPostFormatToPostConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPost
}

"Connection between the postFormat type and the Taxonomy type"
type BlogPostFormatToTaxonomyConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogTaxonomy
}

"Connection between the post type and the category type"
type BlogPostToCategoryConnection {
    "Edges for the PostToCategoryConnection connection"
    edges: [BlogPostToCategoryConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogCategory]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogPostToCategoryConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogCategory
}

"Connection between the post type and the Comment type"
type BlogPostToCommentConnection {
    "Edges for the PostToCommentConnection connection"
    edges: [BlogPostToCommentConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogComment]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogPostToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogComment
}

"Connection between the post type and the postFormat type"
type BlogPostToPostFormatConnection {
    "Edges for the PostToPostFormatConnection connection"
    edges: [BlogPostToPostFormatConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPostFormat]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogPostToPostFormatConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPostFormat
}

"Connection between the post type and the post type"
type BlogPostToPreviewConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogPost
}

"Connection between the post type and the post type"
type BlogPostToRevisionConnection {
    "Edges for the postToRevisionConnection connection"
    edges: [BlogPostToRevisionConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPost]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogPostToRevisionConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPost
}

"Connection between the post type and the tag type"
type BlogPostToTagConnection {
    "Edges for the PostToTagConnection connection"
    edges: [BlogPostToTagConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogTag]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogPostToTagConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogTag
}

"Connection between the post type and the TermNode type"
type BlogPostToTermNodeConnection {
    "Edges for the PostToTermNodeConnection connection"
    edges: [BlogPostToTermNodeConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogTermNode]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogPostToTermNodeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogTermNode
}

"Details for labels of the PostType"
type BlogPostTypeLabelDetails {
    "Default is ‘Add New’ for both hierarchical and non-hierarchical types."
    addNew: String
    "Label for adding a new singular item."
    addNewItem: String
    "Label to signify all items in a submenu link."
    allItems: String
    "Label for archives in nav menus"
    archives: String
    "Label for the attributes meta box."
    attributes: String
    "Label for editing a singular item."
    editItem: String
    "Label for the Featured Image meta box title."
    featuredImage: String
    "Label for the table views hidden heading."
    filterItemsList: String
    "Label for the media frame button."
    insertIntoItem: String
    "Label for the table hidden heading."
    itemsList: String
    "Label for the table pagination hidden heading."
    itemsListNavigation: String
    "Label for the menu name."
    menuName: String
    "General name for the post type, usually plural."
    name: String
    "Label for the new item page title."
    newItem: String
    "Label used when no items are found."
    notFound: String
    "Label used when no items are in the trash."
    notFoundInTrash: String
    "Label used to prefix parents of hierarchical items."
    parentItemColon: String
    "Label for removing the featured image."
    removeFeaturedImage: String
    "Label for searching plural items."
    searchItems: String
    "Label for setting the featured image."
    setFeaturedImage: String
    "Name for one object of this post type."
    singularName: String
    "Label for the media frame filter."
    uploadedToThisItem: String
    "Label in the media frame for using a featured image."
    useFeaturedImage: String
    "Label for viewing a singular item."
    viewItem: String
    "Label for viewing post type archives."
    viewItems: String
}

"Field Group"
type BlogPost_Authoroverride implements BlogAcfFieldGroup {
    "The name of the ACF Field Group"
    fieldGroupName: String
    title: String
    username: String
}

"The reading setting type"
type BlogReadingSettings {
    "Blog pages show at most."
    postsPerPage: Int
}

"The payload for the registerUser mutation"
type BlogRegisterUserPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The User object mutation type."
    user: BlogUser
}

"The payload for the resetUserPassword mutation"
type BlogResetUserPasswordPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The User object mutation type."
    user: BlogUser
}

"The payload for the restoreComment mutation"
type BlogRestoreCommentPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The restored comment object"
    comment: BlogComment
    "The ID of the restored comment"
    restoredId: ID
}

type BlogRootMutation {
    "The payload for the createComment mutation"
    createComment(
        "Input for the createComment mutation"
        input: BlogCreateCommentInput!
    ): BlogCreateCommentPayload
}

type BlogRootQuery {
    "An object of the post Type. "
    post(
        "Whether to return the node as a preview instance"
        asPreview: Boolean,
        "The globally unique identifier of the object."
        id: ID!,
        "Type of unique identifier to fetch by. Default is Global ID"
        idType: BlogPostIdType
    ): BlogPost
    "Connection between the RootQuery type and the post type"
    posts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogRootQueryToPostConnectionWhereArgs
    ): BlogRootQueryToPostConnection
}

"Connection between the RootQuery type and the category type"
type BlogRootQueryToCategoryConnection {
    "Edges for the RootQueryToCategoryConnection connection"
    edges: [BlogRootQueryToCategoryConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogCategory]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToCategoryConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogCategory
}

"Connection between the RootQuery type and the Comment type"
type BlogRootQueryToCommentConnection {
    "Edges for the RootQueryToCommentConnection connection"
    edges: [BlogRootQueryToCommentConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogComment]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogComment
}

"Connection between the RootQuery type and the ContentNode type"
type BlogRootQueryToContentNodeConnection {
    "Edges for the RootQueryToContentNodeConnection connection"
    edges: [BlogRootQueryToContentNodeConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogContentNode]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToContentNodeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogContentNode
}

"Connection between the RootQuery type and the ContentRevisionUnion type"
type BlogRootQueryToContentRevisionUnionConnection {
    "Edges for the RootQueryToContentRevisionUnionConnection connection"
    edges: [BlogRootQueryToContentRevisionUnionConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogContentRevisionUnion]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToContentRevisionUnionConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogContentRevisionUnion
}

"Connection between the RootQuery type and the ContentType type"
type BlogRootQueryToContentTypeConnection {
    "Edges for the RootQueryToContentTypeConnection connection"
    edges: [BlogRootQueryToContentTypeConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogContentType]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToContentTypeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogContentType
}

"Connection between the RootQuery type and the EnqueuedScript type"
type BlogRootQueryToEnqueuedScriptConnection {
    "Edges for the RootQueryToEnqueuedScriptConnection connection"
    edges: [BlogRootQueryToEnqueuedScriptConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogEnqueuedScript]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToEnqueuedScriptConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogEnqueuedScript
}

"Connection between the RootQuery type and the EnqueuedStylesheet type"
type BlogRootQueryToEnqueuedStylesheetConnection {
    "Edges for the RootQueryToEnqueuedStylesheetConnection connection"
    edges: [BlogRootQueryToEnqueuedStylesheetConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogEnqueuedStylesheet]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToEnqueuedStylesheetConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogEnqueuedStylesheet
}

"Connection between the RootQuery type and the mediaItem type"
type BlogRootQueryToMediaItemConnection {
    "Edges for the RootQueryToMediaItemConnection connection"
    edges: [BlogRootQueryToMediaItemConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogMediaItem]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToMediaItemConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogMediaItem
}

"Connection between the RootQuery type and the Menu type"
type BlogRootQueryToMenuConnection {
    "Edges for the RootQueryToMenuConnection connection"
    edges: [BlogRootQueryToMenuConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogMenu]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToMenuConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogMenu
}

"Connection between the RootQuery type and the MenuItem type"
type BlogRootQueryToMenuItemConnection {
    "Edges for the RootQueryToMenuItemConnection connection"
    edges: [BlogRootQueryToMenuItemConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogMenuItem]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToMenuItemConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogMenuItem
}

"Connection between the RootQuery type and the page type"
type BlogRootQueryToPageConnection {
    "Edges for the RootQueryToPageConnection connection"
    edges: [BlogRootQueryToPageConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPage]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToPageConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPage
}

"Connection between the RootQuery type and the Plugin type"
type BlogRootQueryToPluginConnection {
    "Edges for the RootQueryToPluginConnection connection"
    edges: [BlogRootQueryToPluginConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPlugin]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToPluginConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPlugin
}

"Connection between the RootQuery type and the post type"
type BlogRootQueryToPostConnection {
    "Edges for the RootQueryToPostConnection connection"
    edges: [BlogRootQueryToPostConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPost]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToPostConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPost
}

"Connection between the RootQuery type and the postFormat type"
type BlogRootQueryToPostFormatConnection {
    "Edges for the RootQueryToPostFormatConnection connection"
    edges: [BlogRootQueryToPostFormatConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPostFormat]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToPostFormatConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPostFormat
}

"Connection between the RootQuery type and the tag type"
type BlogRootQueryToTagConnection {
    "Edges for the RootQueryToTagConnection connection"
    edges: [BlogRootQueryToTagConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogTag]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToTagConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogTag
}

"Connection between the RootQuery type and the Taxonomy type"
type BlogRootQueryToTaxonomyConnection {
    "Edges for the RootQueryToTaxonomyConnection connection"
    edges: [BlogRootQueryToTaxonomyConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogTaxonomy]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToTaxonomyConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogTaxonomy
}

"Connection between the RootQuery type and the TermNode type"
type BlogRootQueryToTermNodeConnection {
    "Edges for the RootQueryToTermNodeConnection connection"
    edges: [BlogRootQueryToTermNodeConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogTermNode]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToTermNodeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogTermNode
}

"Connection between the RootQuery type and the Theme type"
type BlogRootQueryToThemeConnection {
    "Edges for the RootQueryToThemeConnection connection"
    edges: [BlogRootQueryToThemeConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogTheme]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToThemeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogTheme
}

"Connection between the RootQuery type and the User type"
type BlogRootQueryToUserConnection {
    "Edges for the RootQueryToUserConnection connection"
    edges: [BlogRootQueryToUserConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogUser]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToUserConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogUser
}

"Connection between the RootQuery type and the UserRole type"
type BlogRootQueryToUserRoleConnection {
    "Edges for the RootQueryToUserRoleConnection connection"
    edges: [BlogRootQueryToUserRoleConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogUserRole]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogRootQueryToUserRoleConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogUserRole
}

"The payload for the sendPasswordResetEmail mutation"
type BlogSendPasswordResetEmailPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The user that the password reset email was sent to"
    user: BlogUser
}

"All of the registered settings"
type BlogSettings {
    "Settings of the the string Settings Group"
    discussionSettingsDefaultCommentStatus: String
    "Settings of the the string Settings Group"
    discussionSettingsDefaultPingStatus: String
    "Settings of the the string Settings Group"
    generalSettingsDateFormat: String
    "Settings of the the string Settings Group"
    generalSettingsDescription: String
    "Settings of the the string Settings Group"
    generalSettingsEmail: String
    "Settings of the the string Settings Group"
    generalSettingsLanguage: String
    "Settings of the the integer Settings Group"
    generalSettingsStartOfWeek: Int
    "Settings of the the string Settings Group"
    generalSettingsTimeFormat: String
    "Settings of the the string Settings Group"
    generalSettingsTimezone: String
    "Settings of the the string Settings Group"
    generalSettingsTitle: String
    "Settings of the the string Settings Group"
    generalSettingsUrl: String
    "Settings of the the integer Settings Group"
    readingSettingsPostsPerPage: Int
    "Settings of the the integer Settings Group"
    writingSettingsDefaultCategory: Int
    "Settings of the the string Settings Group"
    writingSettingsDefaultPostFormat: String
    "Settings of the the boolean Settings Group"
    writingSettingsUseSmilies: Boolean
}

"The tag type"
type BlogTag implements BlogDatabaseIdentifier & BlogMenuItemLinkable & BlogNode & BlogTermNode & BlogUniformResourceIdentifiable {
    "Connection between the tag type and the ContentNode type"
    contentNodes(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogTagToContentNodeConnectionWhereArgs
    ): BlogTagToContentNodeConnection
    "The number of objects connected to the object"
    count: Int
    "The unique resource identifier path"
    databaseId: Int!
    "The description of the object"
    description: String
    "Added to the GraphQL Schema because the ACF Field Group &quot;Display&quot; was set to Show in GraphQL."
    display: BlogTag_Display
    "Connection between the TermNode type and the EnqueuedScript type"
    enqueuedScripts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogTermNodeToEnqueuedScriptConnection
    "Connection between the TermNode type and the EnqueuedStylesheet type"
    enqueuedStylesheets(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogTermNodeToEnqueuedStylesheetConnection
    "The unique resource identifier path"
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Whether the node is a Term"
    isTermNode: Boolean!
    "The link to the term"
    link: String
    "The human friendly name of the object."
    name: String
    "Connection between the tag type and the post type"
    posts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogTagToPostConnectionWhereArgs
    ): BlogTagToPostConnection
    "An alphanumeric identifier for the object unique to its type."
    slug: String
    "The id field matches the WP_Post-&gt;ID field."
    tagId: Int @deprecated(reason : "Deprecated in favor of databaseId")
    "Connection between the tag type and the Taxonomy type"
    taxonomy: BlogTagToTaxonomyConnectionEdge
    "The name of the taxonomy that the object is associated with"
    taxonomyName: String
    "The ID of the term group that this term object belongs to"
    termGroupId: Int
    "The taxonomy ID that the object is associated with"
    termTaxonomyId: Int
    "The unique resource identifier path"
    uri: String
}

"Connection between the tag type and the ContentNode type"
type BlogTagToContentNodeConnection {
    "Edges for the TagToContentNodeConnection connection"
    edges: [BlogTagToContentNodeConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogContentNode]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogTagToContentNodeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogContentNode
}

"Connection between the tag type and the post type"
type BlogTagToPostConnection {
    "Edges for the TagToPostConnection connection"
    edges: [BlogTagToPostConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPost]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogTagToPostConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPost
}

"Connection between the tag type and the Taxonomy type"
type BlogTagToTaxonomyConnectionEdge {
    "The node of the connection, without the edges"
    node: BlogTaxonomy
}

"Field Group"
type BlogTag_Display implements BlogAcfFieldGroup {
    color: String
    "The name of the ACF Field Group"
    fieldGroupName: String
}

"A taxonomy object"
type BlogTaxonomy implements BlogNode {
    "List of Content Types associated with the Taxonomy"
    connectedContentTypes(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogTaxonomyToContentTypeConnection
    "Description of the taxonomy. This field is equivalent to WP_Taxonomy-&gt;description"
    description: String
    "The plural name of the post type within the GraphQL Schema."
    graphqlPluralName: String
    "The singular name of the post type within the GraphQL Schema."
    graphqlSingleName: String
    "Whether the taxonomy is hierarchical"
    hierarchical: Boolean
    "The globally unique identifier of the taxonomy object."
    id: ID!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Name of the taxonomy shown in the menu. Usually plural."
    label: String
    "The display name of the taxonomy. This field is equivalent to WP_Taxonomy-&gt;label"
    name: String
    "Whether the taxonomy is publicly queryable"
    public: Boolean
    "Name of content type to diplay in REST API &quot;wp/v2&quot; namespace."
    restBase: String
    "The REST Controller class assigned to handling this content type."
    restControllerClass: String
    "Whether to show the taxonomy as part of a tag cloud widget. This field is equivalent to WP_Taxonomy-&gt;show_tagcloud"
    showCloud: Boolean
    "Whether to display a column for the taxonomy on its post type listing screens."
    showInAdminColumn: Boolean
    "Whether to add the post type to the GraphQL Schema."
    showInGraphql: Boolean
    "Whether to show the taxonomy in the admin menu"
    showInMenu: Boolean
    "Whether the taxonomy is available for selection in navigation menus."
    showInNavMenus: Boolean
    "Whether to show the taxonomy in the quick/bulk edit panel."
    showInQuickEdit: Boolean
    "Whether to add the post type route in the REST API &quot;wp/v2&quot; namespace."
    showInRest: Boolean
    "Whether to generate and allow a UI for managing terms in this taxonomy in the admin"
    showUi: Boolean
}

"Connection between the Taxonomy type and the ContentType type"
type BlogTaxonomyToContentTypeConnection {
    "Edges for the TaxonomyToContentTypeConnection connection"
    edges: [BlogTaxonomyToContentTypeConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogContentType]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogTaxonomyToContentTypeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogContentType
}

"Connection between the TermNode type and the EnqueuedScript type"
type BlogTermNodeToEnqueuedScriptConnection {
    "Edges for the TermNodeToEnqueuedScriptConnection connection"
    edges: [BlogTermNodeToEnqueuedScriptConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogEnqueuedScript]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogTermNodeToEnqueuedScriptConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogEnqueuedScript
}

"Connection between the TermNode type and the EnqueuedStylesheet type"
type BlogTermNodeToEnqueuedStylesheetConnection {
    "Edges for the TermNodeToEnqueuedStylesheetConnection connection"
    edges: [BlogTermNodeToEnqueuedStylesheetConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogEnqueuedStylesheet]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogTermNodeToEnqueuedStylesheetConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogEnqueuedStylesheet
}

"A theme object"
type BlogTheme implements BlogNode {
    "Name of the theme author(s), could also be a company name. This field is equivalent to WP_Theme-&gt;get( &quot;Author&quot; )."
    author: String
    "URI for the author/company website. This field is equivalent to WP_Theme-&gt;get( &quot;AuthorURI&quot; )."
    authorUri: String
    "The description of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Description&quot; )."
    description: String
    "The globally unique identifier of the theme object."
    id: ID!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Display name of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Name&quot; )."
    name: String
    "The URL of the screenshot for the theme. The screenshot is intended to give an overview of what the theme looks like. This field is equivalent to WP_Theme-&gt;get_screenshot()."
    screenshot: String
    "The theme slug is used to internally match themes. Theme slugs can have subdirectories like: my-theme/sub-theme. This field is equivalent to WP_Theme-&gt;get_stylesheet()."
    slug: String
    "URI for the author/company website. This field is equivalent to WP_Theme-&gt;get( &quot;Tags&quot; )."
    tags: [String]
    "A URI if the theme has a website associated with it. The Theme URI is handy for directing users to a theme site for support etc. This field is equivalent to WP_Theme-&gt;get( &quot;ThemeURI&quot; )."
    themeUri: String
    "The current version of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Version&quot; )."
    version: String
}

"The payload for the UpdateCategory mutation"
type BlogUpdateCategoryPayload {
    "The created category"
    category: BlogCategory
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
}

"The payload for the updateComment mutation"
type BlogUpdateCommentPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The comment that was created"
    comment: BlogComment
    "Whether the mutation succeeded. If the comment is not approved, the server will not return the comment to a non authenticated user, but a success message can be returned if the create succeeded, and the client can optimistically add the comment to the client cache"
    success: Boolean
}

"The payload for the updateMediaItem mutation"
type BlogUpdateMediaItemPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The MediaItem object mutation type."
    mediaItem: BlogMediaItem
}

"The payload for the updatePage mutation"
type BlogUpdatePagePayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The Post object mutation type."
    page: BlogPage
}

"The payload for the UpdatePostFormat mutation"
type BlogUpdatePostFormatPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The created post_format"
    postFormat: BlogPostFormat
}

"The payload for the updatePost mutation"
type BlogUpdatePostPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The Post object mutation type."
    post: BlogPost
}

"The payload for the updateSettings mutation"
type BlogUpdateSettingsPayload {
    "Update all settings."
    allSettings: BlogSettings
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "Update the discussion setting."
    discussionSettings: BlogDiscussionSettings
    "Update the general setting."
    generalSettings: BlogGeneralSettings
    "Update the reading setting."
    readingSettings: BlogReadingSettings
    "Update the writing setting."
    writingSettings: BlogWritingSettings
}

"The payload for the UpdateTag mutation"
type BlogUpdateTagPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The created post_tag"
    tag: BlogTag
}

"The payload for the updateUser mutation"
type BlogUpdateUserPayload {
    "If a &#039;clientMutationId&#039; input is provided to the mutation, it will be returned as output on the mutation. This ID can be used by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The User object mutation type."
    user: BlogUser
}

"A User object"
type BlogUser implements BlogCommenter & BlogDatabaseIdentifier & BlogNode & BlogUniformResourceIdentifiable {
    "Avatar object for user. The avatar object can be retrieved in different sizes by specifying the size argument."
    avatar(
        "Whether to always show the default image, never the Gravatar. Default false"
        forceDefault: Boolean,
        "The rating level of the avatar."
        rating: BlogAvatarRatingEnum,
        "The size attribute of the avatar field can be used to fetch avatars of different sizes. The value corresponds to the dimension in pixels to fetch. The default is 96 pixels."
        size: Int = 96
    ): BlogAvatar
    "User metadata option name. Usually it will be &quot;wp_capabilities&quot;."
    capKey: String
    "A list of capabilities (permissions) granted to the user"
    capabilities: [String]
    "Connection between the User type and the Comment type"
    comments(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogUserToCommentConnectionWhereArgs
    ): BlogUserToCommentConnection
    "Identifies the primary key from the database."
    databaseId: Int!
    "Description of the user."
    description: String
    "Email address of the user. This is equivalent to the WP_User-&gt;user_email property."
    email: String
    "Connection between the User type and the EnqueuedScript type"
    enqueuedScripts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogUserToEnqueuedScriptConnection
    "Connection between the User type and the EnqueuedStylesheet type"
    enqueuedStylesheets(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogUserToEnqueuedStylesheetConnection
    "A complete list of capabilities including capabilities inherited from a role. This is equivalent to the array keys of WP_User-&gt;allcaps."
    extraCapabilities: [String]
    "First name of the user. This is equivalent to the WP_User-&gt;user_first_name property."
    firstName: String
    "The globally unique identifier for the user object."
    id: ID!
    "Whether the node is a Content Node"
    isContentNode: Boolean!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "Whether the node is a Term"
    isTermNode: Boolean!
    "Last name of the user. This is equivalent to the WP_User-&gt;user_last_name property."
    lastName: String
    "The preferred language locale set for the user. Value derived from get_user_locale()."
    locale: String
    "Connection between the User type and the mediaItem type"
    mediaItems(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogUserToMediaItemConnectionWhereArgs
    ): BlogUserToMediaItemConnection
    "Display name of the user. This is equivalent to the WP_User-&gt;dispaly_name property."
    name: String
    "The nicename for the user. This field is equivalent to WP_User-&gt;user_nicename"
    nicename: String
    "Nickname of the user."
    nickname: String
    "Connection between the User type and the page type"
    pages(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogUserToPageConnectionWhereArgs
    ): BlogUserToPageConnection
    "Connection between the User type and the post type"
    posts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogUserToPostConnectionWhereArgs
    ): BlogUserToPostConnection
    "The date the user registered or was created. The field follows a full ISO8601 date string format."
    registeredDate: String
    "Connection between the User and Revisions authored by the user"
    revisions(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int,
        "Arguments for filtering the connection"
        where: BlogUserToContentRevisionUnionConnectionWhereArgs
    ): BlogUserToContentRevisionUnionConnection
    "Connection between the User type and the UserRole type"
    roles(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        "The number of items to return before the referenced \"before\" cursor"
        last: Int
    ): BlogUserToUserRoleConnection
    "The slug for the user. This field is equivalent to WP_User-&gt;user_nicename"
    slug: String
    "The unique resource identifier path"
    uri: String
    "A website url that is associated with the user."
    url: String
    "The Id of the user. Equivalent to WP_User-&gt;ID"
    userId: Int @deprecated(reason : "Deprecated in favor of the databaseId field")
    "Username for the user. This field is equivalent to WP_User-&gt;user_login."
    username: String
}

"A user role object"
type BlogUserRole implements BlogNode {
    "The capabilities that belong to this role"
    capabilities: [String]
    "The display name of the role"
    displayName: String
    "The globally unique identifier for the user role object."
    id: ID!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "The registered name of the role"
    name: String
}

"Connection between the User type and the Comment type"
type BlogUserToCommentConnection {
    "Edges for the UserToCommentConnection connection"
    edges: [BlogUserToCommentConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogComment]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogUserToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogComment
}

"Connection between the User type and the ContentRevisionUnion type"
type BlogUserToContentRevisionUnionConnection {
    "Edges for the UserToContentRevisionUnionConnection connection"
    edges: [BlogUserToContentRevisionUnionConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogContentRevisionUnion]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogUserToContentRevisionUnionConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogContentRevisionUnion
}

"Connection between the User type and the EnqueuedScript type"
type BlogUserToEnqueuedScriptConnection {
    "Edges for the UserToEnqueuedScriptConnection connection"
    edges: [BlogUserToEnqueuedScriptConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogEnqueuedScript]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogUserToEnqueuedScriptConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogEnqueuedScript
}

"Connection between the User type and the EnqueuedStylesheet type"
type BlogUserToEnqueuedStylesheetConnection {
    "Edges for the UserToEnqueuedStylesheetConnection connection"
    edges: [BlogUserToEnqueuedStylesheetConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogEnqueuedStylesheet]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogUserToEnqueuedStylesheetConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogEnqueuedStylesheet
}

"Connection between the User type and the mediaItem type"
type BlogUserToMediaItemConnection {
    "Edges for the UserToMediaItemConnection connection"
    edges: [BlogUserToMediaItemConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogMediaItem]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogUserToMediaItemConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogMediaItem
}

"Connection between the User type and the page type"
type BlogUserToPageConnection {
    "Edges for the UserToPageConnection connection"
    edges: [BlogUserToPageConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPage]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogUserToPageConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPage
}

"Connection between the User type and the post type"
type BlogUserToPostConnection {
    "Edges for the UserToPostConnection connection"
    edges: [BlogUserToPostConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogPost]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogUserToPostConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogPost
}

"Connection between the User type and the UserRole type"
type BlogUserToUserRoleConnection {
    "Edges for the UserToUserRoleConnection connection"
    edges: [BlogUserToUserRoleConnectionEdge]
    "The nodes of the connection, without the edges"
    nodes: [BlogUserRole]
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo
}

"An edge in a connection"
type BlogUserToUserRoleConnectionEdge {
    "A cursor for use in pagination"
    cursor: String
    "The item at the end of the edge"
    node: BlogUserRole
}

"Information about pagination in a connection."
type BlogWPPageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

"The writing setting type"
type BlogWritingSettings {
    "Default post category."
    defaultCategory: Int
    "Default post format."
    defaultPostFormat: String
    "Convert emoticons like :-) and :-P to graphics on display."
    useSmilies: Boolean
}

type CalendarCalendarEvent {
    calendarId: String!
    calendarName: String!
    description: String!
    end: CalendarDateTime!
    id: ID!
    location: String!
    metadata: CalendarJSONObject!
    start: CalendarDateTime!
    subscriberCount: Float!
    title: String!
}

type CalendarMutation {
    subscribe(calendarId: String!, destination: String!, eventId: String!): Boolean!
}

type CalendarQuery {
    event(calendars: [String!], format: CalendarFormat = HTML, id: ID!): CalendarCalendarEvent
    events(after: CalendarDateTime!, before: CalendarDateTime!, calendars: [String!], exceptCalendars: [String!], format: CalendarFormat = HTML, order: CalendarOrder = ASC, skip: Float = 0.0, take: Float = 100.0): [CalendarCalendarEvent!]!
}

type ClearAffectedRowsOutput {
    count: Int!
}

type ClearAggregateEmailTemplate {
    _count: ClearEmailTemplateCountAggregate
    _max: ClearEmailTemplateMaxAggregate
    _min: ClearEmailTemplateMinAggregate
}

type ClearAggregateEvent {
    _avg: ClearEventAvgAggregate
    _count: ClearEventCountAggregate
    _max: ClearEventMaxAggregate
    _min: ClearEventMinAggregate
    _sum: ClearEventSumAggregate
}

type ClearAggregateEventGroup {
    _avg: ClearEventGroupAvgAggregate
    _count: ClearEventGroupCountAggregate
    _max: ClearEventGroupMaxAggregate
    _min: ClearEventGroupMinAggregate
    _sum: ClearEventGroupSumAggregate
}

type ClearAggregateEventRestriction {
    _count: ClearEventRestrictionCountAggregate
    _max: ClearEventRestrictionMaxAggregate
    _min: ClearEventRestrictionMinAggregate
}

type ClearAggregateMailingListMember {
    _count: ClearMailingListMemberCountAggregate
    _max: ClearMailingListMemberMaxAggregate
    _min: ClearMailingListMemberMinAggregate
}

type ClearAggregatePayment {
    _count: ClearPaymentCountAggregate
    _max: ClearPaymentMaxAggregate
    _min: ClearPaymentMinAggregate
}

type ClearAggregatePerson {
    _avg: ClearPersonAvgAggregate
    _count: ClearPersonCountAggregate
    _max: ClearPersonMaxAggregate
    _min: ClearPersonMinAggregate
    _sum: ClearPersonSumAggregate
}

type ClearAggregatePromoCode {
    _avg: ClearPromoCodeAvgAggregate
    _count: ClearPromoCodeCountAggregate
    _max: ClearPromoCodeMaxAggregate
    _min: ClearPromoCodeMinAggregate
    _sum: ClearPromoCodeSumAggregate
}

type ClearAggregateScheduleItem {
    _count: ClearScheduleItemCountAggregate
    _max: ClearScheduleItemMaxAggregate
    _min: ClearScheduleItemMinAggregate
}

type ClearAggregateSponsor {
    _avg: ClearSponsorAvgAggregate
    _count: ClearSponsorCountAggregate
    _max: ClearSponsorMaxAggregate
    _min: ClearSponsorMinAggregate
    _sum: ClearSponsorSumAggregate
}

type ClearAggregateTicket {
    _avg: ClearTicketAvgAggregate
    _count: ClearTicketCountAggregate
    _max: ClearTicketMaxAggregate
    _min: ClearTicketMinAggregate
    _sum: ClearTicketSumAggregate
}

type ClearAggregateVenue {
    _avg: ClearVenueAvgAggregate
    _count: ClearVenueCountAggregate
    _max: ClearVenueMaxAggregate
    _min: ClearVenueMinAggregate
    _sum: ClearVenueSumAggregate
}

type ClearEmailTemplate {
    _count: ClearEmailTemplateCount
    automatic: Boolean!
    createdAt: ClearDateTime!
    extraFilters: ClearJSON
    fromEmail: String!
    fromName: String!
    getMetadata(key: String!): String
    id: String!
    marketing: Boolean!
    name: String!
    previewEmailBody: String!
    replyTo: String!
    sendAfterEvent: Boolean!
    sendInWorkHours: Boolean!
    sendLate: Boolean!
    sendParent: Boolean!
    sendText: Boolean!
    sendTo: ClearTicketType!
    sentTo(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicket!]!
    subject: String!
    template: String!
    textMsg: String
    updatedAt: ClearDateTime!
    when: String!
    whenFrom: ClearEmailWhenFrom!
}

type ClearEmailTemplateCount {
    sentTo: Int!
}

type ClearEmailTemplateCountAggregate {
    _all: Int!
    automatic: Int!
    createdAt: Int!
    extraFilters: Int!
    fromEmail: Int!
    fromName: Int!
    id: Int!
    marketing: Int!
    metadata: Int!
    name: Int!
    replyTo: Int!
    sendAfterEvent: Int!
    sendInWorkHours: Int!
    sendLate: Int!
    sendParent: Int!
    sendText: Int!
    sendTo: Int!
    subject: Int!
    template: Int!
    textMsg: Int!
    updatedAt: Int!
    when: Int!
    whenFrom: Int!
}

type ClearEmailTemplateGroupBy {
    _count: ClearEmailTemplateCountAggregate
    _max: ClearEmailTemplateMaxAggregate
    _min: ClearEmailTemplateMinAggregate
    automatic: Boolean!
    createdAt: ClearDateTime!
    extraFilters: ClearJSON
    fromEmail: String!
    fromName: String!
    id: String!
    marketing: Boolean!
    metadata: ClearJSON
    name: String!
    replyTo: String!
    sendAfterEvent: Boolean!
    sendInWorkHours: Boolean!
    sendLate: Boolean!
    sendParent: Boolean!
    sendText: Boolean!
    sendTo: ClearTicketType!
    subject: String!
    template: String!
    textMsg: String
    updatedAt: ClearDateTime!
    when: String!
    whenFrom: ClearEmailWhenFrom!
}

type ClearEmailTemplateMaxAggregate {
    automatic: Boolean
    createdAt: ClearDateTime
    fromEmail: String
    fromName: String
    id: String
    marketing: Boolean
    name: String
    replyTo: String
    sendAfterEvent: Boolean
    sendInWorkHours: Boolean
    sendLate: Boolean
    sendParent: Boolean
    sendText: Boolean
    sendTo: ClearTicketType
    subject: String
    template: String
    textMsg: String
    updatedAt: ClearDateTime
    when: String
    whenFrom: ClearEmailWhenFrom
}

type ClearEmailTemplateMinAggregate {
    automatic: Boolean
    createdAt: ClearDateTime
    fromEmail: String
    fromName: String
    id: String
    marketing: Boolean
    name: String
    replyTo: String
    sendAfterEvent: Boolean
    sendInWorkHours: Boolean
    sendLate: Boolean
    sendParent: Boolean
    sendText: Boolean
    sendTo: ClearTicketType
    subject: String
    template: String
    textMsg: String
    updatedAt: ClearDateTime
    when: String
    whenFrom: ClearEmailWhenFrom
}

type ClearEvent {
    _count: ClearEventCount
    activeTicketPrice: Float
    canEarlyBirdRegister: Boolean!
    canRegister: Boolean!
    checkPromoCode(code: String!): ClearJSONObject!
    contentfulWebname: String
    createdAt: ClearDateTime!
    displayDate: String!
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroup!
    eventGroupId: String!
    eventRestrictions(cursor: ClearEventRestrictionWhereUniqueInput, distinct: [ClearEventRestrictionScalarFieldEnum!], orderBy: [ClearEventRestrictionOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventRestrictionWhereInput): [ClearEventRestriction!]!
    getMetadata(key: String!): String
    id: String!
    interestedEmails(cursor: ClearMailingListMemberWhereUniqueInput, distinct: [ClearMailingListMemberScalarFieldEnum!], orderBy: [ClearMailingListMemberOrderByWithRelationInput!], skip: Int, take: Int, where: ClearMailingListMemberWhereInput): [ClearMailingListMember!]!
    majorityAge: Int!
    managers: [String!]!
    maxAge: Float!
    minAge: Float!
    name: String!
    promoCodes(cursor: ClearPromoCodeWhereUniqueInput, distinct: [ClearPromoCodeScalarFieldEnum!], orderBy: [ClearPromoCodeOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPromoCodeWhereInput): [ClearPromoCode!]!
    region: CmsRegion
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean!
    remainingTickets: Float
    schedule(cursor: ClearScheduleItemWhereUniqueInput, distinct: [ClearScheduleItemScalarFieldEnum!], orderBy: [ClearScheduleItemOrderByWithRelationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): [ClearScheduleItem!]!
    showcaseId: String
    soldTickets(onlyStudents: Boolean = false): Float!
    sponsors(cursor: ClearSponsorWhereUniqueInput, distinct: [ClearSponsorScalarFieldEnum!], orderBy: [ClearSponsorOrderByWithRelationInput!], skip: Int, take: Int, where: ClearSponsorWhereInput): [ClearSponsor!]!
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicket!]!
    timezone: String
    updatedAt: ClearDateTime!
    venue: ClearVenue
    venueId: String
}

type ClearEventAvgAggregate {
    earlyBirdPrice: Float
    majorityAge: Float
    ticketPrice: Float
}

type ClearEventCount {
    eventRestrictions: Int!
    interestedEmails: Int!
    promoCodes: Int!
    schedule: Int!
    sponsors: Int!
    tickets: Int!
}

type ClearEventCountAggregate {
    _all: Int!
    contentfulWebname: Int!
    createdAt: Int!
    earlyBirdCutoff: Int!
    earlyBirdPrice: Int!
    endDate: Int!
    eventGroupId: Int!
    id: Int!
    majorityAge: Int!
    managers: Int!
    metadata: Int!
    name: Int!
    registrationCutoff: Int!
    registrationsOpen: Int!
    showcaseId: Int!
    startDate: Int!
    ticketPrice: Int!
    timezone: Int!
    updatedAt: Int!
    venueId: Int!
}

type ClearEventGroup {
    _count: ClearEventGroupCount
    createdAt: ClearDateTime!
    displayDate: String!
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    events(cursor: ClearEventWhereUniqueInput, distinct: [ClearEventScalarFieldEnum!], orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): [ClearEvent!]!
    getMetadata(key: String!): String
    id: String!
    name: String!
    promoCodes(cursor: ClearPromoCodeWhereUniqueInput, distinct: [ClearPromoCodeScalarFieldEnum!], orderBy: [ClearPromoCodeOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPromoCodeWhereInput): [ClearPromoCode!]!
    registrationCutoff: ClearDateTime!
    schedule(cursor: ClearScheduleItemWhereUniqueInput, distinct: [ClearScheduleItemScalarFieldEnum!], orderBy: [ClearScheduleItemOrderByWithRelationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): [ClearScheduleItem!]!
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime!
}

type ClearEventGroupAvgAggregate {
    earlyBirdPrice: Float
    ticketPrice: Float
}

type ClearEventGroupBy {
    _avg: ClearEventAvgAggregate
    _count: ClearEventCountAggregate
    _max: ClearEventMaxAggregate
    _min: ClearEventMinAggregate
    _sum: ClearEventSumAggregate
    contentfulWebname: String
    createdAt: ClearDateTime!
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroupId: String!
    id: String!
    majorityAge: Int!
    managers: [String!]
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean!
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    timezone: String
    updatedAt: ClearDateTime!
    venueId: String
}

type ClearEventGroupCount {
    events: Int!
    promoCodes: Int!
    schedule: Int!
}

type ClearEventGroupCountAggregate {
    _all: Int!
    createdAt: Int!
    earlyBirdCutoff: Int!
    earlyBirdPrice: Int!
    endDate: Int!
    id: Int!
    metadata: Int!
    name: Int!
    registrationCutoff: Int!
    showcaseId: Int!
    startDate: Int!
    ticketPrice: Int!
    updatedAt: Int!
}

type ClearEventGroupGroupBy {
    _avg: ClearEventGroupAvgAggregate
    _count: ClearEventGroupCountAggregate
    _max: ClearEventGroupMaxAggregate
    _min: ClearEventGroupMinAggregate
    _sum: ClearEventGroupSumAggregate
    createdAt: ClearDateTime!
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    id: String!
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime!
}

type ClearEventGroupMaxAggregate {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime
    earlyBirdPrice: Float
    endDate: ClearDateTime
    id: String
    name: String
    registrationCutoff: ClearDateTime
    showcaseId: String
    startDate: ClearDateTime
    ticketPrice: Float
    updatedAt: ClearDateTime
}

type ClearEventGroupMinAggregate {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime
    earlyBirdPrice: Float
    endDate: ClearDateTime
    id: String
    name: String
    registrationCutoff: ClearDateTime
    showcaseId: String
    startDate: ClearDateTime
    ticketPrice: Float
    updatedAt: ClearDateTime
}

type ClearEventGroupSumAggregate {
    earlyBirdPrice: Float
    ticketPrice: Float
}

type ClearEventMaxAggregate {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime
    earlyBirdPrice: Float
    endDate: ClearDateTime
    eventGroupId: String
    id: String
    majorityAge: Int
    name: String
    registrationCutoff: ClearDateTime
    registrationsOpen: Boolean
    showcaseId: String
    startDate: ClearDateTime
    ticketPrice: Float
    timezone: String
    updatedAt: ClearDateTime
    venueId: String
}

type ClearEventMinAggregate {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime
    earlyBirdPrice: Float
    endDate: ClearDateTime
    eventGroupId: String
    id: String
    majorityAge: Int
    name: String
    registrationCutoff: ClearDateTime
    registrationsOpen: Boolean
    showcaseId: String
    startDate: ClearDateTime
    ticketPrice: Float
    timezone: String
    updatedAt: ClearDateTime
    venueId: String
}

type ClearEventRestriction {
    Events(cursor: ClearEventWhereUniqueInput, distinct: [ClearEventScalarFieldEnum!], orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): [ClearEvent!]!
    _count: ClearEventRestrictionCount
    createdAt: ClearDateTime!
    details: String
    getMetadata(key: String!): String
    iconUri: String
    id: String!
    name: String!
    title: String!
    updatedAt: ClearDateTime!
}

type ClearEventRestrictionCount {
    Events: Int!
}

type ClearEventRestrictionCountAggregate {
    _all: Int!
    createdAt: Int!
    details: Int!
    iconUri: Int!
    id: Int!
    metadata: Int!
    name: Int!
    title: Int!
    updatedAt: Int!
}

type ClearEventRestrictionGroupBy {
    _count: ClearEventRestrictionCountAggregate
    _max: ClearEventRestrictionMaxAggregate
    _min: ClearEventRestrictionMinAggregate
    createdAt: ClearDateTime!
    details: String
    iconUri: String
    id: String!
    metadata: ClearJSON
    name: String!
    title: String!
    updatedAt: ClearDateTime!
}

type ClearEventRestrictionMaxAggregate {
    createdAt: ClearDateTime
    details: String
    iconUri: String
    id: String
    name: String
    title: String
    updatedAt: ClearDateTime
}

type ClearEventRestrictionMinAggregate {
    createdAt: ClearDateTime
    details: String
    iconUri: String
    id: String
    name: String
    title: String
    updatedAt: ClearDateTime
}

type ClearEventSumAggregate {
    earlyBirdPrice: Float
    majorityAge: Int
    ticketPrice: Float
}

type ClearMailingListMember {
    _count: ClearMailingListMemberCount
    createdAt: ClearDateTime!
    email: String!
    getMetadata(key: String!): String
    id: String!
    interestedInEvents(cursor: ClearEventWhereUniqueInput, distinct: [ClearEventScalarFieldEnum!], orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): [ClearEvent!]!
    lastEmailed: ClearDateTime
    updatedAt: ClearDateTime!
}

type ClearMailingListMemberCount {
    interestedInEvents: Int!
}

type ClearMailingListMemberCountAggregate {
    _all: Int!
    createdAt: Int!
    email: Int!
    id: Int!
    lastEmailed: Int!
    metadata: Int!
    updatedAt: Int!
}

type ClearMailingListMemberGroupBy {
    _count: ClearMailingListMemberCountAggregate
    _max: ClearMailingListMemberMaxAggregate
    _min: ClearMailingListMemberMinAggregate
    createdAt: ClearDateTime!
    email: String!
    id: String!
    lastEmailed: ClearDateTime
    metadata: ClearJSON
    updatedAt: ClearDateTime!
}

type ClearMailingListMemberMaxAggregate {
    createdAt: ClearDateTime
    email: String
    id: String
    lastEmailed: ClearDateTime
    updatedAt: ClearDateTime
}

type ClearMailingListMemberMinAggregate {
    createdAt: ClearDateTime
    email: String
    id: String
    lastEmailed: ClearDateTime
    updatedAt: ClearDateTime
}

type ClearMutation {
    createEmailTemplate(data: ClearEmailTemplateCreateInput!): ClearEmailTemplate!
    createEvent(data: ClearEventCreateInput!): ClearEvent!
    createEventGroup(data: ClearEventGroupCreateInput!): ClearEventGroup!
    createEventRestriction(data: ClearEventRestrictionCreateInput!): ClearEventRestriction!
    createMailingListMember(data: ClearMailingListMemberCreateInput!): ClearMailingListMember!
    createManyEmailTemplate(data: [ClearEmailTemplateCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyEvent(data: [ClearEventCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyEventGroup(data: [ClearEventGroupCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyEventRestriction(data: [ClearEventRestrictionCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyMailingListMember(data: [ClearMailingListMemberCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyPayment(data: [ClearPaymentCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyPerson(data: [ClearPersonCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyPromoCode(data: [ClearPromoCodeCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyScheduleItem(data: [ClearScheduleItemCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManySponsor(data: [ClearSponsorCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyTicket(data: [ClearTicketCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyVenue(data: [ClearVenueCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createPayment(data: ClearPaymentCreateInput!): ClearPayment!
    createPerson(data: ClearPersonCreateInput!): ClearPerson!
    createPromoCode(data: ClearPromoCodeCreateInput!): ClearPromoCode!
    createScheduleItem(data: ClearScheduleItemCreateInput!): ClearScheduleItem!
    createSponsor(data: ClearSponsorCreateInput!): ClearSponsor!
    createTicket(data: ClearTicketCreateInput!): ClearTicket!
    createVenue(data: ClearVenueCreateInput!): ClearVenue!
    deleteEmailTemplate(where: ClearEmailTemplateWhereUniqueInput!): ClearEmailTemplate
    deleteEvent(where: ClearEventWhereUniqueInput!): ClearEvent
    deleteEventGroup(where: ClearEventGroupWhereUniqueInput!): ClearEventGroup
    deleteEventRestriction(where: ClearEventRestrictionWhereUniqueInput!): ClearEventRestriction
    deleteMailingListMember(where: ClearMailingListMemberWhereUniqueInput!): ClearMailingListMember
    deleteManyEmailTemplate(where: ClearEmailTemplateWhereInput): ClearAffectedRowsOutput!
    deleteManyEvent(where: ClearEventWhereInput): ClearAffectedRowsOutput!
    deleteManyEventGroup(where: ClearEventGroupWhereInput): ClearAffectedRowsOutput!
    deleteManyEventRestriction(where: ClearEventRestrictionWhereInput): ClearAffectedRowsOutput!
    deleteManyMailingListMember(where: ClearMailingListMemberWhereInput): ClearAffectedRowsOutput!
    deleteManyPayment(where: ClearPaymentWhereInput): ClearAffectedRowsOutput!
    deleteManyPerson(where: ClearPersonWhereInput): ClearAffectedRowsOutput!
    deleteManyPromoCode(where: ClearPromoCodeWhereInput): ClearAffectedRowsOutput!
    deleteManyScheduleItem(where: ClearScheduleItemWhereInput): ClearAffectedRowsOutput!
    deleteManySponsor(where: ClearSponsorWhereInput): ClearAffectedRowsOutput!
    deleteManyTicket(where: ClearTicketWhereInput): ClearAffectedRowsOutput!
    deleteManyVenue(where: ClearVenueWhereInput): ClearAffectedRowsOutput!
    deletePayment(where: ClearPaymentWhereUniqueInput!): ClearPayment
    deletePerson(where: ClearPersonWhereUniqueInput!): ClearPerson
    deletePromoCode(where: ClearPromoCodeWhereUniqueInput!): ClearPromoCode
    deleteScheduleItem(where: ClearScheduleItemWhereUniqueInput!): ClearScheduleItem
    deleteSponsor(where: ClearSponsorWhereUniqueInput!): ClearSponsor
    deleteTicket(where: ClearTicketWhereUniqueInput!): ClearTicket
    deleteVenue(where: ClearVenueWhereUniqueInput!): ClearVenue
    finalizePayment(paymentIntentId: String!): [String!]!
    registerForEvent(eventWhere: ClearEventWhereUniqueInput!, guardianData: ClearPersonCreateInput, promoCode: String, ticketData: ClearTicketCreateWithoutEventInput, ticketsData: [ClearTicketCreateWithoutEventInput!]): String
    setEmailTemplateMetadata(key: String!, value: String!, where: ClearEmailTemplateWhereUniqueInput!): ClearEmailTemplate
    setEventGroupMetadata(key: String!, value: String!, where: ClearEventGroupWhereUniqueInput!): ClearEventGroup
    setEventMetadata(key: String!, value: String!, where: ClearEventWhereUniqueInput!): ClearEvent
    setEventRestrictionMetadata(key: String!, value: String!, where: ClearEventRestrictionWhereUniqueInput!): ClearEventRestriction
    setMailingListMemberMetadata(key: String!, value: String!, where: ClearMailingListMemberWhereUniqueInput!): ClearMailingListMember
    setPaymentMetadata(key: String!, value: String!, where: ClearPaymentWhereUniqueInput!): ClearPayment
    setPersonMetadata(key: String!, value: String!, where: ClearPersonWhereUniqueInput!): ClearPerson
    setPromoCodeMetadata(key: String!, value: String!, where: ClearPromoCodeWhereUniqueInput!): ClearPromoCode
    setScheduleItemMetadata(key: String!, value: String!, where: ClearScheduleItemWhereUniqueInput!): ClearScheduleItem
    setSponsorMetadata(key: String!, value: String!, where: ClearSponsorWhereUniqueInput!): ClearSponsor
    setTicketMetadata(key: String!, value: String!, where: ClearTicketWhereUniqueInput!): ClearTicket
    setVenueMetadata(key: String!, value: String!, where: ClearVenueWhereUniqueInput!): ClearVenue
    subscribeToMailingList(email: String!, where: ClearEventWhereUniqueInput!): ClearMailingListMember
    updateEmailTemplate(data: ClearEmailTemplateUpdateInput!, where: ClearEmailTemplateWhereUniqueInput!): ClearEmailTemplate
    updateEvent(data: ClearEventUpdateInput!, where: ClearEventWhereUniqueInput!): ClearEvent
    updateEventGroup(data: ClearEventGroupUpdateInput!, where: ClearEventGroupWhereUniqueInput!): ClearEventGroup
    updateEventRestriction(data: ClearEventRestrictionUpdateInput!, where: ClearEventRestrictionWhereUniqueInput!): ClearEventRestriction
    updateMailingListMember(data: ClearMailingListMemberUpdateInput!, where: ClearMailingListMemberWhereUniqueInput!): ClearMailingListMember
    updateManyEmailTemplate(data: ClearEmailTemplateUpdateManyMutationInput!, where: ClearEmailTemplateWhereInput): ClearAffectedRowsOutput!
    updateManyEvent(data: ClearEventUpdateManyMutationInput!, where: ClearEventWhereInput): ClearAffectedRowsOutput!
    updateManyEventGroup(data: ClearEventGroupUpdateManyMutationInput!, where: ClearEventGroupWhereInput): ClearAffectedRowsOutput!
    updateManyEventRestriction(data: ClearEventRestrictionUpdateManyMutationInput!, where: ClearEventRestrictionWhereInput): ClearAffectedRowsOutput!
    updateManyMailingListMember(data: ClearMailingListMemberUpdateManyMutationInput!, where: ClearMailingListMemberWhereInput): ClearAffectedRowsOutput!
    updateManyPayment(data: ClearPaymentUpdateManyMutationInput!, where: ClearPaymentWhereInput): ClearAffectedRowsOutput!
    updateManyPerson(data: ClearPersonUpdateManyMutationInput!, where: ClearPersonWhereInput): ClearAffectedRowsOutput!
    updateManyPromoCode(data: ClearPromoCodeUpdateManyMutationInput!, where: ClearPromoCodeWhereInput): ClearAffectedRowsOutput!
    updateManyScheduleItem(data: ClearScheduleItemUpdateManyMutationInput!, where: ClearScheduleItemWhereInput): ClearAffectedRowsOutput!
    updateManySponsor(data: ClearSponsorUpdateManyMutationInput!, where: ClearSponsorWhereInput): ClearAffectedRowsOutput!
    updateManyTicket(data: ClearTicketUpdateManyMutationInput!, where: ClearTicketWhereInput): ClearAffectedRowsOutput!
    updateManyVenue(data: ClearVenueUpdateManyMutationInput!, where: ClearVenueWhereInput): ClearAffectedRowsOutput!
    updatePayment(data: ClearPaymentUpdateInput!, where: ClearPaymentWhereUniqueInput!): ClearPayment
    updatePerson(data: ClearPersonUpdateInput!, where: ClearPersonWhereUniqueInput!): ClearPerson
    updatePromoCode(data: ClearPromoCodeUpdateInput!, where: ClearPromoCodeWhereUniqueInput!): ClearPromoCode
    updateScheduleItem(data: ClearScheduleItemUpdateInput!, where: ClearScheduleItemWhereUniqueInput!): ClearScheduleItem
    updateSponsor(data: ClearSponsorUpdateInput!, where: ClearSponsorWhereUniqueInput!): ClearSponsor
    updateTicket(data: ClearTicketUpdateInput!, where: ClearTicketWhereUniqueInput!): ClearTicket
    updateVenue(data: ClearVenueUpdateInput!, where: ClearVenueWhereUniqueInput!): ClearVenue
    uploadDarkSponsorLogo(upload: Upload!, where: ClearSponsorWhereUniqueInput!): ClearSponsor
    uploadEventRestrictionIcon(upload: Upload!, where: ClearEventRestrictionWhereUniqueInput!): ClearEventRestriction
    uploadSponsorLogo(upload: Upload!, where: ClearSponsorWhereUniqueInput!): ClearSponsor
    upsertEmailTemplate(create: ClearEmailTemplateCreateInput!, update: ClearEmailTemplateUpdateInput!, where: ClearEmailTemplateWhereUniqueInput!): ClearEmailTemplate!
    upsertEvent(create: ClearEventCreateInput!, update: ClearEventUpdateInput!, where: ClearEventWhereUniqueInput!): ClearEvent!
    upsertEventGroup(create: ClearEventGroupCreateInput!, update: ClearEventGroupUpdateInput!, where: ClearEventGroupWhereUniqueInput!): ClearEventGroup!
    upsertEventRestriction(create: ClearEventRestrictionCreateInput!, update: ClearEventRestrictionUpdateInput!, where: ClearEventRestrictionWhereUniqueInput!): ClearEventRestriction!
    upsertMailingListMember(create: ClearMailingListMemberCreateInput!, update: ClearMailingListMemberUpdateInput!, where: ClearMailingListMemberWhereUniqueInput!): ClearMailingListMember!
    upsertPayment(create: ClearPaymentCreateInput!, update: ClearPaymentUpdateInput!, where: ClearPaymentWhereUniqueInput!): ClearPayment!
    upsertPerson(create: ClearPersonCreateInput!, update: ClearPersonUpdateInput!, where: ClearPersonWhereUniqueInput!): ClearPerson!
    upsertPromoCode(create: ClearPromoCodeCreateInput!, update: ClearPromoCodeUpdateInput!, where: ClearPromoCodeWhereUniqueInput!): ClearPromoCode!
    upsertScheduleItem(create: ClearScheduleItemCreateInput!, update: ClearScheduleItemUpdateInput!, where: ClearScheduleItemWhereUniqueInput!): ClearScheduleItem!
    upsertSponsor(create: ClearSponsorCreateInput!, update: ClearSponsorUpdateInput!, where: ClearSponsorWhereUniqueInput!): ClearSponsor!
    upsertTicket(create: ClearTicketCreateInput!, update: ClearTicketUpdateInput!, where: ClearTicketWhereUniqueInput!): ClearTicket!
    upsertVenue(create: ClearVenueCreateInput!, update: ClearVenueUpdateInput!, where: ClearVenueWhereUniqueInput!): ClearVenue!
    withdrawFailedPayment(paymentIntentId: String!): Boolean!
}

type ClearPayment {
    _count: ClearPaymentCount
    complete: Boolean!
    createdAt: ClearDateTime!
    getMetadata(key: String!): String
    id: String!
    stripePaymentIntentId: String!
    tickets(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicket!]!
    updatedAt: ClearDateTime!
}

type ClearPaymentCount {
    tickets: Int!
}

type ClearPaymentCountAggregate {
    _all: Int!
    complete: Int!
    createdAt: Int!
    id: Int!
    metadata: Int!
    stripePaymentIntentId: Int!
    updatedAt: Int!
}

type ClearPaymentGroupBy {
    _count: ClearPaymentCountAggregate
    _max: ClearPaymentMaxAggregate
    _min: ClearPaymentMinAggregate
    complete: Boolean!
    createdAt: ClearDateTime!
    id: String!
    metadata: ClearJSON
    stripePaymentIntentId: String!
    updatedAt: ClearDateTime!
}

type ClearPaymentMaxAggregate {
    complete: Boolean
    createdAt: ClearDateTime
    id: String
    stripePaymentIntentId: String
    updatedAt: ClearDateTime
}

type ClearPaymentMinAggregate {
    complete: Boolean
    createdAt: ClearDateTime
    id: String
    stripePaymentIntentId: String
    updatedAt: ClearDateTime
}

type ClearPerson {
    Ticket(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicket!]!
    _count: ClearPersonCount
    age: Int
    createdAt: ClearDateTime!
    email: String
    firstName: String!
    getMetadata(key: String!): String
    id: String!
    lastName: String!
    phone: String
    pronouns: String
    updatedAt: ClearDateTime!
    username: String
}

type ClearPersonAvgAggregate {
    age: Float
}

type ClearPersonCount {
    Ticket: Int!
}

type ClearPersonCountAggregate {
    _all: Int!
    age: Int!
    createdAt: Int!
    email: Int!
    firstName: Int!
    id: Int!
    lastName: Int!
    metadata: Int!
    phone: Int!
    pronouns: Int!
    updatedAt: Int!
    username: Int!
}

type ClearPersonGroupBy {
    _avg: ClearPersonAvgAggregate
    _count: ClearPersonCountAggregate
    _max: ClearPersonMaxAggregate
    _min: ClearPersonMinAggregate
    _sum: ClearPersonSumAggregate
    age: Int
    createdAt: ClearDateTime!
    email: String
    firstName: String!
    id: String!
    lastName: String!
    metadata: ClearJSON
    phone: String
    pronouns: String
    updatedAt: ClearDateTime!
    username: String
}

type ClearPersonMaxAggregate {
    age: Int
    createdAt: ClearDateTime
    email: String
    firstName: String
    id: String
    lastName: String
    phone: String
    pronouns: String
    updatedAt: ClearDateTime
    username: String
}

type ClearPersonMinAggregate {
    age: Int
    createdAt: ClearDateTime
    email: String
    firstName: String
    id: String
    lastName: String
    phone: String
    pronouns: String
    updatedAt: ClearDateTime
    username: String
}

type ClearPersonSumAggregate {
    age: Int
}

type ClearPromoCode {
    _count: ClearPromoCodeCount
    amount: Float!
    code: String!
    createdAt: ClearDateTime!
    event: ClearEvent
    eventGroup: ClearEventGroup
    eventGroupId: String
    eventId: String
    getMetadata(key: String!): String
    id: String!
    tickets(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicket!]!
    type: ClearDiscountType!
    updatedAt: ClearDateTime!
    uses: Int
    usesRemaining: Float
}

type ClearPromoCodeAvgAggregate {
    amount: Float
    uses: Float
}

type ClearPromoCodeCount {
    tickets: Int!
}

type ClearPromoCodeCountAggregate {
    _all: Int!
    amount: Int!
    code: Int!
    createdAt: Int!
    eventGroupId: Int!
    eventId: Int!
    id: Int!
    metadata: Int!
    type: Int!
    updatedAt: Int!
    uses: Int!
}

type ClearPromoCodeGroupBy {
    _avg: ClearPromoCodeAvgAggregate
    _count: ClearPromoCodeCountAggregate
    _max: ClearPromoCodeMaxAggregate
    _min: ClearPromoCodeMinAggregate
    _sum: ClearPromoCodeSumAggregate
    amount: Float!
    code: String!
    createdAt: ClearDateTime!
    eventGroupId: String
    eventId: String
    id: String!
    metadata: ClearJSON
    type: ClearDiscountType!
    updatedAt: ClearDateTime!
    uses: Int
}

type ClearPromoCodeMaxAggregate {
    amount: Float
    code: String
    createdAt: ClearDateTime
    eventGroupId: String
    eventId: String
    id: String
    type: ClearDiscountType
    updatedAt: ClearDateTime
    uses: Int
}

type ClearPromoCodeMinAggregate {
    amount: Float
    code: String
    createdAt: ClearDateTime
    eventGroupId: String
    eventId: String
    id: String
    type: ClearDiscountType
    updatedAt: ClearDateTime
    uses: Int
}

type ClearPromoCodeSumAggregate {
    amount: Float
    uses: Int
}

type ClearQuery {
    aggregateEmailTemplate(cursor: ClearEmailTemplateWhereUniqueInput, orderBy: [ClearEmailTemplateOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEmailTemplateWhereInput): ClearAggregateEmailTemplate!
    aggregateEvent(cursor: ClearEventWhereUniqueInput, orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): ClearAggregateEvent!
    aggregateEventGroup(cursor: ClearEventGroupWhereUniqueInput, orderBy: [ClearEventGroupOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventGroupWhereInput): ClearAggregateEventGroup!
    aggregateEventRestriction(cursor: ClearEventRestrictionWhereUniqueInput, orderBy: [ClearEventRestrictionOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventRestrictionWhereInput): ClearAggregateEventRestriction!
    aggregateMailingListMember(cursor: ClearMailingListMemberWhereUniqueInput, orderBy: [ClearMailingListMemberOrderByWithRelationInput!], skip: Int, take: Int, where: ClearMailingListMemberWhereInput): ClearAggregateMailingListMember!
    aggregatePayment(cursor: ClearPaymentWhereUniqueInput, orderBy: [ClearPaymentOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPaymentWhereInput): ClearAggregatePayment!
    aggregatePerson(cursor: ClearPersonWhereUniqueInput, orderBy: [ClearPersonOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPersonWhereInput): ClearAggregatePerson!
    aggregatePromoCode(cursor: ClearPromoCodeWhereUniqueInput, orderBy: [ClearPromoCodeOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPromoCodeWhereInput): ClearAggregatePromoCode!
    aggregateScheduleItem(cursor: ClearScheduleItemWhereUniqueInput, orderBy: [ClearScheduleItemOrderByWithRelationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): ClearAggregateScheduleItem!
    aggregateSponsor(cursor: ClearSponsorWhereUniqueInput, orderBy: [ClearSponsorOrderByWithRelationInput!], skip: Int, take: Int, where: ClearSponsorWhereInput): ClearAggregateSponsor!
    aggregateTicket(cursor: ClearTicketWhereUniqueInput, orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): ClearAggregateTicket!
    aggregateVenue(cursor: ClearVenueWhereUniqueInput, orderBy: [ClearVenueOrderByWithRelationInput!], skip: Int, take: Int, where: ClearVenueWhereInput): ClearAggregateVenue!
    emailTemplate(where: ClearEmailTemplateWhereUniqueInput!): ClearEmailTemplate
    emailTemplates(cursor: ClearEmailTemplateWhereUniqueInput, distinct: [ClearEmailTemplateScalarFieldEnum!], orderBy: [ClearEmailTemplateOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEmailTemplateWhereInput): [ClearEmailTemplate!]!
    event(where: ClearEventWhereUniqueInput!): ClearEvent
    eventGroup(where: ClearEventGroupWhereUniqueInput!): ClearEventGroup
    eventGroups(cursor: ClearEventGroupWhereUniqueInput, distinct: [ClearEventGroupScalarFieldEnum!], orderBy: [ClearEventGroupOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventGroupWhereInput): [ClearEventGroup!]!
    eventRestriction(where: ClearEventRestrictionWhereUniqueInput!): ClearEventRestriction
    eventRestrictions(cursor: ClearEventRestrictionWhereUniqueInput, distinct: [ClearEventRestrictionScalarFieldEnum!], orderBy: [ClearEventRestrictionOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventRestrictionWhereInput): [ClearEventRestriction!]!
    events(cursor: ClearEventWhereUniqueInput, distinct: [ClearEventScalarFieldEnum!], editable: Boolean, orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): [ClearEvent!]!
    findFirstEmailTemplate(cursor: ClearEmailTemplateWhereUniqueInput, distinct: [ClearEmailTemplateScalarFieldEnum!], orderBy: [ClearEmailTemplateOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEmailTemplateWhereInput): ClearEmailTemplate
    findFirstEvent(cursor: ClearEventWhereUniqueInput, distinct: [ClearEventScalarFieldEnum!], orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): ClearEvent
    findFirstEventGroup(cursor: ClearEventGroupWhereUniqueInput, distinct: [ClearEventGroupScalarFieldEnum!], orderBy: [ClearEventGroupOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventGroupWhereInput): ClearEventGroup
    findFirstEventRestriction(cursor: ClearEventRestrictionWhereUniqueInput, distinct: [ClearEventRestrictionScalarFieldEnum!], orderBy: [ClearEventRestrictionOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventRestrictionWhereInput): ClearEventRestriction
    findFirstMailingListMember(cursor: ClearMailingListMemberWhereUniqueInput, distinct: [ClearMailingListMemberScalarFieldEnum!], orderBy: [ClearMailingListMemberOrderByWithRelationInput!], skip: Int, take: Int, where: ClearMailingListMemberWhereInput): ClearMailingListMember
    findFirstPayment(cursor: ClearPaymentWhereUniqueInput, distinct: [ClearPaymentScalarFieldEnum!], orderBy: [ClearPaymentOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPaymentWhereInput): ClearPayment
    findFirstPerson(cursor: ClearPersonWhereUniqueInput, distinct: [ClearPersonScalarFieldEnum!], orderBy: [ClearPersonOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPersonWhereInput): ClearPerson
    findFirstPromoCode(cursor: ClearPromoCodeWhereUniqueInput, distinct: [ClearPromoCodeScalarFieldEnum!], orderBy: [ClearPromoCodeOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPromoCodeWhereInput): ClearPromoCode
    findFirstScheduleItem(cursor: ClearScheduleItemWhereUniqueInput, distinct: [ClearScheduleItemScalarFieldEnum!], orderBy: [ClearScheduleItemOrderByWithRelationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): ClearScheduleItem
    findFirstSponsor(cursor: ClearSponsorWhereUniqueInput, distinct: [ClearSponsorScalarFieldEnum!], orderBy: [ClearSponsorOrderByWithRelationInput!], skip: Int, take: Int, where: ClearSponsorWhereInput): ClearSponsor
    findFirstTicket(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): ClearTicket
    findFirstVenue(cursor: ClearVenueWhereUniqueInput, distinct: [ClearVenueScalarFieldEnum!], orderBy: [ClearVenueOrderByWithRelationInput!], skip: Int, take: Int, where: ClearVenueWhereInput): ClearVenue
    groupByEmailTemplate(by: [ClearEmailTemplateScalarFieldEnum!]!, having: ClearEmailTemplateScalarWhereWithAggregatesInput, orderBy: [ClearEmailTemplateOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearEmailTemplateWhereInput): [ClearEmailTemplateGroupBy!]!
    groupByEvent(by: [ClearEventScalarFieldEnum!]!, having: ClearEventScalarWhereWithAggregatesInput, orderBy: [ClearEventOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearEventWhereInput): [ClearEventGroupBy!]!
    groupByEventGroup(by: [ClearEventGroupScalarFieldEnum!]!, having: ClearEventGroupScalarWhereWithAggregatesInput, orderBy: [ClearEventGroupOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearEventGroupWhereInput): [ClearEventGroupGroupBy!]!
    groupByEventRestriction(by: [ClearEventRestrictionScalarFieldEnum!]!, having: ClearEventRestrictionScalarWhereWithAggregatesInput, orderBy: [ClearEventRestrictionOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearEventRestrictionWhereInput): [ClearEventRestrictionGroupBy!]!
    groupByMailingListMember(by: [ClearMailingListMemberScalarFieldEnum!]!, having: ClearMailingListMemberScalarWhereWithAggregatesInput, orderBy: [ClearMailingListMemberOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearMailingListMemberWhereInput): [ClearMailingListMemberGroupBy!]!
    groupByPayment(by: [ClearPaymentScalarFieldEnum!]!, having: ClearPaymentScalarWhereWithAggregatesInput, orderBy: [ClearPaymentOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearPaymentWhereInput): [ClearPaymentGroupBy!]!
    groupByPerson(by: [ClearPersonScalarFieldEnum!]!, having: ClearPersonScalarWhereWithAggregatesInput, orderBy: [ClearPersonOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearPersonWhereInput): [ClearPersonGroupBy!]!
    groupByPromoCode(by: [ClearPromoCodeScalarFieldEnum!]!, having: ClearPromoCodeScalarWhereWithAggregatesInput, orderBy: [ClearPromoCodeOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearPromoCodeWhereInput): [ClearPromoCodeGroupBy!]!
    groupByScheduleItem(by: [ClearScheduleItemScalarFieldEnum!]!, having: ClearScheduleItemScalarWhereWithAggregatesInput, orderBy: [ClearScheduleItemOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): [ClearScheduleItemGroupBy!]!
    groupBySponsor(by: [ClearSponsorScalarFieldEnum!]!, having: ClearSponsorScalarWhereWithAggregatesInput, orderBy: [ClearSponsorOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearSponsorWhereInput): [ClearSponsorGroupBy!]!
    groupByTicket(by: [ClearTicketScalarFieldEnum!]!, having: ClearTicketScalarWhereWithAggregatesInput, orderBy: [ClearTicketOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicketGroupBy!]!
    groupByVenue(by: [ClearVenueScalarFieldEnum!]!, having: ClearVenueScalarWhereWithAggregatesInput, orderBy: [ClearVenueOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearVenueWhereInput): [ClearVenueGroupBy!]!
    mailingListMember(where: ClearMailingListMemberWhereUniqueInput!): ClearMailingListMember
    mailingListMembers(cursor: ClearMailingListMemberWhereUniqueInput, distinct: [ClearMailingListMemberScalarFieldEnum!], orderBy: [ClearMailingListMemberOrderByWithRelationInput!], skip: Int, take: Int, where: ClearMailingListMemberWhereInput): [ClearMailingListMember!]!
    payment(where: ClearPaymentWhereUniqueInput!): ClearPayment
    payments(cursor: ClearPaymentWhereUniqueInput, distinct: [ClearPaymentScalarFieldEnum!], orderBy: [ClearPaymentOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPaymentWhereInput): [ClearPayment!]!
    people(cursor: ClearPersonWhereUniqueInput, distinct: [ClearPersonScalarFieldEnum!], orderBy: [ClearPersonOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPersonWhereInput): [ClearPerson!]!
    person(where: ClearPersonWhereUniqueInput!): ClearPerson
    promoCode(where: ClearPromoCodeWhereUniqueInput!): ClearPromoCode
    promoCodes(cursor: ClearPromoCodeWhereUniqueInput, distinct: [ClearPromoCodeScalarFieldEnum!], orderBy: [ClearPromoCodeOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPromoCodeWhereInput): [ClearPromoCode!]!
    scheduleItem(where: ClearScheduleItemWhereUniqueInput!): ClearScheduleItem
    scheduleItems(cursor: ClearScheduleItemWhereUniqueInput, distinct: [ClearScheduleItemScalarFieldEnum!], orderBy: [ClearScheduleItemOrderByWithRelationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): [ClearScheduleItem!]!
    sponsor(where: ClearSponsorWhereUniqueInput!): ClearSponsor
    sponsors(cursor: ClearSponsorWhereUniqueInput, distinct: [ClearSponsorScalarFieldEnum!], orderBy: [ClearSponsorOrderByWithRelationInput!], skip: Int, take: Int, where: ClearSponsorWhereInput): [ClearSponsor!]!
    ticket(where: ClearTicketWhereUniqueInput!): ClearTicket
    tickets(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicket!]!
    venue(where: ClearVenueWhereUniqueInput!): ClearVenue
    venues(cursor: ClearVenueWhereUniqueInput, distinct: [ClearVenueScalarFieldEnum!], orderBy: [ClearVenueOrderByWithRelationInput!], skip: Int, take: Int, where: ClearVenueWhereInput): [ClearVenue!]!
}

type ClearScheduleItem {
    createdAt: ClearDateTime!
    description: String
    displayTime: String!
    displayTimeWithDate: String!
    end: ClearDateTime
    event: ClearEvent
    eventGroup: ClearEventGroup
    eventGroupId: String
    eventId: String
    finalized: Boolean!
    getMetadata(key: String!): String
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String!
    internal: Boolean!
    link: String
    name: String!
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime!
    type: String!
    updatedAt: ClearDateTime!
}

type ClearScheduleItemCountAggregate {
    _all: Int!
    createdAt: Int!
    description: Int!
    end: Int!
    eventGroupId: Int!
    eventId: Int!
    finalized: Int!
    hostEmail: Int!
    hostName: Int!
    hostPronoun: Int!
    id: Int!
    internal: Int!
    link: Int!
    metadata: Int!
    name: Int!
    organizerEmail: Int!
    organizerName: Int!
    organizerPhone: Int!
    start: Int!
    type: Int!
    updatedAt: Int!
}

type ClearScheduleItemGroupBy {
    _count: ClearScheduleItemCountAggregate
    _max: ClearScheduleItemMaxAggregate
    _min: ClearScheduleItemMinAggregate
    createdAt: ClearDateTime!
    description: String
    end: ClearDateTime
    eventGroupId: String
    eventId: String
    finalized: Boolean!
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String!
    internal: Boolean!
    link: String
    metadata: ClearJSON
    name: String!
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime!
    type: String!
    updatedAt: ClearDateTime!
}

type ClearScheduleItemMaxAggregate {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventGroupId: String
    eventId: String
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime
}

type ClearScheduleItemMinAggregate {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventGroupId: String
    eventId: String
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime
}

type ClearSponsor {
    amount: Int!
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime!
    darkLogoImageUri: String
    description: String
    event: ClearEvent
    eventId: String
    getMetadata(key: String!): String
    id: String!
    link: String
    logoImageUri: String
    name: String!
    perks: String
    updatedAt: ClearDateTime!
}

type ClearSponsorAvgAggregate {
    amount: Float
}

type ClearSponsorCountAggregate {
    _all: Int!
    amount: Int!
    contactEmail: Int!
    contactName: Int!
    contactPhone: Int!
    createdAt: Int!
    darkLogoImageUri: Int!
    description: Int!
    eventId: Int!
    id: Int!
    link: Int!
    logoImageUri: Int!
    metadata: Int!
    name: Int!
    perks: Int!
    updatedAt: Int!
}

type ClearSponsorGroupBy {
    _avg: ClearSponsorAvgAggregate
    _count: ClearSponsorCountAggregate
    _max: ClearSponsorMaxAggregate
    _min: ClearSponsorMinAggregate
    _sum: ClearSponsorSumAggregate
    amount: Int!
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime!
    darkLogoImageUri: String
    description: String
    eventId: String
    id: String!
    link: String
    logoImageUri: String
    metadata: ClearJSON
    name: String!
    perks: String
    updatedAt: ClearDateTime!
}

type ClearSponsorMaxAggregate {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    darkLogoImageUri: String
    description: String
    eventId: String
    id: String
    link: String
    logoImageUri: String
    name: String
    perks: String
    updatedAt: ClearDateTime
}

type ClearSponsorMinAggregate {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    darkLogoImageUri: String
    description: String
    eventId: String
    id: String
    link: String
    logoImageUri: String
    name: String
    perks: String
    updatedAt: ClearDateTime
}

type ClearSponsorSumAggregate {
    amount: Int
}

type ClearTicket {
    _count: ClearTicketCount
    age: Int
    couponCode: String
    createdAt: ClearDateTime!
    email: String
    event: ClearEvent!
    eventId: String!
    firstName: String!
    getMetadata(key: String!): String
    guardian: ClearPerson
    id: String!
    lastName: String!
    needsGuardian: Boolean!
    payment: ClearPayment
    paymentId: String
    personId: String
    phone: String
    promoCode: ClearPromoCode
    promoCodeId: String
    sentEmails(cursor: ClearEmailTemplateWhereUniqueInput, distinct: [ClearEmailTemplateScalarFieldEnum!], orderBy: [ClearEmailTemplateOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEmailTemplateWhereInput): [ClearEmailTemplate!]!
    type: ClearTicketType!
    updatedAt: ClearDateTime!
    waiverSigned: Boolean!
}

type ClearTicketAvgAggregate {
    age: Float
}

type ClearTicketCount {
    sentEmails: Int!
}

type ClearTicketCountAggregate {
    _all: Int!
    age: Int!
    couponCode: Int!
    createdAt: Int!
    email: Int!
    eventId: Int!
    firstName: Int!
    id: Int!
    lastName: Int!
    metadata: Int!
    paymentId: Int!
    personId: Int!
    phone: Int!
    promoCodeId: Int!
    type: Int!
    updatedAt: Int!
    waiverSigned: Int!
}

type ClearTicketGroupBy {
    _avg: ClearTicketAvgAggregate
    _count: ClearTicketCountAggregate
    _max: ClearTicketMaxAggregate
    _min: ClearTicketMinAggregate
    _sum: ClearTicketSumAggregate
    age: Int
    couponCode: String
    createdAt: ClearDateTime!
    email: String
    eventId: String!
    firstName: String!
    id: String!
    lastName: String!
    metadata: ClearJSON
    paymentId: String
    personId: String
    phone: String
    promoCodeId: String
    type: ClearTicketType!
    updatedAt: ClearDateTime!
    waiverSigned: Boolean!
}

type ClearTicketMaxAggregate {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    eventId: String
    firstName: String
    id: String
    lastName: String
    paymentId: String
    personId: String
    phone: String
    promoCodeId: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

type ClearTicketMinAggregate {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    eventId: String
    firstName: String
    id: String
    lastName: String
    paymentId: String
    personId: String
    phone: String
    promoCodeId: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

type ClearTicketSumAggregate {
    age: Int
}

type ClearVenue {
    _count: ClearVenueCount
    address: String
    addressLine1: String
    capacity: Int
    city: String
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime!
    events(cursor: ClearEventWhereUniqueInput, distinct: [ClearEventScalarFieldEnum!], orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): [ClearEvent!]!
    getMetadata(key: String!): String
    id: String!
    mapLink: String
    name: String!
    state: String
    stateAbbreviation: String
    updatedAt: ClearDateTime!
    zipCode: String
}

type ClearVenueAvgAggregate {
    capacity: Float
}

type ClearVenueCount {
    events: Int!
}

type ClearVenueCountAggregate {
    _all: Int!
    address: Int!
    capacity: Int!
    contactEmail: Int!
    contactName: Int!
    contactPhone: Int!
    createdAt: Int!
    id: Int!
    mapLink: Int!
    metadata: Int!
    name: Int!
    updatedAt: Int!
}

type ClearVenueGroupBy {
    _avg: ClearVenueAvgAggregate
    _count: ClearVenueCountAggregate
    _max: ClearVenueMaxAggregate
    _min: ClearVenueMinAggregate
    _sum: ClearVenueSumAggregate
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime!
    id: String!
    mapLink: String
    metadata: ClearJSON
    name: String!
    updatedAt: ClearDateTime!
}

type ClearVenueMaxAggregate {
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    id: String
    mapLink: String
    name: String
    updatedAt: ClearDateTime
}

type ClearVenueMinAggregate {
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    id: String
    mapLink: String
    name: String
    updatedAt: ClearDateTime
}

type ClearVenueSumAggregate {
    capacity: Int
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/announcement)"
type CmsAnnouncement implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    displayAt(locale: String): CmsDateTime
    endAt(locale: String): CmsDateTime
    link(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsAnnouncementLinkingCollections
    oneline(locale: String): String
    programs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAnnouncementProgramCollection
    sys: CmsSys!
    title(locale: String): String
    type(locale: String): String
    visibility(locale: String): String
}

type CmsAnnouncementCollection {
    items: [CmsAnnouncement]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsAnnouncementLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsAnnouncementProgramCollection {
    items: [CmsProgram]!
    limit: Int!
    skip: Int!
    total: Int!
}

"Represents a binary file in a space. An asset can be any file type."
type CmsAsset {
    contentType(locale: String): String
    contentfulBaseUrl(locale: String, transform: CmsImageTransformOptions): String
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): String
    fileName(locale: String): String
    height(locale: String): Int
    linkedFrom(allowedLocales: [String]): CmsAssetLinkingCollections
    size(locale: String): Int
    sys: CmsSys!
    title(locale: String): String
    url(transform: CmsImageTransformOptions): String
    width(locale: String): Int
}

type CmsAssetCollection {
    items: [CmsAsset]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsAssetLinkingCollections {
    awards(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAwardCollection
    badges(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsBadgeCollection
    communityPartners(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsCommunityPartnerCollection
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    events(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEventCollection
    forms(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsFormCollection
    globalSponsors(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsGlobalSponsorCollection
    hiringCompanies(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsHiringCompanyCollection
    legalDocuments(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsLegalDocumentCollection
    newsCoverages(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsNewsCoverageCollection
    pressPhotos(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsPressPhotoCollection
    programs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsProgramCollection
    regions(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsRegionCollection
    socialMedias(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsSocialMediaCollection
    stockMusics(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsStockMusicCollection
    testimonials(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsTestimonialCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/award)"
type CmsAward implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): String
    icon(locale: String, preview: Boolean): CmsAsset
    id(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsAwardLinkingCollections
    name(locale: String): String
    programs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAwardProgramsCollection
    ranking(locale: String): Int
    sys: CmsSys!
}

type CmsAwardCollection {
    items: [CmsAward]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsAwardLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsAwardProgramsCollection {
    items: [CmsProgram]!
    limit: Int!
    skip: Int!
    total: Int!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/badge)"
type CmsBadge implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): String
    earnCriteria(locale: String): String
    earnMessage(locale: String): String
    emoji(locale: String): String
    grantPermissionOverrideIDs(locale: String): CmsJSON
    id(locale: String): String
    image(locale: String, preview: Boolean): CmsAsset
    linkedFrom(allowedLocales: [String]): CmsBadgeLinkingCollections
    name(locale: String): String
    sys: CmsSys!
}

type CmsBadgeCollection {
    items: [CmsBadge]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsBadgeLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/bumper)"
type CmsBumper implements CmsEntry {
    ambient(locale: String): Boolean
    contentfulMetadata: CmsContentfulMetadata!
    linkedFrom(allowedLocales: [String]): CmsBumperLinkingCollections
    purpose(locale: String): [String]
    sys: CmsSys!
    title(locale: String): String
    video(locale: String): CmsJSON
}

type CmsBumperCollection {
    items: [CmsBumper]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsBumperLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/communityPartner)"
type CmsCommunityPartner implements CmsEntry {
    audience(locale: String): [String]
    blurb(locale: String): String
    contentfulMetadata: CmsContentfulMetadata!
    cost(locale: String): Int
    details(locale: String): String
    displayUrl(locale: String): String
    eligibility(locale: String): String
    expires(locale: String): CmsDateTime
    linkedFrom(allowedLocales: [String]): CmsCommunityPartnerLinkingCollections
    logo(locale: String, preview: Boolean): CmsAsset
    name(locale: String): String
    regions(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsCommunityPartnerRegionCollection
    sys: CmsSys!
    url(locale: String): String
}

type CmsCommunityPartnerCollection {
    items: [CmsCommunityPartner]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsCommunityPartnerLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsCommunityPartnerRegionCollection {
    items: [CmsRegion]!
    limit: Int!
    skip: Int!
    total: Int!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/string)"
type CmsContentTypeString implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    json(locale: String): CmsJSON
    key(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsContentTypeStringLinkingCollections
    richValue(locale: String): CmsContentTypeStringRichValue
    subvalues(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsContentTypeStringSubvalueCollection
    sys: CmsSys!
    value(locale: String): String
}

type CmsContentTypeStringCollection {
    items: [CmsContentTypeString]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsContentTypeStringLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    strings(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsContentTypeStringCollection
}

type CmsContentTypeStringRichValue {
    json: CmsJSON!
    links: CmsContentTypeStringRichValueLinks!
}

type CmsContentTypeStringRichValueAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsContentTypeStringRichValueEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsContentTypeStringRichValueLinks {
    assets: CmsContentTypeStringRichValueAssets!
    entries: CmsContentTypeStringRichValueEntries!
}

type CmsContentTypeStringSubvalueCollection {
    items: [CmsContentTypeString]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsContentfulMetadata {
    tags: [CmsContentfulTag]!
}

"""

Represents a tag entity for finding and organizing content easily.
Find out more here: https://www.contentful.com/developers/docs/references/content-delivery-api/#/reference/content-tags
"""
type CmsContentfulTag {
    id: String
    name: String
}

type CmsEntryCollection {
    items: [CmsEntry]!
    limit: Int!
    skip: Int!
    total: Int!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/event)"
type CmsEvent implements CmsEntry {
    awardsAt(locale: String): CmsDateTime
    calendarReleaseDate(locale: String): CmsDateTime
    contentfulMetadata: CmsContentfulMetadata!
    endsAt(locale: String): CmsDateTime
    id(locale: String): String
    kickoffVideo(locale: String, preview: Boolean): CmsAsset
    kickoffVideoCaptions(locale: String, preview: Boolean): CmsAsset
    linkedFrom(allowedLocales: [String]): CmsEventLinkingCollections
    notice(locale: String): CmsEventNotice
    participantRoleId(locale: String): String
    posters(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    program(locale: String, preview: Boolean): CmsProgram
    registrationsCloseAt(locale: String): CmsDateTime
    registrationsOpenAt(locale: String): CmsDateTime
    startsAt(locale: String): CmsDateTime
    statEventCount(locale: String): Int
    statLowInterestContinuedCount(locale: String): Int
    statLowInterestCount(locale: String): Int
    statStudentCount(locale: String): Int
    subEventIds(locale: String): CmsJSON
    sys: CmsSys!
    theme(locale: String): String
    themeBackgrounds(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    themeLogoBackgrounds(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    title(locale: String): String
}

type CmsEventCollection {
    items: [CmsEvent]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsEventLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    pressPhotos(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsPressPhotoCollection
}

type CmsEventNotice {
    json: CmsJSON!
    links: CmsEventNoticeLinks!
}

type CmsEventNoticeAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsEventNoticeEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsEventNoticeLinks {
    assets: CmsEventNoticeAssets!
    entries: CmsEventNoticeEntries!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/faq)"
type CmsFaq implements CmsEntry {
    answer(locale: String): CmsFaqAnswer
    audience(locale: String): [String]
    contentfulMetadata: CmsContentfulMetadata!
    featured(locale: String): Boolean
    linkedFrom(allowedLocales: [String]): CmsFaqLinkingCollections
    program(locale: String, preview: Boolean): CmsProgram
    relatedAnswers(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsFaqRelatedAnswersCollection
    sys: CmsSys!
    tags(locale: String): [String]
    title(locale: String): String
}

type CmsFaqAnswer {
    json: CmsJSON!
    links: CmsFaqAnswerLinks!
}

type CmsFaqAnswerAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsFaqAnswerEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsFaqAnswerLinks {
    assets: CmsFaqAnswerAssets!
    entries: CmsFaqAnswerEntries!
}

type CmsFaqCollection {
    items: [CmsFaq]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsFaqLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    faqs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsFaqCollection
}

type CmsFaqRelatedAnswersCollection {
    items: [CmsFaq]!
    limit: Int!
    skip: Int!
    total: Int!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/form)"
type CmsForm implements CmsEntry {
    cognitoForm(locale: String): Int
    contentfulMetadata: CmsContentfulMetadata!
    details(locale: String): CmsFormDetails
    image(locale: String, preview: Boolean): CmsAsset
    linkedFrom(allowedLocales: [String]): CmsFormLinkingCollections
    prefill(locale: String): CmsJSON
    sidebar(locale: String): CmsFormSidebar
    slug(locale: String): String
    sys: CmsSys!
    title(locale: String): String
}

type CmsFormCollection {
    items: [CmsForm]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsFormDetails {
    json: CmsJSON!
    links: CmsFormDetailsLinks!
}

type CmsFormDetailsAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsFormDetailsEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsFormDetailsLinks {
    assets: CmsFormDetailsAssets!
    entries: CmsFormDetailsEntries!
}

type CmsFormLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsFormSidebar {
    json: CmsJSON!
    links: CmsFormSidebarLinks!
}

type CmsFormSidebarAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsFormSidebarEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsFormSidebarLinks {
    assets: CmsFormSidebarAssets!
    entries: CmsFormSidebarEntries!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/globalSponsor)"
type CmsGlobalSponsor implements CmsEntry {
    audio(locale: String, preview: Boolean): CmsAsset
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): String
    instagramUsername(locale: String): String
    link(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsGlobalSponsorLinkingCollections
    logo(locale: String, preview: Boolean): CmsAsset
    name(locale: String): String
    perks(locale: String): String
    shortDescription(locale: String): String
    sys: CmsSys!
    twitterUsername(locale: String): String
    type(locale: String): String
}

type CmsGlobalSponsorCollection {
    items: [CmsGlobalSponsor]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsGlobalSponsorLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    hiringCompanies(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsHiringCompanyCollection
    programs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsProgramCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/hiringCompany)"
type CmsHiringCompany implements CmsEntry {
    alumniReferralAccounts: [AccountUser]
    alumniReferrals(locale: String): [String]
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): CmsHiringCompanyDescription
    featured(locale: String): Boolean
    linkedFrom(allowedLocales: [String]): CmsHiringCompanyLinkingCollections
    logo(locale: String, preview: Boolean): CmsAsset
    name(locale: String): String
    relatedSponsor(locale: String, preview: Boolean): CmsGlobalSponsor
    sys: CmsSys!
    url(locale: String): String
}

type CmsHiringCompanyCollection {
    items: [CmsHiringCompany]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsHiringCompanyDescription {
    json: CmsJSON!
    links: CmsHiringCompanyDescriptionLinks!
}

type CmsHiringCompanyDescriptionAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsHiringCompanyDescriptionEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsHiringCompanyDescriptionLinks {
    assets: CmsHiringCompanyDescriptionAssets!
    entries: CmsHiringCompanyDescriptionEntries!
}

type CmsHiringCompanyLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    hiringPosts(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsHiringPostCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/hiringPost)"
type CmsHiringPost implements CmsEntry {
    company(locale: String, preview: Boolean): CmsHiringCompany
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): CmsHiringPostDescription
    linkedFrom(allowedLocales: [String]): CmsHiringPostLinkingCollections
    paid(locale: String): Boolean
    regions(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsHiringPostRegionsCollection
    sys: CmsSys!
    title(locale: String): String
    type(locale: String): String
    url(locale: String): String
}

type CmsHiringPostCollection {
    items: [CmsHiringPost]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsHiringPostDescription {
    json: CmsJSON!
    links: CmsHiringPostDescriptionLinks!
}

type CmsHiringPostDescriptionAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsHiringPostDescriptionEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsHiringPostDescriptionLinks {
    assets: CmsHiringPostDescriptionAssets!
    entries: CmsHiringPostDescriptionEntries!
}

type CmsHiringPostLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsHiringPostRegionsCollection {
    items: [CmsRegion]!
    limit: Int!
    skip: Int!
    total: Int!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/legalDocument)"
type CmsLegalDocument implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    date(locale: String): CmsDateTime
    file(locale: String, preview: Boolean): CmsAsset
    id(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsLegalDocumentLinkingCollections
    sys: CmsSys!
    title(locale: String): String
    type(locale: String): String
}

type CmsLegalDocumentCollection {
    items: [CmsLegalDocument]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsLegalDocumentLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsLocation {
    lat: Float
    lon: Float
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/newsCoverage)"
type CmsNewsCoverage implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    date(locale: String): CmsDateTime
    featured(locale: String): Boolean
    linkedFrom(allowedLocales: [String]): CmsNewsCoverageLinkingCollections
    publicationLogo(locale: String, preview: Boolean): CmsAsset
    publicationName(locale: String): String
    sys: CmsSys!
    title(locale: String): String
    url(locale: String): String
}

type CmsNewsCoverageCollection {
    items: [CmsNewsCoverage]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsNewsCoverageLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/pressPhoto)"
type CmsPressPhoto implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    event(locale: String, preview: Boolean): CmsEvent
    linkedFrom(allowedLocales: [String]): CmsPressPhotoLinkingCollections
    photo(locale: String, preview: Boolean): CmsAsset
    region(locale: String, preview: Boolean): CmsRegion
    subProgram(locale: String, preview: Boolean): CmsProgram
    sys: CmsSys!
    tags(locale: String): [String]
}

type CmsPressPhotoCollection {
    items: [CmsPressPhoto]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsPressPhotoLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/program)"
type CmsProgram implements CmsEntry {
    archived(locale: String): Boolean
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): String
    educationDetails(locale: String): CmsProgramEducationDetails
    eligibility(locale: String): CmsProgramEligibility
    linkedFrom(allowedLocales: [String]): CmsProgramLinkingCollections
    logo(locale: String, preview: Boolean): CmsAsset
    logoWhite(locale: String, preview: Boolean): CmsAsset
    name(locale: String): String
    posters(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    presentingSponsors(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsProgramPresentingSponsorsCollection
    shortDescription(locale: String): String
    sponsorPerks(locale: String): CmsJSON
    sys: CmsSys!
    type(locale: String): String
    url(locale: String): String
    virtual(locale: String): Boolean
    volunteerBlurb(locale: String): CmsProgramVolunteerBlurb
    volunteerDetails(locale: String): CmsProgramVolunteerDetails
    volunteerPositions(locale: String): [String]
    volunteerRecruitingResources(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    volunteerUrl(locale: String): String
    webname(locale: String): String
}

type CmsProgramCollection {
    items: [CmsProgram]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsProgramEducationDetails {
    json: CmsJSON!
    links: CmsProgramEducationDetailsLinks!
}

type CmsProgramEducationDetailsAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsProgramEducationDetailsEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsProgramEducationDetailsLinks {
    assets: CmsProgramEducationDetailsAssets!
    entries: CmsProgramEducationDetailsEntries!
}

type CmsProgramEligibility {
    json: CmsJSON!
    links: CmsProgramEligibilityLinks!
}

type CmsProgramEligibilityAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsProgramEligibilityEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsProgramEligibilityLinks {
    assets: CmsProgramEligibilityAssets!
    entries: CmsProgramEligibilityEntries!
}

type CmsProgramLinkingCollections {
    announcements(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAnnouncementCollection
    awards(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAwardCollection
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    events(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEventCollection
    faqs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsFaqCollection
    pressPhotos(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsPressPhotoCollection
    testimonials(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsTestimonialCollection
}

type CmsProgramPresentingSponsorsCollection {
    items: [CmsGlobalSponsor]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsProgramVolunteerBlurb {
    json: CmsJSON!
    links: CmsProgramVolunteerBlurbLinks!
}

type CmsProgramVolunteerBlurbAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsProgramVolunteerBlurbEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsProgramVolunteerBlurbLinks {
    assets: CmsProgramVolunteerBlurbAssets!
    entries: CmsProgramVolunteerBlurbEntries!
}

type CmsProgramVolunteerDetails {
    json: CmsJSON!
    links: CmsProgramVolunteerDetailsLinks!
}

type CmsProgramVolunteerDetailsAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsProgramVolunteerDetailsEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsProgramVolunteerDetailsLinks {
    assets: CmsProgramVolunteerDetailsAssets!
    entries: CmsProgramVolunteerDetailsEntries!
}

type CmsQuery {
    announcement(id: String!, locale: String, preview: Boolean): CmsAnnouncement
    announcements(limit: Int = 100, locale: String, order: [CmsAnnouncementOrder], preview: Boolean, skip: Int = 0, where: CmsAnnouncementFilter): CmsAnnouncementCollection
    asset(id: String!, locale: String, preview: Boolean): CmsAsset
    assets(limit: Int = 100, locale: String, order: [CmsAssetOrder], preview: Boolean, skip: Int = 0, where: CmsAssetFilter): CmsAssetCollection
    award(id: String!, locale: String, preview: Boolean): CmsAward
    awards(limit: Int = 100, locale: String, order: [CmsAwardOrder], preview: Boolean, skip: Int = 0, where: CmsAwardFilter): CmsAwardCollection
    badge(id: String!, locale: String, preview: Boolean): CmsBadge
    badges(limit: Int = 100, locale: String, order: [CmsBadgeOrder], preview: Boolean, skip: Int = 0, where: CmsBadgeFilter): CmsBadgeCollection
    bumper(id: String!, locale: String, preview: Boolean): CmsBumper
    bumpers(limit: Int = 100, locale: String, order: [CmsBumperOrder], preview: Boolean, skip: Int = 0, where: CmsBumperFilter): CmsBumperCollection
    communityPartner(id: String!, locale: String, preview: Boolean): CmsCommunityPartner
    communityPartners(limit: Int = 100, locale: String, order: [CmsCommunityPartnerOrder], preview: Boolean, skip: Int = 0, where: CmsCommunityPartnerFilter): CmsCommunityPartnerCollection
    entries(limit: Int = 100, locale: String, order: [CmsEntryOrder], preview: Boolean, skip: Int = 0, where: CmsEntryFilter): CmsEntryCollection
    event(id: String!, locale: String, preview: Boolean): CmsEvent
    events(limit: Int = 100, locale: String, order: [CmsEventOrder], preview: Boolean, skip: Int = 0, where: CmsEventFilter): CmsEventCollection
    faq(id: String!, locale: String, preview: Boolean): CmsFaq
    faqs(limit: Int = 100, locale: String, order: [CmsFaqOrder], preview: Boolean, skip: Int = 0, where: CmsFaqFilter): CmsFaqCollection
    form(id: String!, locale: String, preview: Boolean): CmsForm
    forms(limit: Int = 100, locale: String, order: [CmsFormOrder], preview: Boolean, skip: Int = 0, where: CmsFormFilter): CmsFormCollection
    globalSponsor(id: String!, locale: String, preview: Boolean): CmsGlobalSponsor
    globalSponsors(limit: Int = 100, locale: String, order: [CmsGlobalSponsorOrder], preview: Boolean, skip: Int = 0, where: CmsGlobalSponsorFilter): CmsGlobalSponsorCollection
    hiringCompanies(limit: Int = 100, locale: String, order: [CmsHiringCompanyOrder], preview: Boolean, skip: Int = 0, where: CmsHiringCompanyFilter): CmsHiringCompanyCollection
    hiringCompany(id: String!, locale: String, preview: Boolean): CmsHiringCompany
    hiringPost(id: String!, locale: String, preview: Boolean): CmsHiringPost
    hiringPosts(limit: Int = 100, locale: String, order: [CmsHiringPostOrder], preview: Boolean, skip: Int = 0, where: CmsHiringPostFilter): CmsHiringPostCollection
    legalDocument(id: String!, locale: String, preview: Boolean): CmsLegalDocument
    legalDocuments(limit: Int = 100, locale: String, order: [CmsLegalDocumentOrder], preview: Boolean, skip: Int = 0, where: CmsLegalDocumentFilter): CmsLegalDocumentCollection
    newsCoverage(id: String!, locale: String, preview: Boolean): CmsNewsCoverage
    newsCoverages(limit: Int = 100, locale: String, order: [CmsNewsCoverageOrder], preview: Boolean, skip: Int = 0, where: CmsNewsCoverageFilter): CmsNewsCoverageCollection
    pressPhoto(id: String!, locale: String, preview: Boolean): CmsPressPhoto
    pressPhotos(limit: Int = 100, locale: String, order: [CmsPressPhotoOrder], preview: Boolean, skip: Int = 0, where: CmsPressPhotoFilter): CmsPressPhotoCollection
    program(id: String!, locale: String, preview: Boolean): CmsProgram
    programs(limit: Int = 100, locale: String, order: [CmsProgramOrder], preview: Boolean, skip: Int = 0, where: CmsProgramFilter): CmsProgramCollection
    region(id: String!, locale: String, preview: Boolean): CmsRegion
    regions(limit: Int = 100, locale: String, order: [CmsRegionOrder], preview: Boolean, skip: Int = 0, where: CmsRegionFilter): CmsRegionCollection
    site(id: String!, locale: String, preview: Boolean): CmsSite
    sites(limit: Int = 100, locale: String, order: [CmsSiteOrder], preview: Boolean, skip: Int = 0, where: CmsSiteFilter): CmsSiteCollection
    socialMedia(id: String!, locale: String, preview: Boolean): CmsSocialMedia
    socialMedias(limit: Int = 100, locale: String, order: [CmsSocialMediaOrder], preview: Boolean, skip: Int = 0, where: CmsSocialMediaFilter): CmsSocialMediaCollection
    stockMusic(id: String!, locale: String, preview: Boolean): CmsStockMusic
    stockMusics(limit: Int = 100, locale: String, order: [CmsStockMusicOrder], preview: Boolean, skip: Int = 0, where: CmsStockMusicFilter): CmsStockMusicCollection
    string(id: String!, locale: String, preview: Boolean): CmsContentTypeString
    strings(limit: Int = 100, locale: String, order: [CmsContentTypeStringOrder], preview: Boolean, skip: Int = 0, where: CmsContentTypeStringFilter): CmsContentTypeStringCollection
    testimonial(id: String!, locale: String, preview: Boolean): CmsTestimonial
    testimonials(limit: Int = 100, locale: String, order: [CmsTestimonialOrder], preview: Boolean, skip: Int = 0, where: CmsTestimonialFilter): CmsTestimonialCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/region)"
type CmsRegion implements CmsEntry {
    abbr(locale: String): String
    accountingName(locale: String): String
    aliases(locale: String): [String]
    complication(locale: String, preview: Boolean): CmsAsset
    contentfulMetadata: CmsContentfulMetadata!
    countryName(locale: String): String
    countryNameAdjective(locale: String): String
    countryNameShort(locale: String): String
    countryNameShortAdjective(locale: String): String
    e164CountryCode(locale: String): String
    iso3166Alpha2Code(locale: String): String
    iso3166Alpha3Code(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsRegionLinkingCollections
    location(locale: String): CmsLocation
    motto(locale: String): String
    name(locale: String): String
    primaryColor(locale: String): String
    regionPhotos(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    skylinePhoto(locale: String, preview: Boolean): CmsAsset
    stickerLarge(locale: String, preview: Boolean): CmsAsset
    stickerSmall(locale: String, preview: Boolean): CmsAsset
    sys: CmsSys!
    timezone(locale: String): String
    webname(locale: String): String
}

type CmsRegionCollection {
    items: [CmsRegion]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsRegionLinkingCollections {
    communityPartners(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsCommunityPartnerCollection
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    hiringPosts(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsHiringPostCollection
    pressPhotos(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsPressPhotoCollection
    testimonials(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsTestimonialCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/site)"
type CmsSite implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    display(locale: String): [String]
    link(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsSiteLinkingCollections
    sys: CmsSys!
    title(locale: String): String
    type(locale: String): String
}

type CmsSiteCollection {
    items: [CmsSite]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsSiteLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/socialMedia)"
type CmsSocialMedia implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    icon(locale: String, preview: Boolean): CmsAsset
    linkedFrom(allowedLocales: [String]): CmsSocialMediaLinkingCollections
    name(locale: String): String
    sys: CmsSys!
    url(locale: String): String
}

type CmsSocialMediaCollection {
    items: [CmsSocialMedia]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsSocialMediaLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/stockMusic)"
type CmsStockMusic implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    linkedFrom(allowedLocales: [String]): CmsStockMusicLinkingCollections
    music(locale: String, preview: Boolean): CmsAsset
    sys: CmsSys!
    title(locale: String): String
}

type CmsStockMusicCollection {
    items: [CmsStockMusic]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsStockMusicLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsSys {
    environmentId: String!
    firstPublishedAt: CmsDateTime
    id: String!
    publishedAt: CmsDateTime
    publishedVersion: Int
    spaceId: String!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/testimonial)"
type CmsTestimonial implements CmsEntry {
    company(locale: String): String
    contentfulMetadata: CmsContentfulMetadata!
    experience(locale: String): String
    featured(locale: String): Boolean
    firstName(locale: String): String
    groupName(locale: String): String
    image(locale: String, preview: Boolean): CmsAsset
    lastName(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsTestimonialLinkingCollections
    program(locale: String, preview: Boolean): CmsProgram
    quote(locale: String): String
    region(locale: String, preview: Boolean): CmsRegion
    sys: CmsSys!
    title(locale: String): String
    type(locale: String): String
    video(locale: String, preview: Boolean): CmsAsset
}

type CmsTestimonialCollection {
    items: [CmsTestimonial]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsTestimonialLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type GeoGeoResult {
    accuracy: Float
    cityName: String
    country: String
    countryName: String
    ip: String
    isp: String
    lat: Float
    lng: Float
    organization: String
    postalCode: String
    subdivision: String
    subdivisionName: String
    tz: String
}

type GeoQuery {
    mine: GeoGeoResult!
}

type LabsMatch {
    project: LabsProject!
    score: Float!
}

type LabsMentor {
    account: AccountUser
    createdAt: LabsDateTime!
    email: String!
    givenName: String!
    id: String!
    manager: AccountUser
    managerUsername: String
    maxWeeks: Int!
    name: String!
    profile: LabsJSON!
    profileField(key: String!): LabsJSON
    projects: [LabsProject!]!
    status: LabsMentorStatus!
    surname: String!
    updatedAt: LabsDateTime!
    username: String
}

type LabsMutation {
    acceptStudentOffer: LabsStudent!
    addProjectMentor(mentor: LabsIdOrUsernameInput!, project: String!): LabsProject!
    addProjectStudent(project: String!, student: LabsIdOrUsernameInput!): LabsProject!
    applyMentor(data: LabsMentorApplyInput!): LabsMentor!
    applyStudent(data: LabsStudentApplyInput!): LabsStudent!
    cancelStudentApplication: LabsStudent!
    createMentor(data: LabsMentorCreateInput!): LabsMentor!
    createProject(data: LabsProjectCreateInput!, mentor: LabsIdOrUsernameInput): LabsProject!
    createStudent(data: LabsStudentCreateInput!): LabsStudent!
    createTag(data: LabsTagCreateInput!): LabsTag!
    deleteMentor(where: LabsIdOrUsernameInput!): Boolean!
    deleteProject(project: String!): Boolean!
    deleteStudent(where: LabsIdOrUsernameInput!): Boolean!
    deleteTag(tag: String!): Boolean!
    editMentor(data: LabsMentorEditInput!, where: LabsIdOrUsernameInput): LabsMentor!
    editProject(data: LabsProjectEditInput!, project: String!): LabsProject!
    editStudent(data: LabsStudentEditInput!, where: LabsIdOrUsernameInput): LabsStudent!
    editTag(data: LabsTagEditInput!, tag: String!): LabsTag!
    expressProjectPreferences(projects: [String!]!): [LabsPreference!]
    offerStudentAdmission(where: LabsIdOrUsernameInput!): LabsStudent!
    rejectStudent(reason: LabsRejectionReason, where: LabsIdOrUsernameInput!): LabsStudent!
    removeProjectMentor(mentor: LabsIdOrUsernameInput!, project: String!): LabsProject!
    removeProjectStudent(project: String!, student: LabsIdOrUsernameInput!): LabsProject!
    resetStudentAdmissionOffer(where: LabsIdOrUsernameInput!): LabsStudent!
    sendMentorEmail(body: String!, dryRun: Boolean = false, subject: String!, where: LabsMentorFilterInput): Float!
    sendStudentEmail(body: String!, dryRun: Boolean = false, subject: String!, where: LabsStudentFilterInput): Float!
    submitStudentRating(rating: Int!, track: LabsTrack!, where: LabsIdOrUsernameInput!): Boolean!
    submitTraining(tag: String!, url: String!): Boolean!
}

type LabsPreference {
    project: LabsProject!
    ranking: Float!
}

type LabsProject {
    createdAt: LabsDateTime!
    deliverables: String
    description: String
    id: String!
    maxStudents: Int!
    mentors: [LabsMentor!]!
    status: LabsProjectStatus!
    studentCount: Float!
    students: [LabsStudent!]!
    tags: [LabsTag!]!
    track: LabsTrack!
    updatedAt: LabsDateTime!
}

type LabsQuery {
    mentor(where: LabsIdOrUsernameInput): LabsMentor
    mentors(skip: Float, take: Float, where: LabsMentorFilterInput): [LabsMentor!]!
    nextStudentNeedingRating(track: LabsTrack): LabsStudent
    projectMatches(tags: [String!]!): [LabsMatch!]
    projectPreferences: [LabsPreference!]
    statAdmissionsStatus(track: LabsTrack): [LabsStat!]!
    student(where: LabsIdOrUsernameInput): LabsStudent
    students(skip: Float, take: Float, where: LabsStudentFilterInput): [LabsStudent!]!
    studentsTopRated(includeRejected: Boolean, skip: Float, take: Float, track: LabsTrack): [LabsStudent!]!
    tags(type: LabsTagType): [LabsTag!]!
}

type LabsStat {
    key: String!
    value: Float!
}

type LabsStudent {
    account: AccountUser
    admissionRatingAverage: Float
    admissionRatingCount: Float
    createdAt: LabsDateTime!
    email: String!
    givenName: String!
    hasValidAdmissionOffer: Boolean!
    id: String!
    minHours: Int!
    name: String!
    offerDate: LabsDateTime
    partnerCode: String
    profile: LabsJSON!
    projectCount: Float!
    projectPreferences: [LabsPreference!]!
    projects: [LabsProject!]!
    rejectionReason: LabsRejectionReason
    requiredTagTraining: [LabsTag!]!
    status: LabsStudentStatus!
    surname: String!
    tagTrainingSubmissions: [LabsTagTrainingSubmission!]!
    tags: [LabsTag!]!
    track: LabsTrack!
    trackRecommendation: [LabsTrackRecommendation!]
    updatedAt: LabsDateTime!
    username: String!
    weeks: Int!
}

type LabsTag {
    createdAt: LabsDateTime!
    id: String!
    mentorDisplayName: String!
    studentDisplayName: String!
    trainingLink: String
    type: LabsTagType!
    updatedAt: LabsDateTime!
}

type LabsTagTrainingSubmission {
    createdAt: LabsDateTime!
    id: String!
    student: LabsStudent!
    tag: LabsTag!
    updatedAt: LabsDateTime!
    url: String!
}

type LabsTrackRecommendation {
    track: LabsTrack!
    weight: Float!
}

"Represents a binary file in a space. An asset can be any file type."
type LearnAsset {
    contentType(locale: String): String
    contentfulBaseUrl(locale: String, transform: LearnImageTransformOptions): String
    contentfulMetadata: LearnContentfulMetadata!
    description(locale: String): String
    fileName(locale: String): String
    height(locale: String): Int
    linkedFrom(allowedLocales: [String]): LearnAssetLinkingCollections
    size(locale: String): Int
    sys: LearnSys!
    title(locale: String): String
    url(transform: LearnImageTransformOptions): String
    width(locale: String): Int
}

type LearnAssetCollection {
    items: [LearnAsset]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnAssetLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
    technologies(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTechnologyCollection
}

"Display an inline code block inside of rich content for lessons. [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/codeBlock)"
type LearnCodeBlock implements LearnEntry {
    code(locale: String): String
    contentfulMetadata: LearnContentfulMetadata!
    language(locale: String): String
    linkedFrom(allowedLocales: [String]): LearnCodeBlockLinkingCollections
    sys: LearnSys!
}

type LearnCodeBlockCollection {
    items: [LearnCodeBlock]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnCodeBlockLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
}

type LearnContentfulMetadata {
    tags: [LearnContentfulTag]!
}

"""

Represents a tag entity for finding and organizing content easily.
Find out more here: https://www.contentful.com/developers/docs/references/content-delivery-api/#/reference/content-tags
"""
type LearnContentfulTag {
    id: String
    name: String
}

"Determines the hardness of a particular lesson. [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/difficulty)"
type LearnDifficulty implements LearnEntry {
    contentfulMetadata: LearnContentfulMetadata!
    hexCodeColor(locale: String): String
    linkedFrom(allowedLocales: [String]): LearnDifficultyLinkingCollections
    name(locale: String): String
    shortDescription(locale: String): String
    sys: LearnSys!
}

type LearnDifficultyCollection {
    items: [LearnDifficulty]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnDifficultyLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
    tracks(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTrackCollection
}

type LearnEntryCollection {
    items: [LearnEntry]!
    limit: Int!
    skip: Int!
    total: Int!
}

"A specific topic within a track, a lesson can also be thought of as a page [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/lesson)"
type LearnLesson implements LearnEntry {
    content(locale: String): LearnLessonContent
    contentfulMetadata: LearnContentfulMetadata!
    hasNextPage(locale: String): Boolean
    id(locale: String): String
    linkedFrom(allowedLocales: [String]): LearnLessonLinkingCollections
    nameHeader(locale: String): String
    pageNumber(locale: String): Int
    points(locale: String): Int
    sys: LearnSys!
    tags(locale: String): [String]
    track(locale: String, preview: Boolean): LearnTrack
}

type LearnLessonCollection {
    items: [LearnLesson]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnLessonContent {
    json: LearnJSON!
    links: LearnLessonContentLinks!
}

type LearnLessonContentAssets {
    block: [LearnAsset]!
    hyperlink: [LearnAsset]!
}

type LearnLessonContentEntries {
    block: [LearnEntry]!
    hyperlink: [LearnEntry]!
    inline: [LearnEntry]!
}

type LearnLessonContentLinks {
    assets: LearnLessonContentAssets!
    entries: LearnLessonContentEntries!
}

type LearnLessonLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
    tracks(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTrackCollection
}

type LearnQuery {
    asset(id: String!, locale: String, preview: Boolean): LearnAsset
    assets(limit: Int = 100, locale: String, order: [LearnAssetOrder], preview: Boolean, skip: Int = 0, where: LearnAssetFilter): LearnAssetCollection
    codeBlock(id: String!, locale: String, preview: Boolean): LearnCodeBlock
    codeBlocks(limit: Int = 100, locale: String, order: [LearnCodeBlockOrder], preview: Boolean, skip: Int = 0, where: LearnCodeBlockFilter): LearnCodeBlockCollection
    difficulties(limit: Int = 100, locale: String, order: [LearnDifficultyOrder], preview: Boolean, skip: Int = 0, where: LearnDifficultyFilter): LearnDifficultyCollection
    difficulty(id: String!, locale: String, preview: Boolean): LearnDifficulty
    entries(limit: Int = 100, locale: String, order: [LearnEntryOrder], preview: Boolean, skip: Int = 0, where: LearnEntryFilter): LearnEntryCollection
    lesson(id: String!, locale: String, preview: Boolean): LearnLesson
    lessons(limit: Int = 100, locale: String, order: [LearnLessonOrder], preview: Boolean, skip: Int = 0, where: LearnLessonFilter): LearnLessonCollection
    reward(id: String!, locale: String, preview: Boolean): LearnReward
    rewards(limit: Int = 100, locale: String, order: [LearnRewardOrder], preview: Boolean, skip: Int = 0, where: LearnRewardFilter): LearnRewardCollection
    technologies(limit: Int = 100, locale: String, order: [LearnTechnologyOrder], preview: Boolean, skip: Int = 0, where: LearnTechnologyFilter): LearnTechnologyCollection
    technology(id: String!, locale: String, preview: Boolean): LearnTechnology
    track(id: String!, locale: String, preview: Boolean): LearnTrack
    tracks(limit: Int = 100, locale: String, order: [LearnTrackOrder], preview: Boolean, skip: Int = 0, where: LearnTrackFilter): LearnTrackCollection
}

"A toast which gives out rewards based on how well a user is doing. [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/reward)"
type LearnReward implements LearnEntry {
    contentfulMetadata: LearnContentfulMetadata!
    linkedFrom(allowedLocales: [String]): LearnRewardLinkingCollections
    name(locale: String): String
    shortDescription(locale: String): String
    sys: LearnSys!
}

type LearnRewardCollection {
    items: [LearnReward]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnRewardLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
}

type LearnSys {
    environmentId: String!
    firstPublishedAt: LearnDateTime
    id: String!
    publishedAt: LearnDateTime
    publishedVersion: Int
    spaceId: String!
}

"Describes a specific type of technology such as a programming language, framework, libraries, etc... [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/technology)"
type LearnTechnology implements LearnEntry {
    contentfulMetadata: LearnContentfulMetadata!
    description(locale: String): String
    image(locale: String, preview: Boolean): LearnAsset
    linkedFrom(allowedLocales: [String]): LearnTechnologyLinkingCollections
    name(locale: String): String
    sys: LearnSys!
}

type LearnTechnologyCollection {
    items: [LearnTechnology]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnTechnologyLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
    tracks(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTrackCollection
}

"A path that a user can take to start learning a particular topic [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/track)"
type LearnTrack implements LearnEntry {
    contentfulMetadata: LearnContentfulMetadata!
    description(locale: String): String
    difficulty(locale: String, preview: Boolean): LearnDifficulty
    id(locale: String): String
    lessons(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTrackLessonsCollection
    linkedFrom(allowedLocales: [String]): LearnTrackLinkingCollections
    name(locale: String): String
    previewProjectIds(locale: String): [String]
    previewProjects: [ShowcaseProject!]!
    spotlighted(locale: String): Boolean
    sys: LearnSys!
    technologies(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTrackTechnologiesCollection
}

type LearnTrackCollection {
    items: [LearnTrack]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnTrackLessonsCollection {
    items: [LearnLesson]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnTrackLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
    lessons(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnLessonCollection
}

type LearnTrackTechnologiesCollection {
    items: [LearnTechnology]!
    limit: Int!
    skip: Int!
    total: Int!
}

type Mutation {
    account: AccountMutation
    advisors: AdvisorsMutation
    blog: BlogRootMutation
    calendar: CalendarMutation
    clear: ClearMutation
    labs: LabsMutation
    showcase: ShowcaseMutation
}

type Query {
    account: AccountQuery
    advisors: AdvisorsQuery
    blog: BlogRootQuery
    calendar: CalendarQuery
    clear: ClearQuery
    cms: CmsQuery
    geo: GeoQuery
    labs: LabsQuery
    learn: LearnQuery
    showYourWork: ShowYourWorkQuery
    showcase: ShowcaseQuery
    twitch: TwitchQuery
}

type ShowYourWorkDiscordMessage {
    author: AccountUser
    createdAt: ShowYourWorkDateTime!
    id: String!
    imageUrl(fillBlur: Boolean, height: Float, strategy: ShowYourWorkResizeStrategy, width: Float): String!
    text: String!
    userId: String!
    videoUrl: String
}

type ShowYourWorkQuery {
    messages(skip: Float, take: Float): [ShowYourWorkDiscordMessage!]!
}

type ShowcaseAward {
    createdAt: ShowcaseDateTime!
    id: String!
    info: CmsAward
    modifier: String
    project: ShowcaseProject!
    type: String!
    updatedAt: ShowcaseDateTime!
}

type ShowcaseJudgement {
    createdAt: ShowcaseDateTime!
    id: String!
    judgingCriteria: ShowcaseJudgingCriteria!
    judgingPool: ShowcaseJudgingPool!
    updatedAt: ShowcaseDateTime!
    username: String!
    value: Float!
}

type ShowcaseJudgingCriteria {
    createdAt: ShowcaseDateTime!
    id: String!
    judgingPool: ShowcaseJudgingPool!
    name: String!
    updatedAt: ShowcaseDateTime!
    weight: Float!
}

type ShowcaseJudgingPool {
    createdAt: ShowcaseDateTime!
    eventGroupId: String
    eventId: String
    id: String!
    judgingCriteria: [ShowcaseJudgingCriteria!]!
    name: String!
    programId: String
    projects(needsJudging: Boolean = false, take: Float = 25.0): [ShowcaseProject!]!
    regionId: String
    results: [ShowcaseJudgingResult!]!
    updatedAt: ShowcaseDateTime!
}

type ShowcaseJudgingResult {
    count: Float!
    project: ShowcaseProject!
    subScores: [ShowcaseJudgingResultSubValue!]!
    value: Float!
}

type ShowcaseJudgingResultSubValue {
    count: Float!
    judgingCriteria: ShowcaseJudgingCriteria!
    value: Float!
}

type ShowcaseMedia {
    createdAt: ShowcaseDateTime!
    download: String
    id: String!
    image(fillBlur: Boolean, height: Float, strategy: ShowcaseResizeStrategy, width: Float): String!
    project: ShowcaseProject!
    stream: String
    topic: ShowcaseMediaTopic!
    type: ShowcaseMediaType!
    updatedAt: ShowcaseDateTime!
}

type ShowcaseMember {
    account: AccountUser
    createdAt: ShowcaseDateTime!
    project: ShowcaseProject!
    updatedAt: ShowcaseDateTime!
    username: String!
}

type ShowcaseMetadata {
    createdAt: ShowcaseDateTime!
    key: String!
    project: ShowcaseProject!
    updatedAt: ShowcaseDateTime!
    value: String!
    visibility: ShowcaseMetadataVisibility!
}

type ShowcaseMetricAggregate {
    project: ShowcaseProject!
    value: Float
}

type ShowcaseMetricTimeSeries {
    time: ShowcaseDateTime!
    value: Float!
}

type ShowcaseMutation {
    addAward(modifier: String, project: String!, type: String!): ShowcaseAward!
    addMember(project: String!, username: String!): ShowcaseMember!
    addReactions(id: String!, reactions: [ShowcaseAddReactionsInput!]!): Boolean!
    createJudgingPool(judgingPool: ShowcaseCreateJudgingPoolInput!): ShowcaseJudgingPool!
    createProject(project: ShowcaseCreateProjectInput!): ShowcaseProject!
    deleteMedia(id: String!): Boolean!
    deleteProject(id: String!): Boolean!
    editProject(id: String!, project: ShowcaseEditProjectInput!): ShowcaseProject!
    featureProject(id: String!, isFeatured: Boolean): Boolean!
    judgeProject(judgingCriteria: String!, project: String!, value: Float!): Boolean!
    recordMetric(member: String!, name: String!, project: String!, value: Float!): Boolean!
    removeAward(id: String!): Boolean!
    removeJudgingPool(judgingPool: String!): Boolean!
    removeMember(project: String!, username: String!): Boolean!
    setMetadata(key: String!, project: String!, value: String!, visibility: ShowcaseMetadataVisibility!): Boolean!
    unsetMetadata(key: String!, project: String!): Boolean!
    uploadMedia(project: String!, topic: ShowcaseMediaTopic!, type: ShowcaseMediaType!, upload: Upload!): ShowcaseMedia!
}

type ShowcaseProject {
    awards: [ShowcaseAward!]
    canAdmin: Boolean!
    canEdit: Boolean!
    challengesEncountered: String
    codeLink: String
    createdAt: ShowcaseDateTime!
    description: String
    eventGroup: CmsEvent
    eventGroupId: String
    eventId: String!
    featured: Boolean!
    id: String!
    media(take: Float = 100.0, topics: [ShowcaseMediaTopic!], type: ShowcaseMediaType): [ShowcaseMedia!]
    members: [ShowcaseMember!]
    metadata: [ShowcaseMetadata!]
    metadataValue(key: String!): String
    name: String!
    priorExperience: String
    program: CmsProgram
    programId: String!
    reactionCounts: [ShowcaseReactionCount!]!
    region: CmsRegion
    regionId: String
    slug: String
    type: ShowcaseProjectType!
    updatedAt: ShowcaseDateTime!
    userJudgement: [ShowcaseJudgement!]
    viewLink: String
}

type ShowcaseQuery {
    averageMemberRecentResponses(name: String!, projectWhere: ShowcaseProjectsWhere): [ShowcaseMetricAggregate!]!
    judgingPools: [ShowcaseJudgingPool!]!
    membersOverTime(where: ShowcaseProjectsWhere!): [ShowcaseMetricTimeSeries!]!
    myJudgingPool: ShowcaseJudgingPool!
    presentationReadyPercent(where: ShowcaseProjectsWhere!): Float!
    project(id: String, slug: String): ShowcaseProject!
    projects(orderBy: ShowcaseProjectOrderByArg, skip: Float, take: Float, where: ShowcaseProjectsWhere): [ShowcaseProject!]!
    projectsOverTime(where: ShowcaseProjectsWhere!): [ShowcaseMetricTimeSeries!]!
}

type ShowcaseReactionCount {
    count: Float!
    type: ShowcaseReactionType!
}

type Subscription {
    memberAdded(where: ShowcaseProjectsWhere): ShowcaseMember!
    memberRemoved(where: ShowcaseProjectsWhere): ShowcaseMember!
    projectCreated(where: ShowcaseProjectsWhere): ShowcaseProject!
    projectDeleted(where: ShowcaseProjectsWhere): ShowcaseProject!
    projectEdited(where: ShowcaseProjectsWhere): ShowcaseProject!
    userBadgeUpdate: AccountSubscriptionBadge
    userCultSelection: AccountSubscriptionUser
    userDisplayedBadgesUpdate: AccountSubscriptionUser
    userProfilePictureUpdate: AccountSubscriptionUser
    userRoleUpdate: AccountSubscriptionUser
    userUnlinkDiscord: String
    userUpdate: AccountSubscriptionUser
}

type TwitchLiveStatus {
    startedAt: String!
    thumbnail(height: Int!, width: Int!): String!
    title: String!
    url: String!
    username: String!
    viewerCount: Int!
}

type TwitchQuery {
    live: TwitchLiveStatus
}

enum AccountPizzaOrTurtle {
    PIZZA
    TURTLE
}

enum AccountUserPictureFit {
    CLAMP
    CLIP
    CROP
    FACEAREA
    FILL
    FILLMAX
    MAX
    MIN
    SCALE
}

enum AdvisorsAdvisorType {
    HR
    TECHNICAL
}

enum AdvisorsRecommendationRating {
    INTERN_BELOW
    INTERN_EXCEEDS
    INTERN_MEETS
    NEW_GRAD
    NEW_GRAD_EXCEEDS
}

enum AdvisorsRequestType {
    INTERVIEW
    RESUME
}

enum AdvisorsTagType {
    INTEREST
    TECHNOLOGY
}

"What rating to display avatars up to. Accepts 'G', 'PG', 'R', 'X', and are judged in that order. Default is the value of the 'avatar_rating' option"
enum BlogAvatarRatingEnum {
    "Indicates a G level avatar rating level."
    G
    "Indicates a PG level avatar rating level."
    PG
    "Indicates an R level avatar rating level."
    R
    "Indicates an X level avatar rating level."
    X
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogCategoryIdType {
    "The Database ID for the node"
    DATABASE_ID
    "The hashed Global ID"
    ID
    "The name of the node"
    NAME
    "Url friendly name of the node"
    SLUG
    "The URI for the node"
    URI
}

"Options for ordering the connection"
enum BlogCommentsConnectionOrderbyEnum {
    "Order by browser user agent of the commenter."
    COMMENT_AGENT
    "Order by true/false approval of the comment."
    COMMENT_APPROVED
    "Order by name of the comment author."
    COMMENT_AUTHOR
    "Order by e-mail of the comment author."
    COMMENT_AUTHOR_EMAIL
    "Order by IP address of the comment author."
    COMMENT_AUTHOR_IP
    "Order by URL address of the comment author."
    COMMENT_AUTHOR_URL
    "Order by the comment contents."
    COMMENT_CONTENT
    "Order by date/time timestamp of the comment."
    COMMENT_DATE
    "Order by GMT timezone date/time timestamp of the comment."
    COMMENT_DATE_GMT
    "Order by the globally unique identifier for the comment object"
    COMMENT_ID
    "Order by the array list of comment IDs listed in the where clause."
    COMMENT_IN
    "Order by the comment karma score."
    COMMENT_KARMA
    "Order by the comment parent ID."
    COMMENT_PARENT
    "Order by the post object ID."
    COMMENT_POST_ID
    "Order by the the type of comment, such as 'comment', 'pingback', or 'trackback'."
    COMMENT_TYPE
    "Order by the user ID."
    USER_ID
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogContentNodeIdTypeEnum {
    "Identify a resource by the Database ID."
    DATABASE_ID
    "Identify a resource by the (hashed) Global ID."
    ID
    "Identify a resource by the URI."
    URI
}

"Allowed Content Types"
enum BlogContentTypeEnum {
    "The Type of Content object"
    ATTACHMENT
    "The Type of Content object"
    PAGE
    "The Type of Content object"
    POST
}

"The Type of Identifier used to fetch a single Content Type node. To be used along with the \"id\" field. Default is \"ID\"."
enum BlogContentTypeIdTypeEnum {
    "The globally unique ID"
    ID
    "The name of the content type."
    NAME
}

"Allowed Content Types of the Category taxonomy."
enum BlogContentTypesOfCategoryEnum {
    "The Type of Content object"
    POST
}

"Allowed Content Types of the PostFormat taxonomy."
enum BlogContentTypesOfPostFormatEnum {
    "The Type of Content object"
    POST
}

"Allowed Content Types of the Tag taxonomy."
enum BlogContentTypesOfTagEnum {
    "The Type of Content object"
    POST
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogMediaItemIdType {
    "Identify a resource by the Database ID."
    DATABASE_ID
    "Identify a resource by the (hashed) Global ID."
    ID
    "Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier."
    SLUG
    "Identify a media item by its source url"
    SOURCE_URL
    "Identify a resource by the URI."
    URI
}

"The size of the media item object."
enum BlogMediaItemSizeEnum {
    "MediaItem with the large size"
    LARGE
    "MediaItem with the medium size"
    MEDIUM
    "MediaItem with the medium_large size"
    MEDIUM_LARGE
    "MediaItem with the thumbnail size"
    THUMBNAIL
    "MediaItem with the 1536x1536 size"
    _1536X1536
    "MediaItem with the 2048x2048 size"
    _2048X2048
}

"The status of the media item object."
enum BlogMediaItemStatusEnum {
    "Objects with the auto-draft status"
    AUTO_DRAFT
    "Objects with the inherit status"
    INHERIT
    "Objects with the private status"
    PRIVATE
    "Objects with the trash status"
    TRASH
}

"The Type of Identifier used to fetch a single node. Default is \"ID\". To be used along with the \"id\" field."
enum BlogMenuItemNodeIdTypeEnum {
    "Identify a resource by the Database ID."
    DATABASE_ID
    "Identify a resource by the (hashed) Global ID."
    ID
}

"Registered menu locations"
enum BlogMenuLocationEnum {
    "Empty menu location"
    EMPTY
}

"The Type of Identifier used to fetch a single node. Default is \"ID\". To be used along with the \"id\" field."
enum BlogMenuNodeIdTypeEnum {
    "Identify a menu node by the Database ID."
    DATABASE_ID
    "Identify a menu node by the (hashed) Global ID."
    ID
    "Identify a menu node by it's name"
    NAME
}

"The MimeType of the object"
enum BlogMimeTypeEnum {
    "MimeType application/java"
    APPLICATION_JAVA
    "MimeType application/msword"
    APPLICATION_MSWORD
    "MimeType application/octet-stream"
    APPLICATION_OCTET_STREAM
    "MimeType application/onenote"
    APPLICATION_ONENOTE
    "MimeType application/oxps"
    APPLICATION_OXPS
    "MimeType application/pdf"
    APPLICATION_PDF
    "MimeType application/rar"
    APPLICATION_RAR
    "MimeType application/rtf"
    APPLICATION_RTF
    "MimeType application/ttaf+xml"
    APPLICATION_TTAF_XML
    "MimeType application/vnd.apple.keynote"
    APPLICATION_VND_APPLE_KEYNOTE
    "MimeType application/vnd.apple.numbers"
    APPLICATION_VND_APPLE_NUMBERS
    "MimeType application/vnd.apple.pages"
    APPLICATION_VND_APPLE_PAGES
    "MimeType application/vnd.ms-access"
    APPLICATION_VND_MS_ACCESS
    "MimeType application/vnd.ms-excel"
    APPLICATION_VND_MS_EXCEL
    "MimeType application/vnd.ms-excel.addin.macroEnabled.12"
    APPLICATION_VND_MS_EXCEL_ADDIN_MACROENABLED_12
    "MimeType application/vnd.ms-excel.sheet.binary.macroEnabled.12"
    APPLICATION_VND_MS_EXCEL_SHEET_BINARY_MACROENABLED_12
    "MimeType application/vnd.ms-excel.sheet.macroEnabled.12"
    APPLICATION_VND_MS_EXCEL_SHEET_MACROENABLED_12
    "MimeType application/vnd.ms-excel.template.macroEnabled.12"
    APPLICATION_VND_MS_EXCEL_TEMPLATE_MACROENABLED_12
    "MimeType application/vnd.ms-powerpoint"
    APPLICATION_VND_MS_POWERPOINT
    "MimeType application/vnd.ms-powerpoint.addin.macroEnabled.12"
    APPLICATION_VND_MS_POWERPOINT_ADDIN_MACROENABLED_12
    "MimeType application/vnd.ms-powerpoint.presentation.macroEnabled.12"
    APPLICATION_VND_MS_POWERPOINT_PRESENTATION_MACROENABLED_12
    "MimeType application/vnd.ms-powerpoint.slideshow.macroEnabled.12"
    APPLICATION_VND_MS_POWERPOINT_SLIDESHOW_MACROENABLED_12
    "MimeType application/vnd.ms-powerpoint.slide.macroEnabled.12"
    APPLICATION_VND_MS_POWERPOINT_SLIDE_MACROENABLED_12
    "MimeType application/vnd.ms-powerpoint.template.macroEnabled.12"
    APPLICATION_VND_MS_POWERPOINT_TEMPLATE_MACROENABLED_12
    "MimeType application/vnd.ms-project"
    APPLICATION_VND_MS_PROJECT
    "MimeType application/vnd.ms-word.document.macroEnabled.12"
    APPLICATION_VND_MS_WORD_DOCUMENT_MACROENABLED_12
    "MimeType application/vnd.ms-word.template.macroEnabled.12"
    APPLICATION_VND_MS_WORD_TEMPLATE_MACROENABLED_12
    "MimeType application/vnd.ms-write"
    APPLICATION_VND_MS_WRITE
    "MimeType application/vnd.ms-xpsdocument"
    APPLICATION_VND_MS_XPSDOCUMENT
    "MimeType application/vnd.oasis.opendocument.chart"
    APPLICATION_VND_OASIS_OPENDOCUMENT_CHART
    "MimeType application/vnd.oasis.opendocument.database"
    APPLICATION_VND_OASIS_OPENDOCUMENT_DATABASE
    "MimeType application/vnd.oasis.opendocument.formula"
    APPLICATION_VND_OASIS_OPENDOCUMENT_FORMULA
    "MimeType application/vnd.oasis.opendocument.graphics"
    APPLICATION_VND_OASIS_OPENDOCUMENT_GRAPHICS
    "MimeType application/vnd.oasis.opendocument.presentation"
    APPLICATION_VND_OASIS_OPENDOCUMENT_PRESENTATION
    "MimeType application/vnd.oasis.opendocument.spreadsheet"
    APPLICATION_VND_OASIS_OPENDOCUMENT_SPREADSHEET
    "MimeType application/vnd.oasis.opendocument.text"
    APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT
    "MimeType application/vnd.openxmlformats-officedocument.presentationml.presentation"
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_PRESENTATION
    "MimeType application/vnd.openxmlformats-officedocument.presentationml.slide"
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDE
    "MimeType application/vnd.openxmlformats-officedocument.presentationml.slideshow"
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDESHOW
    "MimeType application/vnd.openxmlformats-officedocument.presentationml.template"
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_TEMPLATE
    "MimeType application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_SHEET
    "MimeType application/vnd.openxmlformats-officedocument.spreadsheetml.template"
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_TEMPLATE
    "MimeType application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_DOCUMENT
    "MimeType application/vnd.openxmlformats-officedocument.wordprocessingml.template"
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_TEMPLATE
    "MimeType application/wordperfect"
    APPLICATION_WORDPERFECT
    "MimeType application/x-7z-compressed"
    APPLICATION_X_7Z_COMPRESSED
    "MimeType application/x-gzip"
    APPLICATION_X_GZIP
    "MimeType application/x-tar"
    APPLICATION_X_TAR
    "MimeType application/zip"
    APPLICATION_ZIP
    "MimeType audio/aac"
    AUDIO_AAC
    "MimeType audio/flac"
    AUDIO_FLAC
    "MimeType audio/midi"
    AUDIO_MIDI
    "MimeType audio/mpeg"
    AUDIO_MPEG
    "MimeType audio/ogg"
    AUDIO_OGG
    "MimeType audio/wav"
    AUDIO_WAV
    "MimeType audio/x-matroska"
    AUDIO_X_MATROSKA
    "MimeType audio/x-ms-wax"
    AUDIO_X_MS_WAX
    "MimeType audio/x-ms-wma"
    AUDIO_X_MS_WMA
    "MimeType audio/x-realaudio"
    AUDIO_X_REALAUDIO
    "MimeType image/bmp"
    IMAGE_BMP
    "MimeType image/gif"
    IMAGE_GIF
    "MimeType image/heic"
    IMAGE_HEIC
    "MimeType image/jpeg"
    IMAGE_JPEG
    "MimeType image/png"
    IMAGE_PNG
    "MimeType image/tiff"
    IMAGE_TIFF
    "MimeType image/webp"
    IMAGE_WEBP
    "MimeType image/x-icon"
    IMAGE_X_ICON
    "MimeType text/calendar"
    TEXT_CALENDAR
    "MimeType text/css"
    TEXT_CSS
    "MimeType text/csv"
    TEXT_CSV
    "MimeType text/plain"
    TEXT_PLAIN
    "MimeType text/richtext"
    TEXT_RICHTEXT
    "MimeType text/tab-separated-values"
    TEXT_TAB_SEPARATED_VALUES
    "MimeType text/vtt"
    TEXT_VTT
    "MimeType video/3gpp"
    VIDEO_3GPP
    "MimeType video/3gpp2"
    VIDEO_3GPP2
    "MimeType video/avi"
    VIDEO_AVI
    "MimeType video/divx"
    VIDEO_DIVX
    "MimeType video/mp4"
    VIDEO_MP4
    "MimeType video/mpeg"
    VIDEO_MPEG
    "MimeType video/ogg"
    VIDEO_OGG
    "MimeType video/quicktime"
    VIDEO_QUICKTIME
    "MimeType video/webm"
    VIDEO_WEBM
    "MimeType video/x-flv"
    VIDEO_X_FLV
    "MimeType video/x-matroska"
    VIDEO_X_MATROSKA
    "MimeType video/x-ms-asf"
    VIDEO_X_MS_ASF
    "MimeType video/x-ms-wm"
    VIDEO_X_MS_WM
    "MimeType video/x-ms-wmv"
    VIDEO_X_MS_WMV
    "MimeType video/x-ms-wmx"
    VIDEO_X_MS_WMX
}

"The cardinality of the connection order"
enum BlogOrderEnum {
    "Sort the query result set in an ascending order"
    ASC
    "Sort the query result set in a descending order"
    DESC
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogPageIdType {
    "Identify a resource by the Database ID."
    DATABASE_ID
    "Identify a resource by the (hashed) Global ID."
    ID
    "Identify a resource by the URI."
    URI
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogPostFormatIdType {
    "The Database ID for the node"
    DATABASE_ID
    "The hashed Global ID"
    ID
    "The name of the node"
    NAME
    "Url friendly name of the node"
    SLUG
    "The URI for the node"
    URI
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogPostIdType {
    "Identify a resource by the Database ID."
    DATABASE_ID
    "Identify a resource by the (hashed) Global ID."
    ID
    "Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier."
    SLUG
    "Identify a resource by the URI."
    URI
}

"The format of post field data."
enum BlogPostObjectFieldFormatEnum {
    "Provide the field value directly from database"
    RAW
    "Apply the default WordPress rendering"
    RENDERED
}

"The column to use when filtering by date"
enum BlogPostObjectsConnectionDateColumnEnum {
    "The date the comment was created in local time."
    DATE
    "The most recent modification date of the comment."
    MODIFIED
}

"Field to order the connection by"
enum BlogPostObjectsConnectionOrderbyEnum {
    "Order by author"
    AUTHOR
    "Order by the number of comments it has acquired"
    COMMENT_COUNT
    "Order by publish date"
    DATE
    "Preserve the ID order given in the IN array"
    IN
    "Order by the menu order value"
    MENU_ORDER
    "Order by last modified date"
    MODIFIED
    "Preserve slug order given in the NAME_IN array"
    NAME_IN
    "Order by parent ID"
    PARENT
    "Order by slug"
    SLUG
    "Order by title"
    TITLE
}

"The status of the object."
enum BlogPostStatusEnum {
    "Objects with the acf-disabled status"
    ACF_DISABLED
    "Objects with the auto-draft status"
    AUTO_DRAFT
    "Objects with the draft status"
    DRAFT
    "Objects with the future status"
    FUTURE
    "Objects with the inherit status"
    INHERIT
    "Objects with the pending status"
    PENDING
    "Objects with the private status"
    PRIVATE
    "Objects with the publish status"
    PUBLISH
    "Objects with the request-completed status"
    REQUEST_COMPLETED
    "Objects with the request-confirmed status"
    REQUEST_CONFIRMED
    "Objects with the request-failed status"
    REQUEST_FAILED
    "Objects with the request-pending status"
    REQUEST_PENDING
    "Objects with the trash status"
    TRASH
}

"The logical relation between each item in the array when there are more than one."
enum BlogRelationEnum {
    "The logical AND condition returns true if both operands are true, otherwise, it returns false."
    AND
    "The logical OR condition returns false if both operands are false, otherwise, it returns true."
    OR
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogTagIdType {
    "The Database ID for the node"
    DATABASE_ID
    "The hashed Global ID"
    ID
    "The name of the node"
    NAME
    "Url friendly name of the node"
    SLUG
    "The URI for the node"
    URI
}

"Allowed taxonomies"
enum BlogTaxonomyEnum {
    "Taxonomy enum category"
    CATEGORY
    "Taxonomy enum post_format"
    POSTFORMAT
    "Taxonomy enum post_tag"
    TAG
}

"The Type of Identifier used to fetch a single Taxonomy node. To be used along with the \"id\" field. Default is \"ID\"."
enum BlogTaxonomyIdTypeEnum {
    "The globally unique ID"
    ID
    "The name of the taxonomy"
    NAME
}

"The Type of Identifier used to fetch a single resource. Default is \"ID\". To be used along with the \"id\" field."
enum BlogTermNodeIdTypeEnum {
    "The Database ID for the node"
    DATABASE_ID
    "The hashed Global ID"
    ID
    "The name of the node"
    NAME
    "Url friendly name of the node"
    SLUG
    "The URI for the node"
    URI
}

"Options for ordering the connection by"
enum BlogTermObjectsConnectionOrderbyEnum {
    "Order the connection by item count."
    COUNT
    "Order the connection by description."
    DESCRIPTION
    "Order the connection by name."
    NAME
    "Order the connection by slug."
    SLUG
    "Order the connection by term group."
    TERM_GROUP
    "Order the connection by term id."
    TERM_ID
    "Order the connection by term order."
    TERM_ORDER
}

"The Type of Identifier used to fetch a single User node. To be used along with the \"id\" field. Default is \"ID\"."
enum BlogUserNodeIdTypeEnum {
    "The Database ID for the node"
    DATABASE_ID
    "The Email of the User"
    EMAIL
    "The hashed Global ID"
    ID
    "The slug of the User"
    SLUG
    "The URI for the node"
    URI
    "The username the User uses to login with"
    USERNAME
}

"Names of available user roles"
enum BlogUserRoleEnum {
    "User role with specific capabilities"
    ADMINISTRATOR
    "User role with specific capabilities"
    AUTHOR
    "User role with specific capabilities"
    CONTRIBUTOR
    "User role with specific capabilities"
    EDITOR
    "User role with specific capabilities"
    SUBSCRIBER
}

"Field to order the connection by"
enum BlogUsersConnectionOrderbyEnum {
    "Order by display name"
    DISPLAY_NAME
    "Order by email address"
    EMAIL
    "Order by login"
    LOGIN
    "Preserve the login order given in the LOGIN_IN array"
    LOGIN_IN
    "Order by nice name"
    NICE_NAME
    "Preserve the nice name order given in the NICE_NAME_IN array"
    NICE_NAME_IN
    "Order by registration date"
    REGISTERED
    "Order by URL"
    URL
}

"Column used for searching for users."
enum BlogUsersConnectionSearchColumnEnum {
    "The user's email address."
    EMAIL
    "The globally unique ID."
    ID
    "The username the User uses to login with."
    LOGIN
    "A URL-friendly name for the user. The default is the user's username."
    NICENAME
    "The URL of the user\\s website."
    URL
}

enum CalendarFormat {
    DISCORD
    HTML
    MARKDOWN
}

enum CalendarOrder {
    ASC
    DESC
}

enum ClearDiscountType {
    PERCENT
    SUBTRACT
}

enum ClearEmailTemplateScalarFieldEnum {
    automatic
    createdAt
    extraFilters
    fromEmail
    fromName
    id
    marketing
    metadata
    name
    replyTo
    sendAfterEvent
    sendInWorkHours
    sendLate
    sendParent
    sendText
    sendTo
    subject
    template
    textMsg
    updatedAt
    when
    whenFrom
}

enum ClearEmailWhenFrom {
    EVENTEND
    EVENTSTART
    REGISTER
}

enum ClearEventGroupScalarFieldEnum {
    createdAt
    earlyBirdCutoff
    earlyBirdPrice
    endDate
    id
    metadata
    name
    registrationCutoff
    showcaseId
    startDate
    ticketPrice
    updatedAt
}

enum ClearEventRestrictionScalarFieldEnum {
    createdAt
    details
    iconUri
    id
    metadata
    name
    title
    updatedAt
}

enum ClearEventScalarFieldEnum {
    contentfulWebname
    createdAt
    earlyBirdCutoff
    earlyBirdPrice
    endDate
    eventGroupId
    id
    majorityAge
    managers
    metadata
    name
    registrationCutoff
    registrationsOpen
    showcaseId
    startDate
    ticketPrice
    timezone
    updatedAt
    venueId
}

enum ClearMailingListMemberScalarFieldEnum {
    createdAt
    email
    id
    lastEmailed
    metadata
    updatedAt
}

enum ClearPaymentScalarFieldEnum {
    complete
    createdAt
    id
    metadata
    stripePaymentIntentId
    updatedAt
}

enum ClearPersonScalarFieldEnum {
    age
    createdAt
    email
    firstName
    id
    lastName
    metadata
    phone
    pronouns
    updatedAt
    username
}

enum ClearPromoCodeScalarFieldEnum {
    amount
    code
    createdAt
    eventGroupId
    eventId
    id
    metadata
    type
    updatedAt
    uses
}

enum ClearQueryMode {
    default
    insensitive
}

enum ClearScheduleItemScalarFieldEnum {
    createdAt
    description
    end
    eventGroupId
    eventId
    finalized
    hostEmail
    hostName
    hostPronoun
    id
    internal
    link
    metadata
    name
    organizerEmail
    organizerName
    organizerPhone
    start
    type
    updatedAt
}

enum ClearSortOrder {
    asc
    desc
}

enum ClearSponsorScalarFieldEnum {
    amount
    contactEmail
    contactName
    contactPhone
    createdAt
    darkLogoImageUri
    description
    eventId
    id
    link
    logoImageUri
    metadata
    name
    perks
    updatedAt
}

enum ClearTicketScalarFieldEnum {
    age
    couponCode
    createdAt
    email
    eventId
    firstName
    id
    lastName
    metadata
    paymentId
    personId
    phone
    promoCodeId
    type
    updatedAt
    waiverSigned
}

enum ClearTicketType {
    JUDGE
    MENTOR
    STAFF
    STUDENT
    TEACHER
    VIP
}

enum ClearVenueScalarFieldEnum {
    address
    capacity
    contactEmail
    contactName
    contactPhone
    createdAt
    id
    mapLink
    metadata
    name
    updatedAt
}

enum CmsAnnouncementOrder {
    displayAt_ASC
    displayAt_DESC
    endAt_ASC
    endAt_DESC
    link_ASC
    link_DESC
    oneline_ASC
    oneline_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    type_ASC
    type_DESC
    visibility_ASC
    visibility_DESC
}

enum CmsAssetOrder {
    contentType_ASC
    contentType_DESC
    fileName_ASC
    fileName_DESC
    height_ASC
    height_DESC
    size_ASC
    size_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    url_ASC
    url_DESC
    width_ASC
    width_DESC
}

enum CmsAwardOrder {
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    ranking_ASC
    ranking_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum CmsBadgeOrder {
    description_ASC
    description_DESC
    earnCriteria_ASC
    earnCriteria_DESC
    emoji_ASC
    emoji_DESC
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum CmsBumperOrder {
    ambient_ASC
    ambient_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
}

enum CmsCommunityPartnerOrder {
    blurb_ASC
    blurb_DESC
    cost_ASC
    cost_DESC
    displayUrl_ASC
    displayUrl_DESC
    eligibility_ASC
    eligibility_DESC
    expires_ASC
    expires_DESC
    name_ASC
    name_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    url_ASC
    url_DESC
}

enum CmsContentTypeStringOrder {
    key_ASC
    key_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum CmsEntryOrder {
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum CmsEventOrder {
    awardsAt_ASC
    awardsAt_DESC
    calendarReleaseDate_ASC
    calendarReleaseDate_DESC
    endsAt_ASC
    endsAt_DESC
    id_ASC
    id_DESC
    participantRoleId_ASC
    participantRoleId_DESC
    registrationsCloseAt_ASC
    registrationsCloseAt_DESC
    registrationsOpenAt_ASC
    registrationsOpenAt_DESC
    startsAt_ASC
    startsAt_DESC
    statEventCount_ASC
    statEventCount_DESC
    statLowInterestContinuedCount_ASC
    statLowInterestContinuedCount_DESC
    statLowInterestCount_ASC
    statLowInterestCount_DESC
    statStudentCount_ASC
    statStudentCount_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    theme_ASC
    theme_DESC
    title_ASC
    title_DESC
}

enum CmsFaqOrder {
    featured_ASC
    featured_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
}

enum CmsFormOrder {
    cognitoForm_ASC
    cognitoForm_DESC
    slug_ASC
    slug_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
}

enum CmsGlobalSponsorOrder {
    instagramUsername_ASC
    instagramUsername_DESC
    link_ASC
    link_DESC
    name_ASC
    name_DESC
    shortDescription_ASC
    shortDescription_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    twitterUsername_ASC
    twitterUsername_DESC
    type_ASC
    type_DESC
}

enum CmsHiringCompanyOrder {
    featured_ASC
    featured_DESC
    name_ASC
    name_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    url_ASC
    url_DESC
}

enum CmsHiringPostOrder {
    paid_ASC
    paid_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    type_ASC
    type_DESC
    url_ASC
    url_DESC
}

enum CmsImageFormat {
    AVIF
    "JPG image format."
    JPG
    """

    Progressive JPG format stores multiple passes of an image in progressively higher detail.
    When a progressive image is loading, the viewer will first see a lower quality pixelated version which
    will gradually improve in detail, until the image is fully downloaded. This is to display an image as
    early as possible to make the layout look as designed.
    """
    JPG_PROGRESSIVE
    "PNG image format"
    PNG
    """

    8-bit PNG images support up to 256 colors and weigh less than the standard 24-bit PNG equivalent.
    The 8-bit PNG format is mostly used for simple images, such as icons or logos.
    """
    PNG8
    "WebP image format."
    WEBP
}

enum CmsImageResizeFocus {
    "Focus the resizing on the bottom."
    BOTTOM
    "Focus the resizing on the bottom left."
    BOTTOM_LEFT
    "Focus the resizing on the bottom right."
    BOTTOM_RIGHT
    "Focus the resizing on the center."
    CENTER
    "Focus the resizing on the largest face."
    FACE
    "Focus the resizing on the area containing all the faces."
    FACES
    "Focus the resizing on the left."
    LEFT
    "Focus the resizing on the right."
    RIGHT
    "Focus the resizing on the top."
    TOP
    "Focus the resizing on the top left."
    TOP_LEFT
    "Focus the resizing on the top right."
    TOP_RIGHT
}

enum CmsImageResizeStrategy {
    "Crops a part of the original image to fit into the specified dimensions."
    CROP
    "Resizes the image to the specified dimensions, cropping the image if needed."
    FILL
    "Resizes the image to fit into the specified dimensions."
    FIT
    """

    Resizes the image to the specified dimensions, padding the image if needed.
    Uses desired background color as padding color.
    """
    PAD
    "Resizes the image to the specified dimensions, changing the original aspect ratio if needed."
    SCALE
    "Creates a thumbnail from the image."
    THUMB
}

enum CmsLegalDocumentOrder {
    date_ASC
    date_DESC
    id_ASC
    id_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    type_ASC
    type_DESC
}

enum CmsNewsCoverageOrder {
    date_ASC
    date_DESC
    featured_ASC
    featured_DESC
    publicationName_ASC
    publicationName_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    url_ASC
    url_DESC
}

enum CmsPressPhotoOrder {
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum CmsProgramOrder {
    archived_ASC
    archived_DESC
    name_ASC
    name_DESC
    shortDescription_ASC
    shortDescription_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    type_ASC
    type_DESC
    url_ASC
    url_DESC
    virtual_ASC
    virtual_DESC
    volunteerUrl_ASC
    volunteerUrl_DESC
    webname_ASC
    webname_DESC
}

enum CmsRegionOrder {
    abbr_ASC
    abbr_DESC
    accountingName_ASC
    accountingName_DESC
    countryNameAdjective_ASC
    countryNameAdjective_DESC
    countryNameShortAdjective_ASC
    countryNameShortAdjective_DESC
    countryNameShort_ASC
    countryNameShort_DESC
    countryName_ASC
    countryName_DESC
    e164CountryCode_ASC
    e164CountryCode_DESC
    iso3166Alpha2Code_ASC
    iso3166Alpha2Code_DESC
    iso3166Alpha3Code_ASC
    iso3166Alpha3Code_DESC
    motto_ASC
    motto_DESC
    name_ASC
    name_DESC
    primaryColor_ASC
    primaryColor_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    timezone_ASC
    timezone_DESC
    webname_ASC
    webname_DESC
}

enum CmsSiteOrder {
    link_ASC
    link_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    type_ASC
    type_DESC
}

enum CmsSocialMediaOrder {
    name_ASC
    name_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    url_ASC
    url_DESC
}

enum CmsStockMusicOrder {
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
}

enum CmsTestimonialOrder {
    company_ASC
    company_DESC
    experience_ASC
    experience_DESC
    featured_ASC
    featured_DESC
    firstName_ASC
    firstName_DESC
    groupName_ASC
    groupName_DESC
    lastName_ASC
    lastName_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    type_ASC
    type_DESC
}

enum LabsMentorStatus {
    ACCEPTED
    APPLIED
    CANCELED
    REJECTED
    SCHEDULED
}

enum LabsProjectStatus {
    ACCEPTED
    DRAFT
    MATCHED
    PROPOSED
}

enum LabsRejectionReason {
    EXPERIENCE_HIGH
    EXPERIENCE_LOW
    OTHER
}

enum LabsStudentStatus {
    ACCEPTED
    APPLIED
    CANCELED
    OFFERED
    REJECTED
    TRACK_CHALLENGE
    TRACK_INTERVIEW
}

enum LabsTagType {
    INTEREST
    TECHNOLOGY
}

enum LabsTrack {
    ADVANCED
    BEGINNER
    INTERMEDIATE
}

enum LearnAssetOrder {
    contentType_ASC
    contentType_DESC
    fileName_ASC
    fileName_DESC
    height_ASC
    height_DESC
    size_ASC
    size_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    url_ASC
    url_DESC
    width_ASC
    width_DESC
}

enum LearnCodeBlockOrder {
    language_ASC
    language_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnDifficultyOrder {
    hexCodeColor_ASC
    hexCodeColor_DESC
    name_ASC
    name_DESC
    shortDescription_ASC
    shortDescription_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnEntryOrder {
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnImageFormat {
    AVIF
    "JPG image format."
    JPG
    """

    Progressive JPG format stores multiple passes of an image in progressively higher detail.
    When a progressive image is loading, the viewer will first see a lower quality pixelated version which
    will gradually improve in detail, until the image is fully downloaded. This is to display an image as
    early as possible to make the layout look as designed.
    """
    JPG_PROGRESSIVE
    "PNG image format"
    PNG
    """

    8-bit PNG images support up to 256 colors and weigh less than the standard 24-bit PNG equivalent.
    The 8-bit PNG format is mostly used for simple images, such as icons or logos.
    """
    PNG8
    "WebP image format."
    WEBP
}

enum LearnImageResizeFocus {
    "Focus the resizing on the bottom."
    BOTTOM
    "Focus the resizing on the bottom left."
    BOTTOM_LEFT
    "Focus the resizing on the bottom right."
    BOTTOM_RIGHT
    "Focus the resizing on the center."
    CENTER
    "Focus the resizing on the largest face."
    FACE
    "Focus the resizing on the area containing all the faces."
    FACES
    "Focus the resizing on the left."
    LEFT
    "Focus the resizing on the right."
    RIGHT
    "Focus the resizing on the top."
    TOP
    "Focus the resizing on the top left."
    TOP_LEFT
    "Focus the resizing on the top right."
    TOP_RIGHT
}

enum LearnImageResizeStrategy {
    "Crops a part of the original image to fit into the specified dimensions."
    CROP
    "Resizes the image to the specified dimensions, cropping the image if needed."
    FILL
    "Resizes the image to fit into the specified dimensions."
    FIT
    """

    Resizes the image to the specified dimensions, padding the image if needed.
    Uses desired background color as padding color.
    """
    PAD
    "Resizes the image to the specified dimensions, changing the original aspect ratio if needed."
    SCALE
    "Creates a thumbnail from the image."
    THUMB
}

enum LearnLessonOrder {
    hasNextPage_ASC
    hasNextPage_DESC
    id_ASC
    id_DESC
    nameHeader_ASC
    nameHeader_DESC
    pageNumber_ASC
    pageNumber_DESC
    points_ASC
    points_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnRewardOrder {
    name_ASC
    name_DESC
    shortDescription_ASC
    shortDescription_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnTechnologyOrder {
    name_ASC
    name_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnTrackOrder {
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    spotlighted_ASC
    spotlighted_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum ShowYourWorkResizeStrategy {
    CLAMP
    CLIP
    CROP
    FACEAREA
    FILL
    FILLMAX
    MAX
    MIN
    SCALE
}

enum ShowcaseMediaFilterType {
    ANY
    AUDIOS
    BOTH
    IMAGES
    VIDEOS
}

enum ShowcaseMediaTopic {
    DEMO
    JUDGES
    PRESENTATION
    TEAM
}

enum ShowcaseMediaType {
    AUDIO
    IMAGE
    VIDEO
}

enum ShowcaseMetadataVisibility {
    ADMIN
    PRIVATE
    PUBLIC
}

enum ShowcaseProjectOrderByArg {
    NEWEST
    OLDEST
}

enum ShowcaseProjectType {
    APP
    BOT
    GAME
    HARDWARE
    LIBRARY
    OTHER
    VR
    WEBSITE
}

enum ShowcaseReactionType {
    CLAP
    GRIN
    HEART
    UPVOTE
}

enum ShowcaseResizeStrategy {
    CLAMP
    CLIP
    CROP
    FACEAREA
    FILL
    FILLMAX
    MAX
    MIN
    SCALE
}

input AccountDisplayedUserBadgeInput {
    id: ID!
    order: Int!
}

input AccountUpdateUserInput {
    acceptTos: Boolean
    bio: String
    blocked: Boolean
    displayNameFormat: String
    email: String
    familyName: String
    givenName: String
    phoneNumber: String
    pronoun: String
    title: String
    username: String
}

input AccountUserBadgeInput {
    displayed: Boolean
    expiresUtc: String
    id: ID!
    order: Int
}

input AccountUserPictureTransformInput {
    fit: AccountUserPictureFit
    height: Int
    width: Int
}

input AccountUserSearch {
    familyName: String
    givenName: String
    name: String
    username: String
}

input AccountUserSingleInput {
    discordId: String
    email: String
    id: ID
    username: String
}

input AdvisorsAdvisorCreateInput {
    email: String!
    familyName: String!
    givenName: String!
    limits: AdvisorsAdvisorLimitInput!
    type: AdvisorsAdvisorType!
    username: String
}

input AdvisorsAdvisorLimitInput {
    interviewsPerWeek: Float!
    resumesPerWeek: Float!
}

input AdvisorsAdvisorWhereInput {
    email: String
    id: String
    username: String
}

input AdvisorsEventParticipationCreateInput {
    awardIds: [String!]
    eventId: String!
}

input AdvisorsProfileCreateInput {
    bio: String
    email: String!
    experience: [String!]
    familyName: String!
    givenName: String!
    gradHighSchoolAt: AdvisorsDateTime
    gradUniversityAt: AdvisorsDateTime
    resume: Upload
    searchFullTimeAt: AdvisorsDateTime
    searchInternships: Boolean = false
    searchOpen: Boolean = false
    underrepresentedEthnicity: Boolean = false
    underrepresentedGender: Boolean = false
    urlGithub: String
    urlLinkedIn: String
    urlWebsite: String
    workFteAt: AdvisorsDateTime
    workInternAt: AdvisorsDateTime
}

input AdvisorsProfileEditInput {
    bio: String
    email: String
    experience: [String!]
    familyName: String
    givenName: String
    gradHighSchoolAt: AdvisorsDateTime
    gradUniversityAt: AdvisorsDateTime
    resume: Upload
    searchFullTimeAt: AdvisorsDateTime
    searchInternships: Boolean
    searchOpen: Boolean
    underrepresentedEthnicity: Boolean
    underrepresentedGender: Boolean
    urlGithub: String
    urlLinkedIn: String
    urlWebsite: String
    workFteAt: AdvisorsDateTime
    workInternAt: AdvisorsDateTime
}

input AdvisorsRecommendationCreateInput {
    employer: String!
    familyName: String!
    givenName: String!
    recommendation: String
    relation: String!
    skillEngineering: AdvisorsRecommendationRating
    skillInterpersonal: AdvisorsRecommendationRating
    skillTechnical: AdvisorsRecommendationRating
    title: String!
}

input AdvisorsRecommendationEditInput {
    employer: String
    familyName: String
    givenName: String
    recommendation: String
    relation: String
    skillEngineering: AdvisorsRecommendationRating
    skillInterpersonal: AdvisorsRecommendationRating
    skillTechnical: AdvisorsRecommendationRating
    title: String
}

input AdvisorsRequestCountWhereInput {
    domain: String
    emails: [String!]
    usernames: [String!]
}

input AdvisorsTagCreateInput {
    displayName: String!
    id: String!
    type: AdvisorsTagType!
}

"Arguments for filtering the CategoryToCategoryConnection connection"
input BlogCategoryToCategoryConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Direction the connection should be ordered in"
    order: BlogOrderEnum
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the CategoryToContentNodeConnection connection"
input BlogCategoryToContentNodeConnectionWhereArgs {
    "The Types of content to filter"
    contentTypes: [BlogContentTypesOfCategoryEnum]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the CategoryToPostConnection connection"
input BlogCategoryToPostConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Arguments for filtering the CommentToCommentConnection connection"
input BlogCommentToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    "Array of IDs of users whose unapproved comments will be returned by the query regardless of status."
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    "Limit results to those affiliated with a given content object ID."
    contentId: ID
    "Array of content object IDs to include affiliated comments for."
    contentIdIn: [ID]
    "Array of content object IDs to exclude affiliated comments for."
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    "Array of parent IDs of comments *not* to retrieve children for."
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the CommentToParentCommentConnection connection"
input BlogCommentToParentCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    "Array of IDs of users whose unapproved comments will be returned by the query regardless of status."
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    "Limit results to those affiliated with a given content object ID."
    contentId: ID
    "Array of content object IDs to include affiliated comments for."
    contentIdIn: [ID]
    "Array of content object IDs to exclude affiliated comments for."
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    "Array of parent IDs of comments *not* to retrieve children for."
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the ContentTypeToContentNodeConnection connection"
input BlogContentTypeToContentNodeConnectionWhereArgs {
    "The Types of content to filter"
    contentTypes: [BlogContentTypeEnum]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Input for the createCategory mutation"
input BlogCreateCategoryInput {
    "The slug that the category will be an alias of"
    aliasOf: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The description of the category object"
    description: String
    "The name of the category object to mutate"
    name: String!
    "The ID of the category that should be set as the parent"
    parentId: ID
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the createComment mutation"
input BlogCreateCommentInput {
    "The approval status of the comment."
    approved: String
    "The name of the comment's author."
    author: String
    "The email of the comment's author."
    authorEmail: String
    "The url of the comment's author."
    authorUrl: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the post object the comment belongs to."
    commentOn: Int
    "Content of the comment."
    content: String
    "The date of the object. Preferable to enter as year/month/day ( e.g. 01/31/2017 ) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "Parent comment of current comment."
    parent: ID
    "Type of comment."
    type: String
}

"Input for the createMediaItem mutation"
input BlogCreateMediaItemInput {
    "Alternative text to display when mediaItem is not displayed"
    altText: String
    "The userId to assign as the author of the mediaItem"
    authorId: ID
    "The caption for the mediaItem"
    caption: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The comment status for the mediaItem"
    commentStatus: String
    "The date of the mediaItem"
    date: String
    "The date (in GMT zone) of the mediaItem"
    dateGmt: String
    "Description of the mediaItem"
    description: String
    "The file name of the mediaItem"
    filePath: String
    "The file type of the mediaItem"
    fileType: BlogMimeTypeEnum
    "The WordPress post ID or the graphQL postId of the parent object"
    parentId: ID
    "The ping status for the mediaItem"
    pingStatus: String
    "The slug of the mediaItem"
    slug: String
    "The status of the mediaItem"
    status: BlogMediaItemStatusEnum
    "The title of the mediaItem"
    title: String
}

"Input for the createPage mutation"
input BlogCreatePageInput {
    "The userId to assign as the author of the object"
    authorId: ID
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The comment status for the object"
    commentStatus: String
    "The content of the object"
    content: String
    "The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int
    "The ID of the parent object"
    parentId: ID
    "The password used to protect the content of the object"
    password: String
    "The slug of the object"
    slug: String
    "The title of the object"
    title: String
}

"Input for the createPostFormat mutation"
input BlogCreatePostFormatInput {
    "The slug that the post_format will be an alias of"
    aliasOf: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The description of the post_format object"
    description: String
    "The name of the post_format object to mutate"
    name: String!
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the createPost mutation"
input BlogCreatePostInput {
    "The userId to assign as the author of the object"
    authorId: ID
    "Set connections between the post and categories"
    categories: BlogPostCategoriesInput
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The comment status for the object"
    commentStatus: String
    "The content of the object"
    content: String
    "The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "The excerpt of the object"
    excerpt: String
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int
    "The password used to protect the content of the object"
    password: String
    "The ping status for the object"
    pingStatus: String
    "URLs that have been pinged."
    pinged: [String]
    "Set connections between the post and postFormats"
    postFormats: BlogPostPostFormatsInput
    "The slug of the object"
    slug: String
    "Set connections between the post and tags"
    tags: BlogPostTagsInput
    "The title of the object"
    title: String
    "URLs queued to be pinged."
    toPing: [String]
}

"Input for the createTag mutation"
input BlogCreateTagInput {
    "The slug that the post_tag will be an alias of"
    aliasOf: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The description of the post_tag object"
    description: String
    "The name of the post_tag object to mutate"
    name: String!
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the createUser mutation"
input BlogCreateUserInput {
    "User's AOL IM account."
    aim: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "A string containing content about the user."
    description: String
    "A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user)."
    displayName: String
    "A string containing the user's email address."
    email: String
    "\tThe user's first name."
    firstName: String
    "User's Jabber account."
    jabber: String
    "The user's last name."
    lastName: String
    "User's locale."
    locale: String
    "A string that contains a URL-friendly name for the user. The default is the user's username."
    nicename: String
    "The user's nickname, defaults to the user's username."
    nickname: String
    "A string that contains the plain text password for the user."
    password: String
    "The date the user registered. Format is Y-m-d H:i:s."
    registered: String
    "A string for whether to enable the rich editor or not. False if not empty."
    richEditing: String
    "An array of roles to be assigned to the user."
    roles: [String]
    "A string that contains the user's username for logging in."
    username: String!
    "A string containing the user's URL for the user's web site."
    websiteUrl: String
    "User's Yahoo IM account."
    yim: String
}

"Date values"
input BlogDateInput {
    "Day of the month (from 1 to 31)"
    day: Int
    "Month number (from 1 to 12)"
    month: Int
    "4 digit year (e.g. 2017)"
    year: Int
}

"Filter the connection based on input"
input BlogDateQueryInput {
    "Nodes should be returned after this date"
    after: BlogDateInput
    "Nodes should be returned before this date"
    before: BlogDateInput
    "Column to query against"
    column: BlogPostObjectsConnectionDateColumnEnum
    "For after/before, whether exact value should be matched or not"
    compare: String
    "Day of the month (from 1 to 31)"
    day: Int
    "Hour (from 0 to 23)"
    hour: Int
    "For after/before, whether exact value should be matched or not"
    inclusive: Boolean
    "Minute (from 0 to 59)"
    minute: Int
    "Month number (from 1 to 12)"
    month: Int
    "OR or AND, how the sub-arrays should be compared"
    relation: BlogRelationEnum
    "Second (0 to 59)"
    second: Int
    "Week of the year (from 0 to 53)"
    week: Int
    "4 digit year (e.g. 2017)"
    year: Int
}

"Input for the deleteCategory mutation"
input BlogDeleteCategoryInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the category to delete"
    id: ID!
}

"Input for the deleteComment mutation"
input BlogDeleteCommentInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "Whether the comment should be force deleted instead of being moved to the trash"
    forceDelete: Boolean
    "The deleted comment ID"
    id: ID!
}

"Input for the deleteMediaItem mutation"
input BlogDeleteMediaItemInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "Whether the mediaItem should be force deleted instead of being moved to the trash"
    forceDelete: Boolean
    "The ID of the mediaItem to delete"
    id: ID!
}

"Input for the deletePage mutation"
input BlogDeletePageInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "Whether the object should be force deleted instead of being moved to the trash"
    forceDelete: Boolean
    "The ID of the page to delete"
    id: ID!
}

"Input for the deletePostFormat mutation"
input BlogDeletePostFormatInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the postFormat to delete"
    id: ID!
}

"Input for the deletePost mutation"
input BlogDeletePostInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "Whether the object should be force deleted instead of being moved to the trash"
    forceDelete: Boolean
    "The ID of the post to delete"
    id: ID!
}

"Input for the deleteTag mutation"
input BlogDeleteTagInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the tag to delete"
    id: ID!
}

"Input for the deleteUser mutation"
input BlogDeleteUserInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the user you want to delete"
    id: ID!
    "Reassign posts and links to new User ID."
    reassignId: ID
}

"Arguments for filtering the HierarchicalContentNodeToContentNodeAncestorsConnection connection"
input BlogHierarchicalContentNodeToContentNodeAncestorsConnectionWhereArgs {
    "The Types of content to filter"
    contentTypes: [BlogContentTypeEnum]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the HierarchicalContentNodeToContentNodeChildrenConnection connection"
input BlogHierarchicalContentNodeToContentNodeChildrenConnectionWhereArgs {
    "The Types of content to filter"
    contentTypes: [BlogContentTypeEnum]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the MediaItemToCommentConnection connection"
input BlogMediaItemToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    "Array of IDs of users whose unapproved comments will be returned by the query regardless of status."
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    "Limit results to those affiliated with a given content object ID."
    contentId: ID
    "Array of content object IDs to include affiliated comments for."
    contentIdIn: [ID]
    "Array of content object IDs to exclude affiliated comments for."
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    "Array of parent IDs of comments *not* to retrieve children for."
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the MenuItemToMenuItemConnection connection"
input BlogMenuItemToMenuItemConnectionWhereArgs {
    "The ID of the object"
    id: Int
    "The menu location for the menu being queried"
    location: BlogMenuLocationEnum
    "The database ID of the parent menu object"
    parentDatabaseId: Int
    "The ID of the parent menu object"
    parentId: ID
}

"Arguments for filtering the MenuToMenuItemConnection connection"
input BlogMenuToMenuItemConnectionWhereArgs {
    "The ID of the object"
    id: Int
    "The menu location for the menu being queried"
    location: BlogMenuLocationEnum
    "The database ID of the parent menu object"
    parentDatabaseId: Int
    "The ID of the parent menu object"
    parentId: ID
}

"Arguments for filtering the PageToCommentConnection connection"
input BlogPageToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    "Array of IDs of users whose unapproved comments will be returned by the query regardless of status."
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    "Limit results to those affiliated with a given content object ID."
    contentId: ID
    "Array of content object IDs to include affiliated comments for."
    contentIdIn: [ID]
    "Array of content object IDs to exclude affiliated comments for."
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    "Array of parent IDs of comments *not* to retrieve children for."
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the pageToRevisionConnection connection"
input BlogPageToRevisionConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Set relationships between the post to categories"
input BlogPostCategoriesInput {
    "If true, this will append the category to existing related categories. If false, this will replace existing relationships. Default true."
    append: Boolean
    "The input list of items to set."
    nodes: [BlogPostCategoriesNodeInput]
}

"List of categories to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists."
input BlogPostCategoriesNodeInput {
    "The description of the category. This field is used to set a description of the category if a new one is created during the mutation."
    description: String
    "The ID of the category. If present, this will be used to connect to the post. If no existing category exists with this ID, no connection will be made."
    id: ID
    "The name of the category. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field."
    name: String
    "The slug of the category. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation."
    slug: String
}

"Arguments for filtering the PostFormatToContentNodeConnection connection"
input BlogPostFormatToContentNodeConnectionWhereArgs {
    "The Types of content to filter"
    contentTypes: [BlogContentTypesOfPostFormatEnum]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the PostFormatToPostConnection connection"
input BlogPostFormatToPostConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Options for ordering the connection"
input BlogPostObjectsConnectionOrderbyInput {
    "The field to order the connection by"
    field: BlogPostObjectsConnectionOrderbyEnum!
    "Possible directions in which to order a list of items"
    order: BlogOrderEnum!
}

"Set relationships between the post to postFormats"
input BlogPostPostFormatsInput {
    "If true, this will append the postFormat to existing related postFormats. If false, this will replace existing relationships. Default true."
    append: Boolean
    "The input list of items to set."
    nodes: [BlogPostPostFormatsNodeInput]
}

"List of postFormats to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists."
input BlogPostPostFormatsNodeInput {
    "The description of the postFormat. This field is used to set a description of the postFormat if a new one is created during the mutation."
    description: String
    "The ID of the postFormat. If present, this will be used to connect to the post. If no existing postFormat exists with this ID, no connection will be made."
    id: ID
    "The name of the postFormat. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field."
    name: String
    "The slug of the postFormat. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation."
    slug: String
}

"Set relationships between the post to tags"
input BlogPostTagsInput {
    "If true, this will append the tag to existing related tags. If false, this will replace existing relationships. Default true."
    append: Boolean
    "The input list of items to set."
    nodes: [BlogPostTagsNodeInput]
}

"List of tags to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists."
input BlogPostTagsNodeInput {
    "The description of the tag. This field is used to set a description of the tag if a new one is created during the mutation."
    description: String
    "The ID of the tag. If present, this will be used to connect to the post. If no existing tag exists with this ID, no connection will be made."
    id: ID
    "The name of the tag. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field."
    name: String
    "The slug of the tag. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation."
    slug: String
}

"Arguments for filtering the PostToCategoryConnection connection"
input BlogPostToCategoryConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Direction the connection should be ordered in"
    order: BlogOrderEnum
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the PostToCommentConnection connection"
input BlogPostToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    "Array of IDs of users whose unapproved comments will be returned by the query regardless of status."
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    "Limit results to those affiliated with a given content object ID."
    contentId: ID
    "Array of content object IDs to include affiliated comments for."
    contentIdIn: [ID]
    "Array of content object IDs to exclude affiliated comments for."
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    "Array of parent IDs of comments *not* to retrieve children for."
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the PostToPostFormatConnection connection"
input BlogPostToPostFormatConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Direction the connection should be ordered in"
    order: BlogOrderEnum
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the postToRevisionConnection connection"
input BlogPostToRevisionConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Arguments for filtering the PostToTagConnection connection"
input BlogPostToTagConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Direction the connection should be ordered in"
    order: BlogOrderEnum
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the PostToTermNodeConnection connection"
input BlogPostToTermNodeConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Direction the connection should be ordered in"
    order: BlogOrderEnum
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "The Taxonomy to filter terms by"
    taxonomies: [BlogTaxonomyEnum]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Input for the registerUser mutation"
input BlogRegisterUserInput {
    "User's AOL IM account."
    aim: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "A string containing content about the user."
    description: String
    "A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user)."
    displayName: String
    "A string containing the user's email address."
    email: String
    "\tThe user's first name."
    firstName: String
    "User's Jabber account."
    jabber: String
    "The user's last name."
    lastName: String
    "User's locale."
    locale: String
    "A string that contains a URL-friendly name for the user. The default is the user's username."
    nicename: String
    "The user's nickname, defaults to the user's username."
    nickname: String
    "A string that contains the plain text password for the user."
    password: String
    "The date the user registered. Format is Y-m-d H:i:s."
    registered: String
    "A string for whether to enable the rich editor or not. False if not empty."
    richEditing: String
    "A string that contains the user's username."
    username: String!
    "A string containing the user's URL for the user's web site."
    websiteUrl: String
    "User's Yahoo IM account."
    yim: String
}

"Input for the resetUserPassword mutation"
input BlogResetUserPasswordInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "Password reset key"
    key: String
    "The user's login (username)."
    login: String
    "The new password."
    password: String
}

"Input for the restoreComment mutation"
input BlogRestoreCommentInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the comment to be restored"
    id: ID!
}

"Arguments for filtering the RootQueryToCategoryConnection connection"
input BlogRootQueryToCategoryConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Direction the connection should be ordered in"
    order: BlogOrderEnum
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the RootQueryToCommentConnection connection"
input BlogRootQueryToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    "Array of IDs of users whose unapproved comments will be returned by the query regardless of status."
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    "Limit results to those affiliated with a given content object ID."
    contentId: ID
    "Array of content object IDs to include affiliated comments for."
    contentIdIn: [ID]
    "Array of content object IDs to exclude affiliated comments for."
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    "Array of parent IDs of comments *not* to retrieve children for."
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the RootQueryToContentNodeConnection connection"
input BlogRootQueryToContentNodeConnectionWhereArgs {
    "The Types of content to filter"
    contentTypes: [BlogContentTypeEnum]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the RootQueryToContentRevisionUnionConnection connection"
input BlogRootQueryToContentRevisionUnionConnectionWhereArgs {
    "The Types of content to filter"
    contentTypes: [BlogContentTypeEnum]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the RootQueryToMediaItemConnection connection"
input BlogRootQueryToMediaItemConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the RootQueryToMenuConnection connection"
input BlogRootQueryToMenuConnectionWhereArgs {
    "The ID of the object"
    id: Int
    "The menu location for the menu being queried"
    location: BlogMenuLocationEnum
    "The slug of the menu to query items for"
    slug: String
}

"Arguments for filtering the RootQueryToMenuItemConnection connection"
input BlogRootQueryToMenuItemConnectionWhereArgs {
    "The ID of the object"
    id: Int
    "The menu location for the menu being queried"
    location: BlogMenuLocationEnum
    "The database ID of the parent menu object"
    parentDatabaseId: Int
    "The ID of the parent menu object"
    parentId: ID
}

"Arguments for filtering the RootQueryToPageConnection connection"
input BlogRootQueryToPageConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the RootQueryToPostConnection connection"
input BlogRootQueryToPostConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Arguments for filtering the RootQueryToPostFormatConnection connection"
input BlogRootQueryToPostFormatConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Direction the connection should be ordered in"
    order: BlogOrderEnum
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the RootQueryToTagConnection connection"
input BlogRootQueryToTagConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Direction the connection should be ordered in"
    order: BlogOrderEnum
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the RootQueryToTermNodeConnection connection"
input BlogRootQueryToTermNodeConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Direction the connection should be ordered in"
    order: BlogOrderEnum
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "The Taxonomy to filter terms by"
    taxonomies: [BlogTaxonomyEnum]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the RootQueryToUserConnection connection"
input BlogRootQueryToUserConnectionWhereArgs {
    "Array of userIds to exclude."
    exclude: [Int]
    "Pass an array of post types to filter results to users who have published posts in those post types."
    hasPublishedPosts: [BlogContentTypeEnum]
    "Array of userIds to include."
    include: [Int]
    "The user login."
    login: String
    "An array of logins to include. Users matching one of these logins will be included in results."
    loginIn: [String]
    "An array of logins to exclude. Users matching one of these logins will not be included in results."
    loginNotIn: [String]
    "The user nicename."
    nicename: String
    "An array of nicenames to include. Users matching one of these nicenames will be included in results."
    nicenameIn: [String]
    "An array of nicenames to exclude. Users matching one of these nicenames will not be included in results."
    nicenameNotIn: [String]
    "What paramater to use to order the objects by."
    orderby: [BlogUsersConnectionOrderbyInput]
    "An array of role names that users must match to be included in results. Note that this is an inclusive list: users must match *each* role."
    role: BlogUserRoleEnum
    "An array of role names. Matched users must have at least one of these roles."
    roleIn: [BlogUserRoleEnum]
    "An array of role names to exclude. Users matching one or more of these roles will not be included in results."
    roleNotIn: [BlogUserRoleEnum]
    "Search keyword. Searches for possible string matches on columns. When \"searchColumns\" is left empty, it tries to determine which column to search in based on search string."
    search: String
    "Array of column names to be searched. Accepts 'ID', 'login', 'nicename', 'email', 'url'."
    searchColumns: [BlogUsersConnectionSearchColumnEnum]
}

"Input for the sendPasswordResetEmail mutation"
input BlogSendPasswordResetEmailInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "A string that contains the user's username or email address."
    username: String!
}

"Arguments for filtering the TagToContentNodeConnection connection"
input BlogTagToContentNodeConnectionWhereArgs {
    "The Types of content to filter"
    contentTypes: [BlogContentTypesOfTagEnum]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the TagToPostConnection connection"
input BlogTagToPostConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Input for the UpdateCategory mutation"
input BlogUpdateCategoryInput {
    "The slug that the category will be an alias of"
    aliasOf: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The description of the category object"
    description: String
    "The ID of the category object to update"
    id: ID!
    "The name of the category object to mutate"
    name: String
    "The ID of the category that should be set as the parent"
    parentId: ID
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the updateComment mutation"
input BlogUpdateCommentInput {
    "The approval status of the comment."
    approved: String
    "The name of the comment's author."
    author: String
    "The email of the comment's author."
    authorEmail: String
    "The url of the comment's author."
    authorUrl: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The ID of the post object the comment belongs to."
    commentOn: Int
    "Content of the comment."
    content: String
    "The date of the object. Preferable to enter as year/month/day ( e.g. 01/31/2017 ) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "The ID of the comment being updated."
    id: ID!
    "Parent comment of current comment."
    parent: ID
    "Type of comment."
    type: String
}

"Input for the updateMediaItem mutation"
input BlogUpdateMediaItemInput {
    "Alternative text to display when mediaItem is not displayed"
    altText: String
    "The userId to assign as the author of the mediaItem"
    authorId: ID
    "The caption for the mediaItem"
    caption: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The comment status for the mediaItem"
    commentStatus: String
    "The date of the mediaItem"
    date: String
    "The date (in GMT zone) of the mediaItem"
    dateGmt: String
    "Description of the mediaItem"
    description: String
    "The file name of the mediaItem"
    filePath: String
    "The file type of the mediaItem"
    fileType: BlogMimeTypeEnum
    "The ID of the mediaItem object"
    id: ID!
    "The WordPress post ID or the graphQL postId of the parent object"
    parentId: ID
    "The ping status for the mediaItem"
    pingStatus: String
    "The slug of the mediaItem"
    slug: String
    "The status of the mediaItem"
    status: BlogMediaItemStatusEnum
    "The title of the mediaItem"
    title: String
}

"Input for the updatePage mutation"
input BlogUpdatePageInput {
    "The userId to assign as the author of the object"
    authorId: ID
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The comment status for the object"
    commentStatus: String
    "The content of the object"
    content: String
    "The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "The ID of the page object"
    id: ID!
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int
    "The ID of the parent object"
    parentId: ID
    "The password used to protect the content of the object"
    password: String
    "The slug of the object"
    slug: String
    "The title of the object"
    title: String
}

"Input for the UpdatePostFormat mutation"
input BlogUpdatePostFormatInput {
    "The slug that the post_format will be an alias of"
    aliasOf: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The description of the post_format object"
    description: String
    "The ID of the postFormat object to update"
    id: ID!
    "The name of the post_format object to mutate"
    name: String
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the updatePost mutation"
input BlogUpdatePostInput {
    "The userId to assign as the author of the object"
    authorId: ID
    "Set connections between the post and categories"
    categories: BlogPostCategoriesInput
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The comment status for the object"
    commentStatus: String
    "The content of the object"
    content: String
    "The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "The excerpt of the object"
    excerpt: String
    "The ID of the post object"
    id: ID!
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int
    "The password used to protect the content of the object"
    password: String
    "The ping status for the object"
    pingStatus: String
    "URLs that have been pinged."
    pinged: [String]
    "Set connections between the post and postFormats"
    postFormats: BlogPostPostFormatsInput
    "The slug of the object"
    slug: String
    "Set connections between the post and tags"
    tags: BlogPostTagsInput
    "The title of the object"
    title: String
    "URLs queued to be pinged."
    toPing: [String]
}

"Input for the updateSettings mutation"
input BlogUpdateSettingsInput {
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "Allow people to submit comments on new posts."
    discussionSettingsDefaultCommentStatus: String
    "Allow link notifications from other blogs (pingbacks and trackbacks) on new articles."
    discussionSettingsDefaultPingStatus: String
    "A date format for all date strings."
    generalSettingsDateFormat: String
    "Site tagline."
    generalSettingsDescription: String
    "This address is used for admin purposes, like new user notification."
    generalSettingsEmail: String
    "WordPress locale code."
    generalSettingsLanguage: String
    "A day number of the week that the week should start on."
    generalSettingsStartOfWeek: Int
    "A time format for all time strings."
    generalSettingsTimeFormat: String
    "A city in the same timezone as you."
    generalSettingsTimezone: String
    "Site title."
    generalSettingsTitle: String
    "Site URL."
    generalSettingsUrl: String
    "Blog pages show at most."
    readingSettingsPostsPerPage: Int
    "Default post category."
    writingSettingsDefaultCategory: Int
    "Default post format."
    writingSettingsDefaultPostFormat: String
    "Convert emoticons like :-) and :-P to graphics on display."
    writingSettingsUseSmilies: Boolean
}

"Input for the UpdateTag mutation"
input BlogUpdateTagInput {
    "The slug that the post_tag will be an alias of"
    aliasOf: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "The description of the post_tag object"
    description: String
    "The ID of the tag object to update"
    id: ID!
    "The name of the post_tag object to mutate"
    name: String
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the updateUser mutation"
input BlogUpdateUserInput {
    "User's AOL IM account."
    aim: String
    "This is an ID that can be passed to a mutation by the client to track the progress of mutations and catch possible duplicate mutation submissions."
    clientMutationId: String
    "A string containing content about the user."
    description: String
    "A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user)."
    displayName: String
    "A string containing the user's email address."
    email: String
    "\tThe user's first name."
    firstName: String
    "The ID of the user"
    id: ID!
    "User's Jabber account."
    jabber: String
    "The user's last name."
    lastName: String
    "User's locale."
    locale: String
    "A string that contains a URL-friendly name for the user. The default is the user's username."
    nicename: String
    "The user's nickname, defaults to the user's username."
    nickname: String
    "A string that contains the plain text password for the user."
    password: String
    "The date the user registered. Format is Y-m-d H:i:s."
    registered: String
    "A string for whether to enable the rich editor or not. False if not empty."
    richEditing: String
    "An array of roles to be assigned to the user."
    roles: [String]
    "A string containing the user's URL for the user's web site."
    websiteUrl: String
    "User's Yahoo IM account."
    yim: String
}

"Arguments for filtering the UserToCommentConnection connection"
input BlogUserToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    "Array of IDs of users whose unapproved comments will be returned by the query regardless of status."
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    "Limit results to those affiliated with a given content object ID."
    contentId: ID
    "Array of content object IDs to include affiliated comments for."
    contentIdIn: [ID]
    "Array of content object IDs to exclude affiliated comments for."
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    "Array of parent IDs of comments *not* to retrieve children for."
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the UserToContentRevisionUnionConnection connection"
input BlogUserToContentRevisionUnionConnectionWhereArgs {
    "The Types of content to filter"
    contentTypes: [BlogContentTypeEnum]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the UserToMediaItemConnection connection"
input BlogUserToMediaItemConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the UserToPageConnection connection"
input BlogUserToPageConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the UserToPostConnection connection"
input BlogUserToPostConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: ID
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Options for ordering the connection"
input BlogUsersConnectionOrderbyInput {
    "The field name used to sort the results."
    field: BlogUsersConnectionOrderbyEnum!
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
}

input ClearBoolFieldUpdateOperationsInput {
    set: Boolean
}

input ClearBoolFilter {
    equals: Boolean
    not: ClearNestedBoolFilter
}

input ClearBoolWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedBoolFilter
    _min: ClearNestedBoolFilter
    equals: Boolean
    not: ClearNestedBoolWithAggregatesFilter
}

input ClearDateTimeFieldUpdateOperationsInput {
    set: ClearDateTime
}

input ClearDateTimeFilter {
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeFilter
    notIn: [ClearDateTime!]
}

input ClearDateTimeNullableFilter {
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeNullableFilter
    notIn: [ClearDateTime!]
}

input ClearDateTimeNullableWithAggregatesFilter {
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedDateTimeNullableFilter
    _min: ClearNestedDateTimeNullableFilter
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeNullableWithAggregatesFilter
    notIn: [ClearDateTime!]
}

input ClearDateTimeWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedDateTimeFilter
    _min: ClearNestedDateTimeFilter
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeWithAggregatesFilter
    notIn: [ClearDateTime!]
}

input ClearEmailTemplateCountOrderByAggregateInput {
    automatic: ClearSortOrder
    createdAt: ClearSortOrder
    extraFilters: ClearSortOrder
    fromEmail: ClearSortOrder
    fromName: ClearSortOrder
    id: ClearSortOrder
    marketing: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    replyTo: ClearSortOrder
    sendAfterEvent: ClearSortOrder
    sendInWorkHours: ClearSortOrder
    sendLate: ClearSortOrder
    sendParent: ClearSortOrder
    sendText: ClearSortOrder
    sendTo: ClearSortOrder
    subject: ClearSortOrder
    template: ClearSortOrder
    textMsg: ClearSortOrder
    updatedAt: ClearSortOrder
    when: ClearSortOrder
    whenFrom: ClearSortOrder
}

input ClearEmailTemplateCreateInput {
    automatic: Boolean
    createdAt: ClearDateTime
    extraFilters: ClearJSON
    fromEmail: String
    fromName: String
    id: String
    marketing: Boolean
    metadata: ClearJSON
    name: String!
    replyTo: String
    sendAfterEvent: Boolean
    sendInWorkHours: Boolean
    sendLate: Boolean
    sendParent: Boolean
    sendText: Boolean
    sendTo: ClearTicketType!
    sentTo: ClearTicketCreateNestedManyWithoutSentEmailsInput
    subject: String!
    template: String!
    textMsg: String
    updatedAt: ClearDateTime
    when: String!
    whenFrom: ClearEmailWhenFrom!
}

input ClearEmailTemplateCreateManyInput {
    automatic: Boolean
    createdAt: ClearDateTime
    extraFilters: ClearJSON
    fromEmail: String
    fromName: String
    id: String
    marketing: Boolean
    metadata: ClearJSON
    name: String!
    replyTo: String
    sendAfterEvent: Boolean
    sendInWorkHours: Boolean
    sendLate: Boolean
    sendParent: Boolean
    sendText: Boolean
    sendTo: ClearTicketType!
    subject: String!
    template: String!
    textMsg: String
    updatedAt: ClearDateTime
    when: String!
    whenFrom: ClearEmailWhenFrom!
}

input ClearEmailTemplateCreateNestedManyWithoutSentToInput {
    connect: [ClearEmailTemplateWhereUniqueInput!]
    connectOrCreate: [ClearEmailTemplateCreateOrConnectWithoutSentToInput!]
    create: [ClearEmailTemplateCreateWithoutSentToInput!]
}

input ClearEmailTemplateCreateOrConnectWithoutSentToInput {
    create: ClearEmailTemplateCreateWithoutSentToInput!
    where: ClearEmailTemplateWhereUniqueInput!
}

input ClearEmailTemplateCreateWithoutSentToInput {
    automatic: Boolean
    createdAt: ClearDateTime
    extraFilters: ClearJSON
    fromEmail: String
    fromName: String
    id: String
    marketing: Boolean
    metadata: ClearJSON
    name: String!
    replyTo: String
    sendAfterEvent: Boolean
    sendInWorkHours: Boolean
    sendLate: Boolean
    sendParent: Boolean
    sendText: Boolean
    sendTo: ClearTicketType!
    subject: String!
    template: String!
    textMsg: String
    updatedAt: ClearDateTime
    when: String!
    whenFrom: ClearEmailWhenFrom!
}

input ClearEmailTemplateListRelationFilter {
    every: ClearEmailTemplateWhereInput
    none: ClearEmailTemplateWhereInput
    some: ClearEmailTemplateWhereInput
}

input ClearEmailTemplateMaxOrderByAggregateInput {
    automatic: ClearSortOrder
    createdAt: ClearSortOrder
    fromEmail: ClearSortOrder
    fromName: ClearSortOrder
    id: ClearSortOrder
    marketing: ClearSortOrder
    name: ClearSortOrder
    replyTo: ClearSortOrder
    sendAfterEvent: ClearSortOrder
    sendInWorkHours: ClearSortOrder
    sendLate: ClearSortOrder
    sendParent: ClearSortOrder
    sendText: ClearSortOrder
    sendTo: ClearSortOrder
    subject: ClearSortOrder
    template: ClearSortOrder
    textMsg: ClearSortOrder
    updatedAt: ClearSortOrder
    when: ClearSortOrder
    whenFrom: ClearSortOrder
}

input ClearEmailTemplateMinOrderByAggregateInput {
    automatic: ClearSortOrder
    createdAt: ClearSortOrder
    fromEmail: ClearSortOrder
    fromName: ClearSortOrder
    id: ClearSortOrder
    marketing: ClearSortOrder
    name: ClearSortOrder
    replyTo: ClearSortOrder
    sendAfterEvent: ClearSortOrder
    sendInWorkHours: ClearSortOrder
    sendLate: ClearSortOrder
    sendParent: ClearSortOrder
    sendText: ClearSortOrder
    sendTo: ClearSortOrder
    subject: ClearSortOrder
    template: ClearSortOrder
    textMsg: ClearSortOrder
    updatedAt: ClearSortOrder
    when: ClearSortOrder
    whenFrom: ClearSortOrder
}

input ClearEmailTemplateOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearEmailTemplateOrderByWithAggregationInput {
    _count: ClearEmailTemplateCountOrderByAggregateInput
    _max: ClearEmailTemplateMaxOrderByAggregateInput
    _min: ClearEmailTemplateMinOrderByAggregateInput
    automatic: ClearSortOrder
    createdAt: ClearSortOrder
    extraFilters: ClearSortOrder
    fromEmail: ClearSortOrder
    fromName: ClearSortOrder
    id: ClearSortOrder
    marketing: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    replyTo: ClearSortOrder
    sendAfterEvent: ClearSortOrder
    sendInWorkHours: ClearSortOrder
    sendLate: ClearSortOrder
    sendParent: ClearSortOrder
    sendText: ClearSortOrder
    sendTo: ClearSortOrder
    subject: ClearSortOrder
    template: ClearSortOrder
    textMsg: ClearSortOrder
    updatedAt: ClearSortOrder
    when: ClearSortOrder
    whenFrom: ClearSortOrder
}

input ClearEmailTemplateOrderByWithRelationInput {
    automatic: ClearSortOrder
    createdAt: ClearSortOrder
    extraFilters: ClearSortOrder
    fromEmail: ClearSortOrder
    fromName: ClearSortOrder
    id: ClearSortOrder
    marketing: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    replyTo: ClearSortOrder
    sendAfterEvent: ClearSortOrder
    sendInWorkHours: ClearSortOrder
    sendLate: ClearSortOrder
    sendParent: ClearSortOrder
    sendText: ClearSortOrder
    sendTo: ClearSortOrder
    sentTo: ClearTicketOrderByRelationAggregateInput
    subject: ClearSortOrder
    template: ClearSortOrder
    textMsg: ClearSortOrder
    updatedAt: ClearSortOrder
    when: ClearSortOrder
    whenFrom: ClearSortOrder
}

input ClearEmailTemplateScalarWhereInput {
    AND: [ClearEmailTemplateScalarWhereInput!]
    NOT: [ClearEmailTemplateScalarWhereInput!]
    OR: [ClearEmailTemplateScalarWhereInput!]
    automatic: ClearBoolFilter
    createdAt: ClearDateTimeFilter
    extraFilters: ClearJsonNullableFilter
    fromEmail: ClearStringFilter
    fromName: ClearStringFilter
    id: ClearStringFilter
    marketing: ClearBoolFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    replyTo: ClearStringFilter
    sendAfterEvent: ClearBoolFilter
    sendInWorkHours: ClearBoolFilter
    sendLate: ClearBoolFilter
    sendParent: ClearBoolFilter
    sendText: ClearBoolFilter
    sendTo: ClearEnumTicketTypeFilter
    subject: ClearStringFilter
    template: ClearStringFilter
    textMsg: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
    when: ClearStringFilter
    whenFrom: ClearEnumEmailWhenFromFilter
}

input ClearEmailTemplateScalarWhereWithAggregatesInput {
    AND: [ClearEmailTemplateScalarWhereWithAggregatesInput!]
    NOT: [ClearEmailTemplateScalarWhereWithAggregatesInput!]
    OR: [ClearEmailTemplateScalarWhereWithAggregatesInput!]
    automatic: ClearBoolWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    extraFilters: ClearJsonNullableWithAggregatesFilter
    fromEmail: ClearStringWithAggregatesFilter
    fromName: ClearStringWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    marketing: ClearBoolWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringWithAggregatesFilter
    replyTo: ClearStringWithAggregatesFilter
    sendAfterEvent: ClearBoolWithAggregatesFilter
    sendInWorkHours: ClearBoolWithAggregatesFilter
    sendLate: ClearBoolWithAggregatesFilter
    sendParent: ClearBoolWithAggregatesFilter
    sendText: ClearBoolWithAggregatesFilter
    sendTo: ClearEnumTicketTypeWithAggregatesFilter
    subject: ClearStringWithAggregatesFilter
    template: ClearStringWithAggregatesFilter
    textMsg: ClearStringNullableWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
    when: ClearStringWithAggregatesFilter
    whenFrom: ClearEnumEmailWhenFromWithAggregatesFilter
}

input ClearEmailTemplateUpdateInput {
    automatic: ClearBoolFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    extraFilters: ClearJSON
    fromEmail: ClearStringFieldUpdateOperationsInput
    fromName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    marketing: ClearBoolFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    replyTo: ClearStringFieldUpdateOperationsInput
    sendAfterEvent: ClearBoolFieldUpdateOperationsInput
    sendInWorkHours: ClearBoolFieldUpdateOperationsInput
    sendLate: ClearBoolFieldUpdateOperationsInput
    sendParent: ClearBoolFieldUpdateOperationsInput
    sendText: ClearBoolFieldUpdateOperationsInput
    sendTo: ClearEnumTicketTypeFieldUpdateOperationsInput
    sentTo: ClearTicketUpdateManyWithoutSentEmailsInput
    subject: ClearStringFieldUpdateOperationsInput
    template: ClearStringFieldUpdateOperationsInput
    textMsg: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    when: ClearStringFieldUpdateOperationsInput
    whenFrom: ClearEnumEmailWhenFromFieldUpdateOperationsInput
}

input ClearEmailTemplateUpdateManyMutationInput {
    automatic: ClearBoolFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    extraFilters: ClearJSON
    fromEmail: ClearStringFieldUpdateOperationsInput
    fromName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    marketing: ClearBoolFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    replyTo: ClearStringFieldUpdateOperationsInput
    sendAfterEvent: ClearBoolFieldUpdateOperationsInput
    sendInWorkHours: ClearBoolFieldUpdateOperationsInput
    sendLate: ClearBoolFieldUpdateOperationsInput
    sendParent: ClearBoolFieldUpdateOperationsInput
    sendText: ClearBoolFieldUpdateOperationsInput
    sendTo: ClearEnumTicketTypeFieldUpdateOperationsInput
    subject: ClearStringFieldUpdateOperationsInput
    template: ClearStringFieldUpdateOperationsInput
    textMsg: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    when: ClearStringFieldUpdateOperationsInput
    whenFrom: ClearEnumEmailWhenFromFieldUpdateOperationsInput
}

input ClearEmailTemplateUpdateManyWithWhereWithoutSentToInput {
    data: ClearEmailTemplateUpdateManyMutationInput!
    where: ClearEmailTemplateScalarWhereInput!
}

input ClearEmailTemplateUpdateManyWithoutSentToInput {
    connect: [ClearEmailTemplateWhereUniqueInput!]
    connectOrCreate: [ClearEmailTemplateCreateOrConnectWithoutSentToInput!]
    create: [ClearEmailTemplateCreateWithoutSentToInput!]
    delete: [ClearEmailTemplateWhereUniqueInput!]
    deleteMany: [ClearEmailTemplateScalarWhereInput!]
    disconnect: [ClearEmailTemplateWhereUniqueInput!]
    set: [ClearEmailTemplateWhereUniqueInput!]
    update: [ClearEmailTemplateUpdateWithWhereUniqueWithoutSentToInput!]
    updateMany: [ClearEmailTemplateUpdateManyWithWhereWithoutSentToInput!]
    upsert: [ClearEmailTemplateUpsertWithWhereUniqueWithoutSentToInput!]
}

input ClearEmailTemplateUpdateWithWhereUniqueWithoutSentToInput {
    data: ClearEmailTemplateUpdateWithoutSentToInput!
    where: ClearEmailTemplateWhereUniqueInput!
}

input ClearEmailTemplateUpdateWithoutSentToInput {
    automatic: ClearBoolFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    extraFilters: ClearJSON
    fromEmail: ClearStringFieldUpdateOperationsInput
    fromName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    marketing: ClearBoolFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    replyTo: ClearStringFieldUpdateOperationsInput
    sendAfterEvent: ClearBoolFieldUpdateOperationsInput
    sendInWorkHours: ClearBoolFieldUpdateOperationsInput
    sendLate: ClearBoolFieldUpdateOperationsInput
    sendParent: ClearBoolFieldUpdateOperationsInput
    sendText: ClearBoolFieldUpdateOperationsInput
    sendTo: ClearEnumTicketTypeFieldUpdateOperationsInput
    subject: ClearStringFieldUpdateOperationsInput
    template: ClearStringFieldUpdateOperationsInput
    textMsg: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    when: ClearStringFieldUpdateOperationsInput
    whenFrom: ClearEnumEmailWhenFromFieldUpdateOperationsInput
}

input ClearEmailTemplateUpsertWithWhereUniqueWithoutSentToInput {
    create: ClearEmailTemplateCreateWithoutSentToInput!
    update: ClearEmailTemplateUpdateWithoutSentToInput!
    where: ClearEmailTemplateWhereUniqueInput!
}

input ClearEmailTemplateWhereInput {
    AND: [ClearEmailTemplateWhereInput!]
    NOT: [ClearEmailTemplateWhereInput!]
    OR: [ClearEmailTemplateWhereInput!]
    automatic: ClearBoolFilter
    createdAt: ClearDateTimeFilter
    extraFilters: ClearJsonNullableFilter
    fromEmail: ClearStringFilter
    fromName: ClearStringFilter
    id: ClearStringFilter
    marketing: ClearBoolFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    replyTo: ClearStringFilter
    sendAfterEvent: ClearBoolFilter
    sendInWorkHours: ClearBoolFilter
    sendLate: ClearBoolFilter
    sendParent: ClearBoolFilter
    sendText: ClearBoolFilter
    sendTo: ClearEnumTicketTypeFilter
    sentTo: ClearTicketListRelationFilter
    subject: ClearStringFilter
    template: ClearStringFilter
    textMsg: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
    when: ClearStringFilter
    whenFrom: ClearEnumEmailWhenFromFilter
}

input ClearEmailTemplateWhereUniqueInput {
    id: String
}

input ClearEnumDiscountTypeFieldUpdateOperationsInput {
    set: ClearDiscountType
}

input ClearEnumDiscountTypeFilter {
    equals: ClearDiscountType
    in: [ClearDiscountType!]
    not: ClearNestedEnumDiscountTypeFilter
    notIn: [ClearDiscountType!]
}

input ClearEnumDiscountTypeWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedEnumDiscountTypeFilter
    _min: ClearNestedEnumDiscountTypeFilter
    equals: ClearDiscountType
    in: [ClearDiscountType!]
    not: ClearNestedEnumDiscountTypeWithAggregatesFilter
    notIn: [ClearDiscountType!]
}

input ClearEnumEmailWhenFromFieldUpdateOperationsInput {
    set: ClearEmailWhenFrom
}

input ClearEnumEmailWhenFromFilter {
    equals: ClearEmailWhenFrom
    in: [ClearEmailWhenFrom!]
    not: ClearNestedEnumEmailWhenFromFilter
    notIn: [ClearEmailWhenFrom!]
}

input ClearEnumEmailWhenFromWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedEnumEmailWhenFromFilter
    _min: ClearNestedEnumEmailWhenFromFilter
    equals: ClearEmailWhenFrom
    in: [ClearEmailWhenFrom!]
    not: ClearNestedEnumEmailWhenFromWithAggregatesFilter
    notIn: [ClearEmailWhenFrom!]
}

input ClearEnumTicketTypeFieldUpdateOperationsInput {
    set: ClearTicketType
}

input ClearEnumTicketTypeFilter {
    equals: ClearTicketType
    in: [ClearTicketType!]
    not: ClearNestedEnumTicketTypeFilter
    notIn: [ClearTicketType!]
}

input ClearEnumTicketTypeWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedEnumTicketTypeFilter
    _min: ClearNestedEnumTicketTypeFilter
    equals: ClearTicketType
    in: [ClearTicketType!]
    not: ClearNestedEnumTicketTypeWithAggregatesFilter
    notIn: [ClearTicketType!]
}

input ClearEventAvgOrderByAggregateInput {
    earlyBirdPrice: ClearSortOrder
    majorityAge: ClearSortOrder
    ticketPrice: ClearSortOrder
}

input ClearEventCountOrderByAggregateInput {
    contentfulWebname: ClearSortOrder
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    eventGroupId: ClearSortOrder
    id: ClearSortOrder
    majorityAge: ClearSortOrder
    managers: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    registrationsOpen: ClearSortOrder
    showcaseId: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    timezone: ClearSortOrder
    updatedAt: ClearSortOrder
    venueId: ClearSortOrder
}

input ClearEventCreateInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    eventRestrictions: ClearEventRestrictionCreateNestedManyWithoutEventsInput
    id: String
    interestedEmails: ClearMailingListMemberCreateNestedManyWithoutInterestedInEventsInput
    majorityAge: Int
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    promoCodes: ClearPromoCodeCreateNestedManyWithoutEventInput
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    showcaseId: String
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    timezone: String
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateManyEventGroupInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    id: String
    majorityAge: Int
    managers: ClearEventCreateManymanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    timezone: String
    updatedAt: ClearDateTime
    venueId: String
}

input ClearEventCreateManyEventGroupInputEnvelope {
    data: [ClearEventCreateManyEventGroupInput!]!
    skipDuplicates: Boolean
}

input ClearEventCreateManyInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroupId: String!
    id: String
    majorityAge: Int
    managers: ClearEventCreateManymanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    timezone: String
    updatedAt: ClearDateTime
    venueId: String
}

input ClearEventCreateManyVenueInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroupId: String!
    id: String
    majorityAge: Int
    managers: ClearEventCreateManymanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    timezone: String
    updatedAt: ClearDateTime
}

input ClearEventCreateManyVenueInputEnvelope {
    data: [ClearEventCreateManyVenueInput!]!
    skipDuplicates: Boolean
}

input ClearEventCreateManymanagersInput {
    set: [String!]!
}

input ClearEventCreateNestedManyWithoutEventGroupInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutEventGroupInput!]
    create: [ClearEventCreateWithoutEventGroupInput!]
    createMany: ClearEventCreateManyEventGroupInputEnvelope
}

input ClearEventCreateNestedManyWithoutEventRestrictionsInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutEventRestrictionsInput!]
    create: [ClearEventCreateWithoutEventRestrictionsInput!]
}

input ClearEventCreateNestedManyWithoutInterestedEmailsInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutInterestedEmailsInput!]
    create: [ClearEventCreateWithoutInterestedEmailsInput!]
}

input ClearEventCreateNestedManyWithoutVenueInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutVenueInput!]
    create: [ClearEventCreateWithoutVenueInput!]
    createMany: ClearEventCreateManyVenueInputEnvelope
}

input ClearEventCreateNestedOneWithoutPromoCodesInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutPromoCodesInput
    create: ClearEventCreateWithoutPromoCodesInput
}

input ClearEventCreateNestedOneWithoutScheduleInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutScheduleInput
    create: ClearEventCreateWithoutScheduleInput
}

input ClearEventCreateNestedOneWithoutSponsorsInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutSponsorsInput
    create: ClearEventCreateWithoutSponsorsInput
}

input ClearEventCreateNestedOneWithoutTicketsInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutTicketsInput
    create: ClearEventCreateWithoutTicketsInput
}

input ClearEventCreateOrConnectWithoutEventGroupInput {
    create: ClearEventCreateWithoutEventGroupInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateOrConnectWithoutEventRestrictionsInput {
    create: ClearEventCreateWithoutEventRestrictionsInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateOrConnectWithoutInterestedEmailsInput {
    create: ClearEventCreateWithoutInterestedEmailsInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateOrConnectWithoutPromoCodesInput {
    create: ClearEventCreateWithoutPromoCodesInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateOrConnectWithoutScheduleInput {
    create: ClearEventCreateWithoutScheduleInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateOrConnectWithoutSponsorsInput {
    create: ClearEventCreateWithoutSponsorsInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateOrConnectWithoutTicketsInput {
    create: ClearEventCreateWithoutTicketsInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateOrConnectWithoutVenueInput {
    create: ClearEventCreateWithoutVenueInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateWithoutEventGroupInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventRestrictions: ClearEventRestrictionCreateNestedManyWithoutEventsInput
    id: String
    interestedEmails: ClearMailingListMemberCreateNestedManyWithoutInterestedInEventsInput
    majorityAge: Int
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    promoCodes: ClearPromoCodeCreateNestedManyWithoutEventInput
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    showcaseId: String
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    timezone: String
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateWithoutEventRestrictionsInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    id: String
    interestedEmails: ClearMailingListMemberCreateNestedManyWithoutInterestedInEventsInput
    majorityAge: Int
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    promoCodes: ClearPromoCodeCreateNestedManyWithoutEventInput
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    showcaseId: String
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    timezone: String
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateWithoutInterestedEmailsInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    eventRestrictions: ClearEventRestrictionCreateNestedManyWithoutEventsInput
    id: String
    majorityAge: Int
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    promoCodes: ClearPromoCodeCreateNestedManyWithoutEventInput
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    showcaseId: String
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    timezone: String
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateWithoutPromoCodesInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    eventRestrictions: ClearEventRestrictionCreateNestedManyWithoutEventsInput
    id: String
    interestedEmails: ClearMailingListMemberCreateNestedManyWithoutInterestedInEventsInput
    majorityAge: Int
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    showcaseId: String
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    timezone: String
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateWithoutScheduleInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    eventRestrictions: ClearEventRestrictionCreateNestedManyWithoutEventsInput
    id: String
    interestedEmails: ClearMailingListMemberCreateNestedManyWithoutInterestedInEventsInput
    majorityAge: Int
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    promoCodes: ClearPromoCodeCreateNestedManyWithoutEventInput
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    showcaseId: String
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    timezone: String
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateWithoutSponsorsInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    eventRestrictions: ClearEventRestrictionCreateNestedManyWithoutEventsInput
    id: String
    interestedEmails: ClearMailingListMemberCreateNestedManyWithoutInterestedInEventsInput
    majorityAge: Int
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    promoCodes: ClearPromoCodeCreateNestedManyWithoutEventInput
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    timezone: String
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateWithoutTicketsInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    eventRestrictions: ClearEventRestrictionCreateNestedManyWithoutEventsInput
    id: String
    interestedEmails: ClearMailingListMemberCreateNestedManyWithoutInterestedInEventsInput
    majorityAge: Int
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    promoCodes: ClearPromoCodeCreateNestedManyWithoutEventInput
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    showcaseId: String
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    timezone: String
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateWithoutVenueInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    eventRestrictions: ClearEventRestrictionCreateNestedManyWithoutEventsInput
    id: String
    interestedEmails: ClearMailingListMemberCreateNestedManyWithoutInterestedInEventsInput
    majorityAge: Int
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    promoCodes: ClearPromoCodeCreateNestedManyWithoutEventInput
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    showcaseId: String
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    timezone: String
    updatedAt: ClearDateTime
}

input ClearEventCreatemanagersInput {
    set: [String!]!
}

input ClearEventGroupAvgOrderByAggregateInput {
    earlyBirdPrice: ClearSortOrder
    ticketPrice: ClearSortOrder
}

input ClearEventGroupCountOrderByAggregateInput {
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    showcaseId: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventGroupCreateInput {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    events: ClearEventCreateNestedManyWithoutEventGroupInput
    id: String
    metadata: ClearJSON
    name: String!
    promoCodes: ClearPromoCodeCreateNestedManyWithoutEventGroupInput
    registrationCutoff: ClearDateTime!
    schedule: ClearScheduleItemCreateNestedManyWithoutEventGroupInput
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
}

input ClearEventGroupCreateManyInput {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    id: String
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
}

input ClearEventGroupCreateNestedOneWithoutEventsInput {
    connect: ClearEventGroupWhereUniqueInput
    connectOrCreate: ClearEventGroupCreateOrConnectWithoutEventsInput
    create: ClearEventGroupCreateWithoutEventsInput
}

input ClearEventGroupCreateNestedOneWithoutPromoCodesInput {
    connect: ClearEventGroupWhereUniqueInput
    connectOrCreate: ClearEventGroupCreateOrConnectWithoutPromoCodesInput
    create: ClearEventGroupCreateWithoutPromoCodesInput
}

input ClearEventGroupCreateNestedOneWithoutScheduleInput {
    connect: ClearEventGroupWhereUniqueInput
    connectOrCreate: ClearEventGroupCreateOrConnectWithoutScheduleInput
    create: ClearEventGroupCreateWithoutScheduleInput
}

input ClearEventGroupCreateOrConnectWithoutEventsInput {
    create: ClearEventGroupCreateWithoutEventsInput!
    where: ClearEventGroupWhereUniqueInput!
}

input ClearEventGroupCreateOrConnectWithoutPromoCodesInput {
    create: ClearEventGroupCreateWithoutPromoCodesInput!
    where: ClearEventGroupWhereUniqueInput!
}

input ClearEventGroupCreateOrConnectWithoutScheduleInput {
    create: ClearEventGroupCreateWithoutScheduleInput!
    where: ClearEventGroupWhereUniqueInput!
}

input ClearEventGroupCreateWithoutEventsInput {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    id: String
    metadata: ClearJSON
    name: String!
    promoCodes: ClearPromoCodeCreateNestedManyWithoutEventGroupInput
    registrationCutoff: ClearDateTime!
    schedule: ClearScheduleItemCreateNestedManyWithoutEventGroupInput
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
}

input ClearEventGroupCreateWithoutPromoCodesInput {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    events: ClearEventCreateNestedManyWithoutEventGroupInput
    id: String
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    schedule: ClearScheduleItemCreateNestedManyWithoutEventGroupInput
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
}

input ClearEventGroupCreateWithoutScheduleInput {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    events: ClearEventCreateNestedManyWithoutEventGroupInput
    id: String
    metadata: ClearJSON
    name: String!
    promoCodes: ClearPromoCodeCreateNestedManyWithoutEventGroupInput
    registrationCutoff: ClearDateTime!
    showcaseId: String
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
}

input ClearEventGroupMaxOrderByAggregateInput {
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    id: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    showcaseId: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventGroupMinOrderByAggregateInput {
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    id: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    showcaseId: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventGroupOrderByWithAggregationInput {
    _avg: ClearEventGroupAvgOrderByAggregateInput
    _count: ClearEventGroupCountOrderByAggregateInput
    _max: ClearEventGroupMaxOrderByAggregateInput
    _min: ClearEventGroupMinOrderByAggregateInput
    _sum: ClearEventGroupSumOrderByAggregateInput
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    showcaseId: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventGroupOrderByWithRelationInput {
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    events: ClearEventOrderByRelationAggregateInput
    id: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    promoCodes: ClearPromoCodeOrderByRelationAggregateInput
    registrationCutoff: ClearSortOrder
    schedule: ClearScheduleItemOrderByRelationAggregateInput
    showcaseId: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventGroupRelationFilter {
    is: ClearEventGroupWhereInput
    isNot: ClearEventGroupWhereInput
}

input ClearEventGroupScalarWhereWithAggregatesInput {
    AND: [ClearEventGroupScalarWhereWithAggregatesInput!]
    NOT: [ClearEventGroupScalarWhereWithAggregatesInput!]
    OR: [ClearEventGroupScalarWhereWithAggregatesInput!]
    createdAt: ClearDateTimeWithAggregatesFilter
    earlyBirdCutoff: ClearDateTimeWithAggregatesFilter
    earlyBirdPrice: ClearFloatWithAggregatesFilter
    endDate: ClearDateTimeWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringWithAggregatesFilter
    registrationCutoff: ClearDateTimeWithAggregatesFilter
    showcaseId: ClearStringNullableWithAggregatesFilter
    startDate: ClearDateTimeWithAggregatesFilter
    ticketPrice: ClearFloatWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearEventGroupSumOrderByAggregateInput {
    earlyBirdPrice: ClearSortOrder
    ticketPrice: ClearSortOrder
}

input ClearEventGroupUpdateInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    events: ClearEventUpdateManyWithoutEventGroupInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    promoCodes: ClearPromoCodeUpdateManyWithoutEventGroupInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventGroupInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventGroupUpdateManyMutationInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventGroupUpdateOneRequiredWithoutEventsInput {
    connect: ClearEventGroupWhereUniqueInput
    connectOrCreate: ClearEventGroupCreateOrConnectWithoutEventsInput
    create: ClearEventGroupCreateWithoutEventsInput
    update: ClearEventGroupUpdateWithoutEventsInput
    upsert: ClearEventGroupUpsertWithoutEventsInput
}

input ClearEventGroupUpdateOneWithoutPromoCodesInput {
    connect: ClearEventGroupWhereUniqueInput
    connectOrCreate: ClearEventGroupCreateOrConnectWithoutPromoCodesInput
    create: ClearEventGroupCreateWithoutPromoCodesInput
    delete: Boolean
    disconnect: Boolean
    update: ClearEventGroupUpdateWithoutPromoCodesInput
    upsert: ClearEventGroupUpsertWithoutPromoCodesInput
}

input ClearEventGroupUpdateOneWithoutScheduleInput {
    connect: ClearEventGroupWhereUniqueInput
    connectOrCreate: ClearEventGroupCreateOrConnectWithoutScheduleInput
    create: ClearEventGroupCreateWithoutScheduleInput
    delete: Boolean
    disconnect: Boolean
    update: ClearEventGroupUpdateWithoutScheduleInput
    upsert: ClearEventGroupUpsertWithoutScheduleInput
}

input ClearEventGroupUpdateWithoutEventsInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    promoCodes: ClearPromoCodeUpdateManyWithoutEventGroupInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventGroupInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventGroupUpdateWithoutPromoCodesInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    events: ClearEventUpdateManyWithoutEventGroupInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventGroupInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventGroupUpdateWithoutScheduleInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    events: ClearEventUpdateManyWithoutEventGroupInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    promoCodes: ClearPromoCodeUpdateManyWithoutEventGroupInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventGroupUpsertWithoutEventsInput {
    create: ClearEventGroupCreateWithoutEventsInput!
    update: ClearEventGroupUpdateWithoutEventsInput!
}

input ClearEventGroupUpsertWithoutPromoCodesInput {
    create: ClearEventGroupCreateWithoutPromoCodesInput!
    update: ClearEventGroupUpdateWithoutPromoCodesInput!
}

input ClearEventGroupUpsertWithoutScheduleInput {
    create: ClearEventGroupCreateWithoutScheduleInput!
    update: ClearEventGroupUpdateWithoutScheduleInput!
}

input ClearEventGroupWhereInput {
    AND: [ClearEventGroupWhereInput!]
    NOT: [ClearEventGroupWhereInput!]
    OR: [ClearEventGroupWhereInput!]
    createdAt: ClearDateTimeFilter
    earlyBirdCutoff: ClearDateTimeFilter
    earlyBirdPrice: ClearFloatFilter
    endDate: ClearDateTimeFilter
    events: ClearEventListRelationFilter
    id: ClearStringFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    promoCodes: ClearPromoCodeListRelationFilter
    registrationCutoff: ClearDateTimeFilter
    schedule: ClearScheduleItemListRelationFilter
    showcaseId: ClearStringNullableFilter
    startDate: ClearDateTimeFilter
    ticketPrice: ClearFloatFilter
    updatedAt: ClearDateTimeFilter
}

input ClearEventGroupWhereUniqueInput {
    id: String
}

input ClearEventListRelationFilter {
    every: ClearEventWhereInput
    none: ClearEventWhereInput
    some: ClearEventWhereInput
}

input ClearEventMaxOrderByAggregateInput {
    contentfulWebname: ClearSortOrder
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    eventGroupId: ClearSortOrder
    id: ClearSortOrder
    majorityAge: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    registrationsOpen: ClearSortOrder
    showcaseId: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    timezone: ClearSortOrder
    updatedAt: ClearSortOrder
    venueId: ClearSortOrder
}

input ClearEventMinOrderByAggregateInput {
    contentfulWebname: ClearSortOrder
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    eventGroupId: ClearSortOrder
    id: ClearSortOrder
    majorityAge: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    registrationsOpen: ClearSortOrder
    showcaseId: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    timezone: ClearSortOrder
    updatedAt: ClearSortOrder
    venueId: ClearSortOrder
}

input ClearEventOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearEventOrderByWithAggregationInput {
    _avg: ClearEventAvgOrderByAggregateInput
    _count: ClearEventCountOrderByAggregateInput
    _max: ClearEventMaxOrderByAggregateInput
    _min: ClearEventMinOrderByAggregateInput
    _sum: ClearEventSumOrderByAggregateInput
    contentfulWebname: ClearSortOrder
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    eventGroupId: ClearSortOrder
    id: ClearSortOrder
    majorityAge: ClearSortOrder
    managers: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    registrationsOpen: ClearSortOrder
    showcaseId: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    timezone: ClearSortOrder
    updatedAt: ClearSortOrder
    venueId: ClearSortOrder
}

input ClearEventOrderByWithRelationInput {
    contentfulWebname: ClearSortOrder
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    eventGroup: ClearEventGroupOrderByWithRelationInput
    eventGroupId: ClearSortOrder
    eventRestrictions: ClearEventRestrictionOrderByRelationAggregateInput
    id: ClearSortOrder
    interestedEmails: ClearMailingListMemberOrderByRelationAggregateInput
    majorityAge: ClearSortOrder
    managers: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    promoCodes: ClearPromoCodeOrderByRelationAggregateInput
    registrationCutoff: ClearSortOrder
    registrationsOpen: ClearSortOrder
    schedule: ClearScheduleItemOrderByRelationAggregateInput
    showcaseId: ClearSortOrder
    sponsors: ClearSponsorOrderByRelationAggregateInput
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    tickets: ClearTicketOrderByRelationAggregateInput
    timezone: ClearSortOrder
    updatedAt: ClearSortOrder
    venue: ClearVenueOrderByWithRelationInput
    venueId: ClearSortOrder
}

input ClearEventRelationFilter {
    is: ClearEventWhereInput
    isNot: ClearEventWhereInput
}

input ClearEventRestrictionCountOrderByAggregateInput {
    createdAt: ClearSortOrder
    details: ClearSortOrder
    iconUri: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    title: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventRestrictionCreateInput {
    Events: ClearEventCreateNestedManyWithoutEventRestrictionsInput
    createdAt: ClearDateTime
    details: String
    iconUri: String
    id: String
    metadata: ClearJSON
    name: String!
    title: String!
    updatedAt: ClearDateTime
}

input ClearEventRestrictionCreateManyInput {
    createdAt: ClearDateTime
    details: String
    iconUri: String
    id: String
    metadata: ClearJSON
    name: String!
    title: String!
    updatedAt: ClearDateTime
}

input ClearEventRestrictionCreateNestedManyWithoutEventsInput {
    connect: [ClearEventRestrictionWhereUniqueInput!]
    connectOrCreate: [ClearEventRestrictionCreateOrConnectWithoutEventsInput!]
    create: [ClearEventRestrictionCreateWithoutEventsInput!]
}

input ClearEventRestrictionCreateOrConnectWithoutEventsInput {
    create: ClearEventRestrictionCreateWithoutEventsInput!
    where: ClearEventRestrictionWhereUniqueInput!
}

input ClearEventRestrictionCreateWithoutEventsInput {
    createdAt: ClearDateTime
    details: String
    iconUri: String
    id: String
    metadata: ClearJSON
    name: String!
    title: String!
    updatedAt: ClearDateTime
}

input ClearEventRestrictionListRelationFilter {
    every: ClearEventRestrictionWhereInput
    none: ClearEventRestrictionWhereInput
    some: ClearEventRestrictionWhereInput
}

input ClearEventRestrictionMaxOrderByAggregateInput {
    createdAt: ClearSortOrder
    details: ClearSortOrder
    iconUri: ClearSortOrder
    id: ClearSortOrder
    name: ClearSortOrder
    title: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventRestrictionMinOrderByAggregateInput {
    createdAt: ClearSortOrder
    details: ClearSortOrder
    iconUri: ClearSortOrder
    id: ClearSortOrder
    name: ClearSortOrder
    title: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventRestrictionOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearEventRestrictionOrderByWithAggregationInput {
    _count: ClearEventRestrictionCountOrderByAggregateInput
    _max: ClearEventRestrictionMaxOrderByAggregateInput
    _min: ClearEventRestrictionMinOrderByAggregateInput
    createdAt: ClearSortOrder
    details: ClearSortOrder
    iconUri: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    title: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventRestrictionOrderByWithRelationInput {
    Events: ClearEventOrderByRelationAggregateInput
    createdAt: ClearSortOrder
    details: ClearSortOrder
    iconUri: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    title: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventRestrictionScalarWhereInput {
    AND: [ClearEventRestrictionScalarWhereInput!]
    NOT: [ClearEventRestrictionScalarWhereInput!]
    OR: [ClearEventRestrictionScalarWhereInput!]
    createdAt: ClearDateTimeFilter
    details: ClearStringNullableFilter
    iconUri: ClearStringNullableFilter
    id: ClearStringFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    title: ClearStringFilter
    updatedAt: ClearDateTimeFilter
}

input ClearEventRestrictionScalarWhereWithAggregatesInput {
    AND: [ClearEventRestrictionScalarWhereWithAggregatesInput!]
    NOT: [ClearEventRestrictionScalarWhereWithAggregatesInput!]
    OR: [ClearEventRestrictionScalarWhereWithAggregatesInput!]
    createdAt: ClearDateTimeWithAggregatesFilter
    details: ClearStringNullableWithAggregatesFilter
    iconUri: ClearStringNullableWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringWithAggregatesFilter
    title: ClearStringWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearEventRestrictionUpdateInput {
    Events: ClearEventUpdateManyWithoutEventRestrictionsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    details: ClearNullableStringFieldUpdateOperationsInput
    iconUri: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    title: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventRestrictionUpdateManyMutationInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    details: ClearNullableStringFieldUpdateOperationsInput
    iconUri: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    title: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventRestrictionUpdateManyWithWhereWithoutEventsInput {
    data: ClearEventRestrictionUpdateManyMutationInput!
    where: ClearEventRestrictionScalarWhereInput!
}

input ClearEventRestrictionUpdateManyWithoutEventsInput {
    connect: [ClearEventRestrictionWhereUniqueInput!]
    connectOrCreate: [ClearEventRestrictionCreateOrConnectWithoutEventsInput!]
    create: [ClearEventRestrictionCreateWithoutEventsInput!]
    delete: [ClearEventRestrictionWhereUniqueInput!]
    deleteMany: [ClearEventRestrictionScalarWhereInput!]
    disconnect: [ClearEventRestrictionWhereUniqueInput!]
    set: [ClearEventRestrictionWhereUniqueInput!]
    update: [ClearEventRestrictionUpdateWithWhereUniqueWithoutEventsInput!]
    updateMany: [ClearEventRestrictionUpdateManyWithWhereWithoutEventsInput!]
    upsert: [ClearEventRestrictionUpsertWithWhereUniqueWithoutEventsInput!]
}

input ClearEventRestrictionUpdateWithWhereUniqueWithoutEventsInput {
    data: ClearEventRestrictionUpdateWithoutEventsInput!
    where: ClearEventRestrictionWhereUniqueInput!
}

input ClearEventRestrictionUpdateWithoutEventsInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    details: ClearNullableStringFieldUpdateOperationsInput
    iconUri: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    title: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventRestrictionUpsertWithWhereUniqueWithoutEventsInput {
    create: ClearEventRestrictionCreateWithoutEventsInput!
    update: ClearEventRestrictionUpdateWithoutEventsInput!
    where: ClearEventRestrictionWhereUniqueInput!
}

input ClearEventRestrictionWhereInput {
    AND: [ClearEventRestrictionWhereInput!]
    Events: ClearEventListRelationFilter
    NOT: [ClearEventRestrictionWhereInput!]
    OR: [ClearEventRestrictionWhereInput!]
    createdAt: ClearDateTimeFilter
    details: ClearStringNullableFilter
    iconUri: ClearStringNullableFilter
    id: ClearStringFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    title: ClearStringFilter
    updatedAt: ClearDateTimeFilter
}

input ClearEventRestrictionWhereUniqueInput {
    id: String
}

input ClearEventScalarWhereInput {
    AND: [ClearEventScalarWhereInput!]
    NOT: [ClearEventScalarWhereInput!]
    OR: [ClearEventScalarWhereInput!]
    contentfulWebname: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    earlyBirdCutoff: ClearDateTimeFilter
    earlyBirdPrice: ClearFloatFilter
    endDate: ClearDateTimeFilter
    eventGroupId: ClearStringFilter
    id: ClearStringFilter
    majorityAge: ClearIntFilter
    managers: ClearStringNullableListFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    registrationCutoff: ClearDateTimeFilter
    registrationsOpen: ClearBoolFilter
    showcaseId: ClearStringNullableFilter
    startDate: ClearDateTimeFilter
    ticketPrice: ClearFloatFilter
    timezone: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
    venueId: ClearStringNullableFilter
}

input ClearEventScalarWhereWithAggregatesInput {
    AND: [ClearEventScalarWhereWithAggregatesInput!]
    NOT: [ClearEventScalarWhereWithAggregatesInput!]
    OR: [ClearEventScalarWhereWithAggregatesInput!]
    contentfulWebname: ClearStringNullableWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    earlyBirdCutoff: ClearDateTimeWithAggregatesFilter
    earlyBirdPrice: ClearFloatWithAggregatesFilter
    endDate: ClearDateTimeWithAggregatesFilter
    eventGroupId: ClearStringWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    majorityAge: ClearIntWithAggregatesFilter
    managers: ClearStringNullableListFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringWithAggregatesFilter
    registrationCutoff: ClearDateTimeWithAggregatesFilter
    registrationsOpen: ClearBoolWithAggregatesFilter
    showcaseId: ClearStringNullableWithAggregatesFilter
    startDate: ClearDateTimeWithAggregatesFilter
    ticketPrice: ClearFloatWithAggregatesFilter
    timezone: ClearStringNullableWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
    venueId: ClearStringNullableWithAggregatesFilter
}

input ClearEventSumOrderByAggregateInput {
    earlyBirdPrice: ClearSortOrder
    majorityAge: ClearSortOrder
    ticketPrice: ClearSortOrder
}

input ClearEventUpdateInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    eventRestrictions: ClearEventRestrictionUpdateManyWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    interestedEmails: ClearMailingListMemberUpdateManyWithoutInterestedInEventsInput
    majorityAge: ClearIntFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    promoCodes: ClearPromoCodeUpdateManyWithoutEventInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    timezone: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateManyMutationInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    majorityAge: ClearIntFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    timezone: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventUpdateManyWithWhereWithoutEventGroupInput {
    data: ClearEventUpdateManyMutationInput!
    where: ClearEventScalarWhereInput!
}

input ClearEventUpdateManyWithWhereWithoutEventRestrictionsInput {
    data: ClearEventUpdateManyMutationInput!
    where: ClearEventScalarWhereInput!
}

input ClearEventUpdateManyWithWhereWithoutInterestedEmailsInput {
    data: ClearEventUpdateManyMutationInput!
    where: ClearEventScalarWhereInput!
}

input ClearEventUpdateManyWithWhereWithoutVenueInput {
    data: ClearEventUpdateManyMutationInput!
    where: ClearEventScalarWhereInput!
}

input ClearEventUpdateManyWithoutEventGroupInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutEventGroupInput!]
    create: [ClearEventCreateWithoutEventGroupInput!]
    createMany: ClearEventCreateManyEventGroupInputEnvelope
    delete: [ClearEventWhereUniqueInput!]
    deleteMany: [ClearEventScalarWhereInput!]
    disconnect: [ClearEventWhereUniqueInput!]
    set: [ClearEventWhereUniqueInput!]
    update: [ClearEventUpdateWithWhereUniqueWithoutEventGroupInput!]
    updateMany: [ClearEventUpdateManyWithWhereWithoutEventGroupInput!]
    upsert: [ClearEventUpsertWithWhereUniqueWithoutEventGroupInput!]
}

input ClearEventUpdateManyWithoutEventRestrictionsInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutEventRestrictionsInput!]
    create: [ClearEventCreateWithoutEventRestrictionsInput!]
    delete: [ClearEventWhereUniqueInput!]
    deleteMany: [ClearEventScalarWhereInput!]
    disconnect: [ClearEventWhereUniqueInput!]
    set: [ClearEventWhereUniqueInput!]
    update: [ClearEventUpdateWithWhereUniqueWithoutEventRestrictionsInput!]
    updateMany: [ClearEventUpdateManyWithWhereWithoutEventRestrictionsInput!]
    upsert: [ClearEventUpsertWithWhereUniqueWithoutEventRestrictionsInput!]
}

input ClearEventUpdateManyWithoutInterestedEmailsInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutInterestedEmailsInput!]
    create: [ClearEventCreateWithoutInterestedEmailsInput!]
    delete: [ClearEventWhereUniqueInput!]
    deleteMany: [ClearEventScalarWhereInput!]
    disconnect: [ClearEventWhereUniqueInput!]
    set: [ClearEventWhereUniqueInput!]
    update: [ClearEventUpdateWithWhereUniqueWithoutInterestedEmailsInput!]
    updateMany: [ClearEventUpdateManyWithWhereWithoutInterestedEmailsInput!]
    upsert: [ClearEventUpsertWithWhereUniqueWithoutInterestedEmailsInput!]
}

input ClearEventUpdateManyWithoutVenueInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutVenueInput!]
    create: [ClearEventCreateWithoutVenueInput!]
    createMany: ClearEventCreateManyVenueInputEnvelope
    delete: [ClearEventWhereUniqueInput!]
    deleteMany: [ClearEventScalarWhereInput!]
    disconnect: [ClearEventWhereUniqueInput!]
    set: [ClearEventWhereUniqueInput!]
    update: [ClearEventUpdateWithWhereUniqueWithoutVenueInput!]
    updateMany: [ClearEventUpdateManyWithWhereWithoutVenueInput!]
    upsert: [ClearEventUpsertWithWhereUniqueWithoutVenueInput!]
}

input ClearEventUpdateOneRequiredWithoutTicketsInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutTicketsInput
    create: ClearEventCreateWithoutTicketsInput
    update: ClearEventUpdateWithoutTicketsInput
    upsert: ClearEventUpsertWithoutTicketsInput
}

input ClearEventUpdateOneWithoutPromoCodesInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutPromoCodesInput
    create: ClearEventCreateWithoutPromoCodesInput
    delete: Boolean
    disconnect: Boolean
    update: ClearEventUpdateWithoutPromoCodesInput
    upsert: ClearEventUpsertWithoutPromoCodesInput
}

input ClearEventUpdateOneWithoutScheduleInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutScheduleInput
    create: ClearEventCreateWithoutScheduleInput
    delete: Boolean
    disconnect: Boolean
    update: ClearEventUpdateWithoutScheduleInput
    upsert: ClearEventUpsertWithoutScheduleInput
}

input ClearEventUpdateOneWithoutSponsorsInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutSponsorsInput
    create: ClearEventCreateWithoutSponsorsInput
    delete: Boolean
    disconnect: Boolean
    update: ClearEventUpdateWithoutSponsorsInput
    upsert: ClearEventUpsertWithoutSponsorsInput
}

input ClearEventUpdateWithWhereUniqueWithoutEventGroupInput {
    data: ClearEventUpdateWithoutEventGroupInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpdateWithWhereUniqueWithoutEventRestrictionsInput {
    data: ClearEventUpdateWithoutEventRestrictionsInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpdateWithWhereUniqueWithoutInterestedEmailsInput {
    data: ClearEventUpdateWithoutInterestedEmailsInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpdateWithWhereUniqueWithoutVenueInput {
    data: ClearEventUpdateWithoutVenueInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpdateWithoutEventGroupInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventRestrictions: ClearEventRestrictionUpdateManyWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    interestedEmails: ClearMailingListMemberUpdateManyWithoutInterestedInEventsInput
    majorityAge: ClearIntFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    promoCodes: ClearPromoCodeUpdateManyWithoutEventInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    timezone: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateWithoutEventRestrictionsInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    interestedEmails: ClearMailingListMemberUpdateManyWithoutInterestedInEventsInput
    majorityAge: ClearIntFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    promoCodes: ClearPromoCodeUpdateManyWithoutEventInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    timezone: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateWithoutInterestedEmailsInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    eventRestrictions: ClearEventRestrictionUpdateManyWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    majorityAge: ClearIntFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    promoCodes: ClearPromoCodeUpdateManyWithoutEventInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    timezone: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateWithoutPromoCodesInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    eventRestrictions: ClearEventRestrictionUpdateManyWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    interestedEmails: ClearMailingListMemberUpdateManyWithoutInterestedInEventsInput
    majorityAge: ClearIntFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    timezone: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateWithoutScheduleInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    eventRestrictions: ClearEventRestrictionUpdateManyWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    interestedEmails: ClearMailingListMemberUpdateManyWithoutInterestedInEventsInput
    majorityAge: ClearIntFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    promoCodes: ClearPromoCodeUpdateManyWithoutEventInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    timezone: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateWithoutSponsorsInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    eventRestrictions: ClearEventRestrictionUpdateManyWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    interestedEmails: ClearMailingListMemberUpdateManyWithoutInterestedInEventsInput
    majorityAge: ClearIntFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    promoCodes: ClearPromoCodeUpdateManyWithoutEventInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    timezone: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateWithoutTicketsInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    eventRestrictions: ClearEventRestrictionUpdateManyWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    interestedEmails: ClearMailingListMemberUpdateManyWithoutInterestedInEventsInput
    majorityAge: ClearIntFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    promoCodes: ClearPromoCodeUpdateManyWithoutEventInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    timezone: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateWithoutVenueInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    eventRestrictions: ClearEventRestrictionUpdateManyWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    interestedEmails: ClearMailingListMemberUpdateManyWithoutInterestedInEventsInput
    majorityAge: ClearIntFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    promoCodes: ClearPromoCodeUpdateManyWithoutEventInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    showcaseId: ClearNullableStringFieldUpdateOperationsInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    timezone: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventUpdatemanagersInput {
    push: [String!]
    set: [String!]
}

input ClearEventUpsertWithWhereUniqueWithoutEventGroupInput {
    create: ClearEventCreateWithoutEventGroupInput!
    update: ClearEventUpdateWithoutEventGroupInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpsertWithWhereUniqueWithoutEventRestrictionsInput {
    create: ClearEventCreateWithoutEventRestrictionsInput!
    update: ClearEventUpdateWithoutEventRestrictionsInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpsertWithWhereUniqueWithoutInterestedEmailsInput {
    create: ClearEventCreateWithoutInterestedEmailsInput!
    update: ClearEventUpdateWithoutInterestedEmailsInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpsertWithWhereUniqueWithoutVenueInput {
    create: ClearEventCreateWithoutVenueInput!
    update: ClearEventUpdateWithoutVenueInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpsertWithoutPromoCodesInput {
    create: ClearEventCreateWithoutPromoCodesInput!
    update: ClearEventUpdateWithoutPromoCodesInput!
}

input ClearEventUpsertWithoutScheduleInput {
    create: ClearEventCreateWithoutScheduleInput!
    update: ClearEventUpdateWithoutScheduleInput!
}

input ClearEventUpsertWithoutSponsorsInput {
    create: ClearEventCreateWithoutSponsorsInput!
    update: ClearEventUpdateWithoutSponsorsInput!
}

input ClearEventUpsertWithoutTicketsInput {
    create: ClearEventCreateWithoutTicketsInput!
    update: ClearEventUpdateWithoutTicketsInput!
}

input ClearEventWhereInput {
    AND: [ClearEventWhereInput!]
    NOT: [ClearEventWhereInput!]
    OR: [ClearEventWhereInput!]
    contentfulWebname: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    earlyBirdCutoff: ClearDateTimeFilter
    earlyBirdPrice: ClearFloatFilter
    endDate: ClearDateTimeFilter
    eventGroup: ClearEventGroupRelationFilter
    eventGroupId: ClearStringFilter
    eventRestrictions: ClearEventRestrictionListRelationFilter
    id: ClearStringFilter
    interestedEmails: ClearMailingListMemberListRelationFilter
    majorityAge: ClearIntFilter
    managers: ClearStringNullableListFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    promoCodes: ClearPromoCodeListRelationFilter
    registrationCutoff: ClearDateTimeFilter
    registrationsOpen: ClearBoolFilter
    schedule: ClearScheduleItemListRelationFilter
    showcaseId: ClearStringNullableFilter
    sponsors: ClearSponsorListRelationFilter
    startDate: ClearDateTimeFilter
    ticketPrice: ClearFloatFilter
    tickets: ClearTicketListRelationFilter
    timezone: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
    venue: ClearVenueRelationFilter
    venueId: ClearStringNullableFilter
}

input ClearEventWhereUniqueInput {
    id: String
}

input ClearFloatFieldUpdateOperationsInput {
    decrement: Float
    divide: Float
    increment: Float
    multiply: Float
    set: Float
}

input ClearFloatFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: ClearNestedFloatFilter
    notIn: [Float!]
}

input ClearFloatWithAggregatesFilter {
    _avg: ClearNestedFloatFilter
    _count: ClearNestedIntFilter
    _max: ClearNestedFloatFilter
    _min: ClearNestedFloatFilter
    _sum: ClearNestedFloatFilter
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: ClearNestedFloatWithAggregatesFilter
    notIn: [Float!]
}

input ClearIntFieldUpdateOperationsInput {
    decrement: Int
    divide: Int
    increment: Int
    multiply: Int
    set: Int
}

input ClearIntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntFilter
    notIn: [Int!]
}

input ClearIntNullableFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntNullableFilter
    notIn: [Int!]
}

input ClearIntNullableWithAggregatesFilter {
    _avg: ClearNestedFloatNullableFilter
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedIntNullableFilter
    _min: ClearNestedIntNullableFilter
    _sum: ClearNestedIntNullableFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntNullableWithAggregatesFilter
    notIn: [Int!]
}

input ClearIntWithAggregatesFilter {
    _avg: ClearNestedFloatFilter
    _count: ClearNestedIntFilter
    _max: ClearNestedIntFilter
    _min: ClearNestedIntFilter
    _sum: ClearNestedIntFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntWithAggregatesFilter
    notIn: [Int!]
}

input ClearJsonNullableFilter {
    equals: ClearJSON
    not: ClearJSON
}

input ClearJsonNullableWithAggregatesFilter {
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedJsonNullableFilter
    _min: ClearNestedJsonNullableFilter
    equals: ClearJSON
    not: ClearJSON
}

input ClearMailingListMemberCountOrderByAggregateInput {
    createdAt: ClearSortOrder
    email: ClearSortOrder
    id: ClearSortOrder
    lastEmailed: ClearSortOrder
    metadata: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearMailingListMemberCreateInput {
    createdAt: ClearDateTime
    email: String!
    id: String
    interestedInEvents: ClearEventCreateNestedManyWithoutInterestedEmailsInput
    lastEmailed: ClearDateTime
    metadata: ClearJSON
    updatedAt: ClearDateTime
}

input ClearMailingListMemberCreateManyInput {
    createdAt: ClearDateTime
    email: String!
    id: String
    lastEmailed: ClearDateTime
    metadata: ClearJSON
    updatedAt: ClearDateTime
}

input ClearMailingListMemberCreateNestedManyWithoutInterestedInEventsInput {
    connect: [ClearMailingListMemberWhereUniqueInput!]
    connectOrCreate: [ClearMailingListMemberCreateOrConnectWithoutInterestedInEventsInput!]
    create: [ClearMailingListMemberCreateWithoutInterestedInEventsInput!]
}

input ClearMailingListMemberCreateOrConnectWithoutInterestedInEventsInput {
    create: ClearMailingListMemberCreateWithoutInterestedInEventsInput!
    where: ClearMailingListMemberWhereUniqueInput!
}

input ClearMailingListMemberCreateWithoutInterestedInEventsInput {
    createdAt: ClearDateTime
    email: String!
    id: String
    lastEmailed: ClearDateTime
    metadata: ClearJSON
    updatedAt: ClearDateTime
}

input ClearMailingListMemberListRelationFilter {
    every: ClearMailingListMemberWhereInput
    none: ClearMailingListMemberWhereInput
    some: ClearMailingListMemberWhereInput
}

input ClearMailingListMemberMaxOrderByAggregateInput {
    createdAt: ClearSortOrder
    email: ClearSortOrder
    id: ClearSortOrder
    lastEmailed: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearMailingListMemberMinOrderByAggregateInput {
    createdAt: ClearSortOrder
    email: ClearSortOrder
    id: ClearSortOrder
    lastEmailed: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearMailingListMemberOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearMailingListMemberOrderByWithAggregationInput {
    _count: ClearMailingListMemberCountOrderByAggregateInput
    _max: ClearMailingListMemberMaxOrderByAggregateInput
    _min: ClearMailingListMemberMinOrderByAggregateInput
    createdAt: ClearSortOrder
    email: ClearSortOrder
    id: ClearSortOrder
    lastEmailed: ClearSortOrder
    metadata: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearMailingListMemberOrderByWithRelationInput {
    createdAt: ClearSortOrder
    email: ClearSortOrder
    id: ClearSortOrder
    interestedInEvents: ClearEventOrderByRelationAggregateInput
    lastEmailed: ClearSortOrder
    metadata: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearMailingListMemberScalarWhereInput {
    AND: [ClearMailingListMemberScalarWhereInput!]
    NOT: [ClearMailingListMemberScalarWhereInput!]
    OR: [ClearMailingListMemberScalarWhereInput!]
    createdAt: ClearDateTimeFilter
    email: ClearStringFilter
    id: ClearStringFilter
    lastEmailed: ClearDateTimeNullableFilter
    metadata: ClearJsonNullableFilter
    updatedAt: ClearDateTimeFilter
}

input ClearMailingListMemberScalarWhereWithAggregatesInput {
    AND: [ClearMailingListMemberScalarWhereWithAggregatesInput!]
    NOT: [ClearMailingListMemberScalarWhereWithAggregatesInput!]
    OR: [ClearMailingListMemberScalarWhereWithAggregatesInput!]
    createdAt: ClearDateTimeWithAggregatesFilter
    email: ClearStringWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    lastEmailed: ClearDateTimeNullableWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearMailingListMemberUpdateInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    interestedInEvents: ClearEventUpdateManyWithoutInterestedEmailsInput
    lastEmailed: ClearNullableDateTimeFieldUpdateOperationsInput
    metadata: ClearJSON
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearMailingListMemberUpdateManyMutationInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastEmailed: ClearNullableDateTimeFieldUpdateOperationsInput
    metadata: ClearJSON
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearMailingListMemberUpdateManyWithWhereWithoutInterestedInEventsInput {
    data: ClearMailingListMemberUpdateManyMutationInput!
    where: ClearMailingListMemberScalarWhereInput!
}

input ClearMailingListMemberUpdateManyWithoutInterestedInEventsInput {
    connect: [ClearMailingListMemberWhereUniqueInput!]
    connectOrCreate: [ClearMailingListMemberCreateOrConnectWithoutInterestedInEventsInput!]
    create: [ClearMailingListMemberCreateWithoutInterestedInEventsInput!]
    delete: [ClearMailingListMemberWhereUniqueInput!]
    deleteMany: [ClearMailingListMemberScalarWhereInput!]
    disconnect: [ClearMailingListMemberWhereUniqueInput!]
    set: [ClearMailingListMemberWhereUniqueInput!]
    update: [ClearMailingListMemberUpdateWithWhereUniqueWithoutInterestedInEventsInput!]
    updateMany: [ClearMailingListMemberUpdateManyWithWhereWithoutInterestedInEventsInput!]
    upsert: [ClearMailingListMemberUpsertWithWhereUniqueWithoutInterestedInEventsInput!]
}

input ClearMailingListMemberUpdateWithWhereUniqueWithoutInterestedInEventsInput {
    data: ClearMailingListMemberUpdateWithoutInterestedInEventsInput!
    where: ClearMailingListMemberWhereUniqueInput!
}

input ClearMailingListMemberUpdateWithoutInterestedInEventsInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastEmailed: ClearNullableDateTimeFieldUpdateOperationsInput
    metadata: ClearJSON
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearMailingListMemberUpsertWithWhereUniqueWithoutInterestedInEventsInput {
    create: ClearMailingListMemberCreateWithoutInterestedInEventsInput!
    update: ClearMailingListMemberUpdateWithoutInterestedInEventsInput!
    where: ClearMailingListMemberWhereUniqueInput!
}

input ClearMailingListMemberWhereInput {
    AND: [ClearMailingListMemberWhereInput!]
    NOT: [ClearMailingListMemberWhereInput!]
    OR: [ClearMailingListMemberWhereInput!]
    createdAt: ClearDateTimeFilter
    email: ClearStringFilter
    id: ClearStringFilter
    interestedInEvents: ClearEventListRelationFilter
    lastEmailed: ClearDateTimeNullableFilter
    metadata: ClearJsonNullableFilter
    updatedAt: ClearDateTimeFilter
}

input ClearMailingListMemberWhereUniqueInput {
    email: String
    id: String
}

input ClearNestedBoolFilter {
    equals: Boolean
    not: ClearNestedBoolFilter
}

input ClearNestedBoolWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedBoolFilter
    _min: ClearNestedBoolFilter
    equals: Boolean
    not: ClearNestedBoolWithAggregatesFilter
}

input ClearNestedDateTimeFilter {
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeFilter
    notIn: [ClearDateTime!]
}

input ClearNestedDateTimeNullableFilter {
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeNullableFilter
    notIn: [ClearDateTime!]
}

input ClearNestedDateTimeNullableWithAggregatesFilter {
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedDateTimeNullableFilter
    _min: ClearNestedDateTimeNullableFilter
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeNullableWithAggregatesFilter
    notIn: [ClearDateTime!]
}

input ClearNestedDateTimeWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedDateTimeFilter
    _min: ClearNestedDateTimeFilter
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeWithAggregatesFilter
    notIn: [ClearDateTime!]
}

input ClearNestedEnumDiscountTypeFilter {
    equals: ClearDiscountType
    in: [ClearDiscountType!]
    not: ClearNestedEnumDiscountTypeFilter
    notIn: [ClearDiscountType!]
}

input ClearNestedEnumDiscountTypeWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedEnumDiscountTypeFilter
    _min: ClearNestedEnumDiscountTypeFilter
    equals: ClearDiscountType
    in: [ClearDiscountType!]
    not: ClearNestedEnumDiscountTypeWithAggregatesFilter
    notIn: [ClearDiscountType!]
}

input ClearNestedEnumEmailWhenFromFilter {
    equals: ClearEmailWhenFrom
    in: [ClearEmailWhenFrom!]
    not: ClearNestedEnumEmailWhenFromFilter
    notIn: [ClearEmailWhenFrom!]
}

input ClearNestedEnumEmailWhenFromWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedEnumEmailWhenFromFilter
    _min: ClearNestedEnumEmailWhenFromFilter
    equals: ClearEmailWhenFrom
    in: [ClearEmailWhenFrom!]
    not: ClearNestedEnumEmailWhenFromWithAggregatesFilter
    notIn: [ClearEmailWhenFrom!]
}

input ClearNestedEnumTicketTypeFilter {
    equals: ClearTicketType
    in: [ClearTicketType!]
    not: ClearNestedEnumTicketTypeFilter
    notIn: [ClearTicketType!]
}

input ClearNestedEnumTicketTypeWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedEnumTicketTypeFilter
    _min: ClearNestedEnumTicketTypeFilter
    equals: ClearTicketType
    in: [ClearTicketType!]
    not: ClearNestedEnumTicketTypeWithAggregatesFilter
    notIn: [ClearTicketType!]
}

input ClearNestedFloatFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: ClearNestedFloatFilter
    notIn: [Float!]
}

input ClearNestedFloatNullableFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: ClearNestedFloatNullableFilter
    notIn: [Float!]
}

input ClearNestedFloatWithAggregatesFilter {
    _avg: ClearNestedFloatFilter
    _count: ClearNestedIntFilter
    _max: ClearNestedFloatFilter
    _min: ClearNestedFloatFilter
    _sum: ClearNestedFloatFilter
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: ClearNestedFloatWithAggregatesFilter
    notIn: [Float!]
}

input ClearNestedIntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntFilter
    notIn: [Int!]
}

input ClearNestedIntNullableFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntNullableFilter
    notIn: [Int!]
}

input ClearNestedIntNullableWithAggregatesFilter {
    _avg: ClearNestedFloatNullableFilter
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedIntNullableFilter
    _min: ClearNestedIntNullableFilter
    _sum: ClearNestedIntNullableFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntNullableWithAggregatesFilter
    notIn: [Int!]
}

input ClearNestedIntWithAggregatesFilter {
    _avg: ClearNestedFloatFilter
    _count: ClearNestedIntFilter
    _max: ClearNestedIntFilter
    _min: ClearNestedIntFilter
    _sum: ClearNestedIntFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntWithAggregatesFilter
    notIn: [Int!]
}

input ClearNestedJsonNullableFilter {
    equals: ClearJSON
    not: ClearJSON
}

input ClearNestedStringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: ClearNestedStringFilter
    notIn: [String!]
    startsWith: String
}

input ClearNestedStringNullableFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: ClearNestedStringNullableFilter
    notIn: [String!]
    startsWith: String
}

input ClearNestedStringNullableWithAggregatesFilter {
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedStringNullableFilter
    _min: ClearNestedStringNullableFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: ClearNestedStringNullableWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input ClearNestedStringWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedStringFilter
    _min: ClearNestedStringFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: ClearNestedStringWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input ClearNullableDateTimeFieldUpdateOperationsInput {
    set: ClearDateTime
}

input ClearNullableIntFieldUpdateOperationsInput {
    decrement: Int
    divide: Int
    increment: Int
    multiply: Int
    set: Int
}

input ClearNullableStringFieldUpdateOperationsInput {
    set: String
}

input ClearPaymentCountOrderByAggregateInput {
    complete: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    stripePaymentIntentId: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearPaymentCreateInput {
    complete: Boolean
    createdAt: ClearDateTime
    id: String
    metadata: ClearJSON
    stripePaymentIntentId: String!
    tickets: ClearTicketCreateNestedManyWithoutPaymentInput
    updatedAt: ClearDateTime
}

input ClearPaymentCreateManyInput {
    complete: Boolean
    createdAt: ClearDateTime
    id: String
    metadata: ClearJSON
    stripePaymentIntentId: String!
    updatedAt: ClearDateTime
}

input ClearPaymentCreateNestedOneWithoutTicketsInput {
    connect: ClearPaymentWhereUniqueInput
    connectOrCreate: ClearPaymentCreateOrConnectWithoutTicketsInput
    create: ClearPaymentCreateWithoutTicketsInput
}

input ClearPaymentCreateOrConnectWithoutTicketsInput {
    create: ClearPaymentCreateWithoutTicketsInput!
    where: ClearPaymentWhereUniqueInput!
}

input ClearPaymentCreateWithoutTicketsInput {
    complete: Boolean
    createdAt: ClearDateTime
    id: String
    metadata: ClearJSON
    stripePaymentIntentId: String!
    updatedAt: ClearDateTime
}

input ClearPaymentMaxOrderByAggregateInput {
    complete: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    stripePaymentIntentId: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearPaymentMinOrderByAggregateInput {
    complete: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    stripePaymentIntentId: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearPaymentOrderByWithAggregationInput {
    _count: ClearPaymentCountOrderByAggregateInput
    _max: ClearPaymentMaxOrderByAggregateInput
    _min: ClearPaymentMinOrderByAggregateInput
    complete: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    stripePaymentIntentId: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearPaymentOrderByWithRelationInput {
    complete: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    stripePaymentIntentId: ClearSortOrder
    tickets: ClearTicketOrderByRelationAggregateInput
    updatedAt: ClearSortOrder
}

input ClearPaymentRelationFilter {
    is: ClearPaymentWhereInput
    isNot: ClearPaymentWhereInput
}

input ClearPaymentScalarWhereWithAggregatesInput {
    AND: [ClearPaymentScalarWhereWithAggregatesInput!]
    NOT: [ClearPaymentScalarWhereWithAggregatesInput!]
    OR: [ClearPaymentScalarWhereWithAggregatesInput!]
    complete: ClearBoolWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    stripePaymentIntentId: ClearStringWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearPaymentUpdateInput {
    complete: ClearBoolFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    stripePaymentIntentId: ClearStringFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutPaymentInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearPaymentUpdateManyMutationInput {
    complete: ClearBoolFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    stripePaymentIntentId: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearPaymentUpdateOneWithoutTicketsInput {
    connect: ClearPaymentWhereUniqueInput
    connectOrCreate: ClearPaymentCreateOrConnectWithoutTicketsInput
    create: ClearPaymentCreateWithoutTicketsInput
    delete: Boolean
    disconnect: Boolean
    update: ClearPaymentUpdateWithoutTicketsInput
    upsert: ClearPaymentUpsertWithoutTicketsInput
}

input ClearPaymentUpdateWithoutTicketsInput {
    complete: ClearBoolFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    stripePaymentIntentId: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearPaymentUpsertWithoutTicketsInput {
    create: ClearPaymentCreateWithoutTicketsInput!
    update: ClearPaymentUpdateWithoutTicketsInput!
}

input ClearPaymentWhereInput {
    AND: [ClearPaymentWhereInput!]
    NOT: [ClearPaymentWhereInput!]
    OR: [ClearPaymentWhereInput!]
    complete: ClearBoolFilter
    createdAt: ClearDateTimeFilter
    id: ClearStringFilter
    metadata: ClearJsonNullableFilter
    stripePaymentIntentId: ClearStringFilter
    tickets: ClearTicketListRelationFilter
    updatedAt: ClearDateTimeFilter
}

input ClearPaymentWhereUniqueInput {
    id: String
}

input ClearPersonAvgOrderByAggregateInput {
    age: ClearSortOrder
}

input ClearPersonCountOrderByAggregateInput {
    age: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    phone: ClearSortOrder
    pronouns: ClearSortOrder
    updatedAt: ClearSortOrder
    username: ClearSortOrder
}

input ClearPersonCreateInput {
    Ticket: ClearTicketCreateNestedManyWithoutGuardianInput
    age: Int
    createdAt: ClearDateTime
    email: String
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    phone: String
    pronouns: String
    updatedAt: ClearDateTime
    username: String
}

input ClearPersonCreateManyInput {
    age: Int
    createdAt: ClearDateTime
    email: String
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    phone: String
    pronouns: String
    updatedAt: ClearDateTime
    username: String
}

input ClearPersonCreateNestedOneWithoutTicketInput {
    connect: ClearPersonWhereUniqueInput
    connectOrCreate: ClearPersonCreateOrConnectWithoutTicketInput
    create: ClearPersonCreateWithoutTicketInput
}

input ClearPersonCreateOrConnectWithoutTicketInput {
    create: ClearPersonCreateWithoutTicketInput!
    where: ClearPersonWhereUniqueInput!
}

input ClearPersonCreateWithoutTicketInput {
    age: Int
    createdAt: ClearDateTime
    email: String
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    phone: String
    pronouns: String
    updatedAt: ClearDateTime
    username: String
}

input ClearPersonMaxOrderByAggregateInput {
    age: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    phone: ClearSortOrder
    pronouns: ClearSortOrder
    updatedAt: ClearSortOrder
    username: ClearSortOrder
}

input ClearPersonMinOrderByAggregateInput {
    age: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    phone: ClearSortOrder
    pronouns: ClearSortOrder
    updatedAt: ClearSortOrder
    username: ClearSortOrder
}

input ClearPersonOrderByWithAggregationInput {
    _avg: ClearPersonAvgOrderByAggregateInput
    _count: ClearPersonCountOrderByAggregateInput
    _max: ClearPersonMaxOrderByAggregateInput
    _min: ClearPersonMinOrderByAggregateInput
    _sum: ClearPersonSumOrderByAggregateInput
    age: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    phone: ClearSortOrder
    pronouns: ClearSortOrder
    updatedAt: ClearSortOrder
    username: ClearSortOrder
}

input ClearPersonOrderByWithRelationInput {
    Ticket: ClearTicketOrderByRelationAggregateInput
    age: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    phone: ClearSortOrder
    pronouns: ClearSortOrder
    updatedAt: ClearSortOrder
    username: ClearSortOrder
}

input ClearPersonRelationFilter {
    is: ClearPersonWhereInput
    isNot: ClearPersonWhereInput
}

input ClearPersonScalarWhereWithAggregatesInput {
    AND: [ClearPersonScalarWhereWithAggregatesInput!]
    NOT: [ClearPersonScalarWhereWithAggregatesInput!]
    OR: [ClearPersonScalarWhereWithAggregatesInput!]
    age: ClearIntNullableWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    email: ClearStringNullableWithAggregatesFilter
    firstName: ClearStringWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    lastName: ClearStringWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    phone: ClearStringNullableWithAggregatesFilter
    pronouns: ClearStringNullableWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
    username: ClearStringNullableWithAggregatesFilter
}

input ClearPersonSumOrderByAggregateInput {
    age: ClearSortOrder
}

input ClearPersonUpdateInput {
    Ticket: ClearTicketUpdateManyWithoutGuardianInput
    age: ClearNullableIntFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    firstName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    phone: ClearNullableStringFieldUpdateOperationsInput
    pronouns: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    username: ClearNullableStringFieldUpdateOperationsInput
}

input ClearPersonUpdateManyMutationInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    firstName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    phone: ClearNullableStringFieldUpdateOperationsInput
    pronouns: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    username: ClearNullableStringFieldUpdateOperationsInput
}

input ClearPersonUpdateOneWithoutTicketInput {
    connect: ClearPersonWhereUniqueInput
    connectOrCreate: ClearPersonCreateOrConnectWithoutTicketInput
    create: ClearPersonCreateWithoutTicketInput
    delete: Boolean
    disconnect: Boolean
    update: ClearPersonUpdateWithoutTicketInput
    upsert: ClearPersonUpsertWithoutTicketInput
}

input ClearPersonUpdateWithoutTicketInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    firstName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    phone: ClearNullableStringFieldUpdateOperationsInput
    pronouns: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    username: ClearNullableStringFieldUpdateOperationsInput
}

input ClearPersonUpsertWithoutTicketInput {
    create: ClearPersonCreateWithoutTicketInput!
    update: ClearPersonUpdateWithoutTicketInput!
}

input ClearPersonWhereInput {
    AND: [ClearPersonWhereInput!]
    NOT: [ClearPersonWhereInput!]
    OR: [ClearPersonWhereInput!]
    Ticket: ClearTicketListRelationFilter
    age: ClearIntNullableFilter
    createdAt: ClearDateTimeFilter
    email: ClearStringNullableFilter
    firstName: ClearStringFilter
    id: ClearStringFilter
    lastName: ClearStringFilter
    metadata: ClearJsonNullableFilter
    phone: ClearStringNullableFilter
    pronouns: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
    username: ClearStringNullableFilter
}

input ClearPersonWhereUniqueInput {
    id: String
}

input ClearPromoCodeAvgOrderByAggregateInput {
    amount: ClearSortOrder
    uses: ClearSortOrder
}

input ClearPromoCodeCountOrderByAggregateInput {
    amount: ClearSortOrder
    code: ClearSortOrder
    createdAt: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    uses: ClearSortOrder
}

input ClearPromoCodeCreateInput {
    amount: Float!
    code: String!
    createdAt: ClearDateTime
    event: ClearEventCreateNestedOneWithoutPromoCodesInput
    eventGroup: ClearEventGroupCreateNestedOneWithoutPromoCodesInput
    id: String
    metadata: ClearJSON
    tickets: ClearTicketCreateNestedManyWithoutPromoCodeInput
    type: ClearDiscountType!
    updatedAt: ClearDateTime
    uses: Int
}

input ClearPromoCodeCreateManyEventGroupInput {
    amount: Float!
    code: String!
    createdAt: ClearDateTime
    eventId: String
    id: String
    metadata: ClearJSON
    type: ClearDiscountType!
    updatedAt: ClearDateTime
    uses: Int
}

input ClearPromoCodeCreateManyEventGroupInputEnvelope {
    data: [ClearPromoCodeCreateManyEventGroupInput!]!
    skipDuplicates: Boolean
}

input ClearPromoCodeCreateManyEventInput {
    amount: Float!
    code: String!
    createdAt: ClearDateTime
    eventGroupId: String
    id: String
    metadata: ClearJSON
    type: ClearDiscountType!
    updatedAt: ClearDateTime
    uses: Int
}

input ClearPromoCodeCreateManyEventInputEnvelope {
    data: [ClearPromoCodeCreateManyEventInput!]!
    skipDuplicates: Boolean
}

input ClearPromoCodeCreateManyInput {
    amount: Float!
    code: String!
    createdAt: ClearDateTime
    eventGroupId: String
    eventId: String
    id: String
    metadata: ClearJSON
    type: ClearDiscountType!
    updatedAt: ClearDateTime
    uses: Int
}

input ClearPromoCodeCreateNestedManyWithoutEventGroupInput {
    connect: [ClearPromoCodeWhereUniqueInput!]
    connectOrCreate: [ClearPromoCodeCreateOrConnectWithoutEventGroupInput!]
    create: [ClearPromoCodeCreateWithoutEventGroupInput!]
    createMany: ClearPromoCodeCreateManyEventGroupInputEnvelope
}

input ClearPromoCodeCreateNestedManyWithoutEventInput {
    connect: [ClearPromoCodeWhereUniqueInput!]
    connectOrCreate: [ClearPromoCodeCreateOrConnectWithoutEventInput!]
    create: [ClearPromoCodeCreateWithoutEventInput!]
    createMany: ClearPromoCodeCreateManyEventInputEnvelope
}

input ClearPromoCodeCreateNestedOneWithoutTicketsInput {
    connect: ClearPromoCodeWhereUniqueInput
    connectOrCreate: ClearPromoCodeCreateOrConnectWithoutTicketsInput
    create: ClearPromoCodeCreateWithoutTicketsInput
}

input ClearPromoCodeCreateOrConnectWithoutEventGroupInput {
    create: ClearPromoCodeCreateWithoutEventGroupInput!
    where: ClearPromoCodeWhereUniqueInput!
}

input ClearPromoCodeCreateOrConnectWithoutEventInput {
    create: ClearPromoCodeCreateWithoutEventInput!
    where: ClearPromoCodeWhereUniqueInput!
}

input ClearPromoCodeCreateOrConnectWithoutTicketsInput {
    create: ClearPromoCodeCreateWithoutTicketsInput!
    where: ClearPromoCodeWhereUniqueInput!
}

input ClearPromoCodeCreateWithoutEventGroupInput {
    amount: Float!
    code: String!
    createdAt: ClearDateTime
    event: ClearEventCreateNestedOneWithoutPromoCodesInput
    id: String
    metadata: ClearJSON
    tickets: ClearTicketCreateNestedManyWithoutPromoCodeInput
    type: ClearDiscountType!
    updatedAt: ClearDateTime
    uses: Int
}

input ClearPromoCodeCreateWithoutEventInput {
    amount: Float!
    code: String!
    createdAt: ClearDateTime
    eventGroup: ClearEventGroupCreateNestedOneWithoutPromoCodesInput
    id: String
    metadata: ClearJSON
    tickets: ClearTicketCreateNestedManyWithoutPromoCodeInput
    type: ClearDiscountType!
    updatedAt: ClearDateTime
    uses: Int
}

input ClearPromoCodeCreateWithoutTicketsInput {
    amount: Float!
    code: String!
    createdAt: ClearDateTime
    event: ClearEventCreateNestedOneWithoutPromoCodesInput
    eventGroup: ClearEventGroupCreateNestedOneWithoutPromoCodesInput
    id: String
    metadata: ClearJSON
    type: ClearDiscountType!
    updatedAt: ClearDateTime
    uses: Int
}

input ClearPromoCodeListRelationFilter {
    every: ClearPromoCodeWhereInput
    none: ClearPromoCodeWhereInput
    some: ClearPromoCodeWhereInput
}

input ClearPromoCodeMaxOrderByAggregateInput {
    amount: ClearSortOrder
    code: ClearSortOrder
    createdAt: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    uses: ClearSortOrder
}

input ClearPromoCodeMinOrderByAggregateInput {
    amount: ClearSortOrder
    code: ClearSortOrder
    createdAt: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    uses: ClearSortOrder
}

input ClearPromoCodeOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearPromoCodeOrderByWithAggregationInput {
    _avg: ClearPromoCodeAvgOrderByAggregateInput
    _count: ClearPromoCodeCountOrderByAggregateInput
    _max: ClearPromoCodeMaxOrderByAggregateInput
    _min: ClearPromoCodeMinOrderByAggregateInput
    _sum: ClearPromoCodeSumOrderByAggregateInput
    amount: ClearSortOrder
    code: ClearSortOrder
    createdAt: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    uses: ClearSortOrder
}

input ClearPromoCodeOrderByWithRelationInput {
    amount: ClearSortOrder
    code: ClearSortOrder
    createdAt: ClearSortOrder
    event: ClearEventOrderByWithRelationInput
    eventGroup: ClearEventGroupOrderByWithRelationInput
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    tickets: ClearTicketOrderByRelationAggregateInput
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    uses: ClearSortOrder
}

input ClearPromoCodeRelationFilter {
    is: ClearPromoCodeWhereInput
    isNot: ClearPromoCodeWhereInput
}

input ClearPromoCodeScalarWhereInput {
    AND: [ClearPromoCodeScalarWhereInput!]
    NOT: [ClearPromoCodeScalarWhereInput!]
    OR: [ClearPromoCodeScalarWhereInput!]
    amount: ClearFloatFilter
    code: ClearStringFilter
    createdAt: ClearDateTimeFilter
    eventGroupId: ClearStringNullableFilter
    eventId: ClearStringNullableFilter
    id: ClearStringFilter
    metadata: ClearJsonNullableFilter
    type: ClearEnumDiscountTypeFilter
    updatedAt: ClearDateTimeFilter
    uses: ClearIntNullableFilter
}

input ClearPromoCodeScalarWhereWithAggregatesInput {
    AND: [ClearPromoCodeScalarWhereWithAggregatesInput!]
    NOT: [ClearPromoCodeScalarWhereWithAggregatesInput!]
    OR: [ClearPromoCodeScalarWhereWithAggregatesInput!]
    amount: ClearFloatWithAggregatesFilter
    code: ClearStringWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    eventGroupId: ClearStringNullableWithAggregatesFilter
    eventId: ClearStringNullableWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    type: ClearEnumDiscountTypeWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
    uses: ClearIntNullableWithAggregatesFilter
}

input ClearPromoCodeSumOrderByAggregateInput {
    amount: ClearSortOrder
    uses: ClearSortOrder
}

input ClearPromoCodeUpdateInput {
    amount: ClearFloatFieldUpdateOperationsInput
    code: ClearStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    event: ClearEventUpdateOneWithoutPromoCodesInput
    eventGroup: ClearEventGroupUpdateOneWithoutPromoCodesInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    tickets: ClearTicketUpdateManyWithoutPromoCodeInput
    type: ClearEnumDiscountTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    uses: ClearNullableIntFieldUpdateOperationsInput
}

input ClearPromoCodeUpdateManyMutationInput {
    amount: ClearFloatFieldUpdateOperationsInput
    code: ClearStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    type: ClearEnumDiscountTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    uses: ClearNullableIntFieldUpdateOperationsInput
}

input ClearPromoCodeUpdateManyWithWhereWithoutEventGroupInput {
    data: ClearPromoCodeUpdateManyMutationInput!
    where: ClearPromoCodeScalarWhereInput!
}

input ClearPromoCodeUpdateManyWithWhereWithoutEventInput {
    data: ClearPromoCodeUpdateManyMutationInput!
    where: ClearPromoCodeScalarWhereInput!
}

input ClearPromoCodeUpdateManyWithoutEventGroupInput {
    connect: [ClearPromoCodeWhereUniqueInput!]
    connectOrCreate: [ClearPromoCodeCreateOrConnectWithoutEventGroupInput!]
    create: [ClearPromoCodeCreateWithoutEventGroupInput!]
    createMany: ClearPromoCodeCreateManyEventGroupInputEnvelope
    delete: [ClearPromoCodeWhereUniqueInput!]
    deleteMany: [ClearPromoCodeScalarWhereInput!]
    disconnect: [ClearPromoCodeWhereUniqueInput!]
    set: [ClearPromoCodeWhereUniqueInput!]
    update: [ClearPromoCodeUpdateWithWhereUniqueWithoutEventGroupInput!]
    updateMany: [ClearPromoCodeUpdateManyWithWhereWithoutEventGroupInput!]
    upsert: [ClearPromoCodeUpsertWithWhereUniqueWithoutEventGroupInput!]
}

input ClearPromoCodeUpdateManyWithoutEventInput {
    connect: [ClearPromoCodeWhereUniqueInput!]
    connectOrCreate: [ClearPromoCodeCreateOrConnectWithoutEventInput!]
    create: [ClearPromoCodeCreateWithoutEventInput!]
    createMany: ClearPromoCodeCreateManyEventInputEnvelope
    delete: [ClearPromoCodeWhereUniqueInput!]
    deleteMany: [ClearPromoCodeScalarWhereInput!]
    disconnect: [ClearPromoCodeWhereUniqueInput!]
    set: [ClearPromoCodeWhereUniqueInput!]
    update: [ClearPromoCodeUpdateWithWhereUniqueWithoutEventInput!]
    updateMany: [ClearPromoCodeUpdateManyWithWhereWithoutEventInput!]
    upsert: [ClearPromoCodeUpsertWithWhereUniqueWithoutEventInput!]
}

input ClearPromoCodeUpdateOneWithoutTicketsInput {
    connect: ClearPromoCodeWhereUniqueInput
    connectOrCreate: ClearPromoCodeCreateOrConnectWithoutTicketsInput
    create: ClearPromoCodeCreateWithoutTicketsInput
    delete: Boolean
    disconnect: Boolean
    update: ClearPromoCodeUpdateWithoutTicketsInput
    upsert: ClearPromoCodeUpsertWithoutTicketsInput
}

input ClearPromoCodeUpdateWithWhereUniqueWithoutEventGroupInput {
    data: ClearPromoCodeUpdateWithoutEventGroupInput!
    where: ClearPromoCodeWhereUniqueInput!
}

input ClearPromoCodeUpdateWithWhereUniqueWithoutEventInput {
    data: ClearPromoCodeUpdateWithoutEventInput!
    where: ClearPromoCodeWhereUniqueInput!
}

input ClearPromoCodeUpdateWithoutEventGroupInput {
    amount: ClearFloatFieldUpdateOperationsInput
    code: ClearStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    event: ClearEventUpdateOneWithoutPromoCodesInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    tickets: ClearTicketUpdateManyWithoutPromoCodeInput
    type: ClearEnumDiscountTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    uses: ClearNullableIntFieldUpdateOperationsInput
}

input ClearPromoCodeUpdateWithoutEventInput {
    amount: ClearFloatFieldUpdateOperationsInput
    code: ClearStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneWithoutPromoCodesInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    tickets: ClearTicketUpdateManyWithoutPromoCodeInput
    type: ClearEnumDiscountTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    uses: ClearNullableIntFieldUpdateOperationsInput
}

input ClearPromoCodeUpdateWithoutTicketsInput {
    amount: ClearFloatFieldUpdateOperationsInput
    code: ClearStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    event: ClearEventUpdateOneWithoutPromoCodesInput
    eventGroup: ClearEventGroupUpdateOneWithoutPromoCodesInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    type: ClearEnumDiscountTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    uses: ClearNullableIntFieldUpdateOperationsInput
}

input ClearPromoCodeUpsertWithWhereUniqueWithoutEventGroupInput {
    create: ClearPromoCodeCreateWithoutEventGroupInput!
    update: ClearPromoCodeUpdateWithoutEventGroupInput!
    where: ClearPromoCodeWhereUniqueInput!
}

input ClearPromoCodeUpsertWithWhereUniqueWithoutEventInput {
    create: ClearPromoCodeCreateWithoutEventInput!
    update: ClearPromoCodeUpdateWithoutEventInput!
    where: ClearPromoCodeWhereUniqueInput!
}

input ClearPromoCodeUpsertWithoutTicketsInput {
    create: ClearPromoCodeCreateWithoutTicketsInput!
    update: ClearPromoCodeUpdateWithoutTicketsInput!
}

input ClearPromoCodeWhereInput {
    AND: [ClearPromoCodeWhereInput!]
    NOT: [ClearPromoCodeWhereInput!]
    OR: [ClearPromoCodeWhereInput!]
    amount: ClearFloatFilter
    code: ClearStringFilter
    createdAt: ClearDateTimeFilter
    event: ClearEventRelationFilter
    eventGroup: ClearEventGroupRelationFilter
    eventGroupId: ClearStringNullableFilter
    eventId: ClearStringNullableFilter
    id: ClearStringFilter
    metadata: ClearJsonNullableFilter
    tickets: ClearTicketListRelationFilter
    type: ClearEnumDiscountTypeFilter
    updatedAt: ClearDateTimeFilter
    uses: ClearIntNullableFilter
}

input ClearPromoCodeWhereUniqueInput {
    id: String
}

input ClearScheduleItemCountOrderByAggregateInput {
    createdAt: ClearSortOrder
    description: ClearSortOrder
    end: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    finalized: ClearSortOrder
    hostEmail: ClearSortOrder
    hostName: ClearSortOrder
    hostPronoun: ClearSortOrder
    id: ClearSortOrder
    internal: ClearSortOrder
    link: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    organizerEmail: ClearSortOrder
    organizerName: ClearSortOrder
    organizerPhone: ClearSortOrder
    start: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearScheduleItemCreateInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    event: ClearEventCreateNestedOneWithoutScheduleInput
    eventGroup: ClearEventGroupCreateNestedOneWithoutScheduleInput
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String!
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime!
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemCreateManyEventGroupInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventId: String
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String!
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime!
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemCreateManyEventGroupInputEnvelope {
    data: [ClearScheduleItemCreateManyEventGroupInput!]!
    skipDuplicates: Boolean
}

input ClearScheduleItemCreateManyEventInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventGroupId: String
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String!
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime!
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemCreateManyEventInputEnvelope {
    data: [ClearScheduleItemCreateManyEventInput!]!
    skipDuplicates: Boolean
}

input ClearScheduleItemCreateManyInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventGroupId: String
    eventId: String
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String!
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime!
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemCreateNestedManyWithoutEventGroupInput {
    connect: [ClearScheduleItemWhereUniqueInput!]
    connectOrCreate: [ClearScheduleItemCreateOrConnectWithoutEventGroupInput!]
    create: [ClearScheduleItemCreateWithoutEventGroupInput!]
    createMany: ClearScheduleItemCreateManyEventGroupInputEnvelope
}

input ClearScheduleItemCreateNestedManyWithoutEventInput {
    connect: [ClearScheduleItemWhereUniqueInput!]
    connectOrCreate: [ClearScheduleItemCreateOrConnectWithoutEventInput!]
    create: [ClearScheduleItemCreateWithoutEventInput!]
    createMany: ClearScheduleItemCreateManyEventInputEnvelope
}

input ClearScheduleItemCreateOrConnectWithoutEventGroupInput {
    create: ClearScheduleItemCreateWithoutEventGroupInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemCreateOrConnectWithoutEventInput {
    create: ClearScheduleItemCreateWithoutEventInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemCreateWithoutEventGroupInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    event: ClearEventCreateNestedOneWithoutScheduleInput
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String!
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime!
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemCreateWithoutEventInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventGroup: ClearEventGroupCreateNestedOneWithoutScheduleInput
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String!
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime!
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemListRelationFilter {
    every: ClearScheduleItemWhereInput
    none: ClearScheduleItemWhereInput
    some: ClearScheduleItemWhereInput
}

input ClearScheduleItemMaxOrderByAggregateInput {
    createdAt: ClearSortOrder
    description: ClearSortOrder
    end: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    finalized: ClearSortOrder
    hostEmail: ClearSortOrder
    hostName: ClearSortOrder
    hostPronoun: ClearSortOrder
    id: ClearSortOrder
    internal: ClearSortOrder
    link: ClearSortOrder
    name: ClearSortOrder
    organizerEmail: ClearSortOrder
    organizerName: ClearSortOrder
    organizerPhone: ClearSortOrder
    start: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearScheduleItemMinOrderByAggregateInput {
    createdAt: ClearSortOrder
    description: ClearSortOrder
    end: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    finalized: ClearSortOrder
    hostEmail: ClearSortOrder
    hostName: ClearSortOrder
    hostPronoun: ClearSortOrder
    id: ClearSortOrder
    internal: ClearSortOrder
    link: ClearSortOrder
    name: ClearSortOrder
    organizerEmail: ClearSortOrder
    organizerName: ClearSortOrder
    organizerPhone: ClearSortOrder
    start: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearScheduleItemOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearScheduleItemOrderByWithAggregationInput {
    _count: ClearScheduleItemCountOrderByAggregateInput
    _max: ClearScheduleItemMaxOrderByAggregateInput
    _min: ClearScheduleItemMinOrderByAggregateInput
    createdAt: ClearSortOrder
    description: ClearSortOrder
    end: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    finalized: ClearSortOrder
    hostEmail: ClearSortOrder
    hostName: ClearSortOrder
    hostPronoun: ClearSortOrder
    id: ClearSortOrder
    internal: ClearSortOrder
    link: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    organizerEmail: ClearSortOrder
    organizerName: ClearSortOrder
    organizerPhone: ClearSortOrder
    start: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearScheduleItemOrderByWithRelationInput {
    createdAt: ClearSortOrder
    description: ClearSortOrder
    end: ClearSortOrder
    event: ClearEventOrderByWithRelationInput
    eventGroup: ClearEventGroupOrderByWithRelationInput
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    finalized: ClearSortOrder
    hostEmail: ClearSortOrder
    hostName: ClearSortOrder
    hostPronoun: ClearSortOrder
    id: ClearSortOrder
    internal: ClearSortOrder
    link: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    organizerEmail: ClearSortOrder
    organizerName: ClearSortOrder
    organizerPhone: ClearSortOrder
    start: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearScheduleItemScalarWhereInput {
    AND: [ClearScheduleItemScalarWhereInput!]
    NOT: [ClearScheduleItemScalarWhereInput!]
    OR: [ClearScheduleItemScalarWhereInput!]
    createdAt: ClearDateTimeFilter
    description: ClearStringNullableFilter
    end: ClearDateTimeNullableFilter
    eventGroupId: ClearStringNullableFilter
    eventId: ClearStringNullableFilter
    finalized: ClearBoolFilter
    hostEmail: ClearStringNullableFilter
    hostName: ClearStringNullableFilter
    hostPronoun: ClearStringNullableFilter
    id: ClearStringFilter
    internal: ClearBoolFilter
    link: ClearStringNullableFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    organizerEmail: ClearStringNullableFilter
    organizerName: ClearStringNullableFilter
    organizerPhone: ClearStringNullableFilter
    start: ClearDateTimeFilter
    type: ClearStringFilter
    updatedAt: ClearDateTimeFilter
}

input ClearScheduleItemScalarWhereWithAggregatesInput {
    AND: [ClearScheduleItemScalarWhereWithAggregatesInput!]
    NOT: [ClearScheduleItemScalarWhereWithAggregatesInput!]
    OR: [ClearScheduleItemScalarWhereWithAggregatesInput!]
    createdAt: ClearDateTimeWithAggregatesFilter
    description: ClearStringNullableWithAggregatesFilter
    end: ClearDateTimeNullableWithAggregatesFilter
    eventGroupId: ClearStringNullableWithAggregatesFilter
    eventId: ClearStringNullableWithAggregatesFilter
    finalized: ClearBoolWithAggregatesFilter
    hostEmail: ClearStringNullableWithAggregatesFilter
    hostName: ClearStringNullableWithAggregatesFilter
    hostPronoun: ClearStringNullableWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    internal: ClearBoolWithAggregatesFilter
    link: ClearStringNullableWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringWithAggregatesFilter
    organizerEmail: ClearStringNullableWithAggregatesFilter
    organizerName: ClearStringNullableWithAggregatesFilter
    organizerPhone: ClearStringNullableWithAggregatesFilter
    start: ClearDateTimeWithAggregatesFilter
    type: ClearStringWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearScheduleItemUpdateInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    end: ClearNullableDateTimeFieldUpdateOperationsInput
    event: ClearEventUpdateOneWithoutScheduleInput
    eventGroup: ClearEventGroupUpdateOneWithoutScheduleInput
    finalized: ClearBoolFieldUpdateOperationsInput
    hostEmail: ClearNullableStringFieldUpdateOperationsInput
    hostName: ClearNullableStringFieldUpdateOperationsInput
    hostPronoun: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    internal: ClearBoolFieldUpdateOperationsInput
    link: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    organizerEmail: ClearNullableStringFieldUpdateOperationsInput
    organizerName: ClearNullableStringFieldUpdateOperationsInput
    organizerPhone: ClearNullableStringFieldUpdateOperationsInput
    start: ClearDateTimeFieldUpdateOperationsInput
    type: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearScheduleItemUpdateManyMutationInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    end: ClearNullableDateTimeFieldUpdateOperationsInput
    finalized: ClearBoolFieldUpdateOperationsInput
    hostEmail: ClearNullableStringFieldUpdateOperationsInput
    hostName: ClearNullableStringFieldUpdateOperationsInput
    hostPronoun: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    internal: ClearBoolFieldUpdateOperationsInput
    link: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    organizerEmail: ClearNullableStringFieldUpdateOperationsInput
    organizerName: ClearNullableStringFieldUpdateOperationsInput
    organizerPhone: ClearNullableStringFieldUpdateOperationsInput
    start: ClearDateTimeFieldUpdateOperationsInput
    type: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearScheduleItemUpdateManyWithWhereWithoutEventGroupInput {
    data: ClearScheduleItemUpdateManyMutationInput!
    where: ClearScheduleItemScalarWhereInput!
}

input ClearScheduleItemUpdateManyWithWhereWithoutEventInput {
    data: ClearScheduleItemUpdateManyMutationInput!
    where: ClearScheduleItemScalarWhereInput!
}

input ClearScheduleItemUpdateManyWithoutEventGroupInput {
    connect: [ClearScheduleItemWhereUniqueInput!]
    connectOrCreate: [ClearScheduleItemCreateOrConnectWithoutEventGroupInput!]
    create: [ClearScheduleItemCreateWithoutEventGroupInput!]
    createMany: ClearScheduleItemCreateManyEventGroupInputEnvelope
    delete: [ClearScheduleItemWhereUniqueInput!]
    deleteMany: [ClearScheduleItemScalarWhereInput!]
    disconnect: [ClearScheduleItemWhereUniqueInput!]
    set: [ClearScheduleItemWhereUniqueInput!]
    update: [ClearScheduleItemUpdateWithWhereUniqueWithoutEventGroupInput!]
    updateMany: [ClearScheduleItemUpdateManyWithWhereWithoutEventGroupInput!]
    upsert: [ClearScheduleItemUpsertWithWhereUniqueWithoutEventGroupInput!]
}

input ClearScheduleItemUpdateManyWithoutEventInput {
    connect: [ClearScheduleItemWhereUniqueInput!]
    connectOrCreate: [ClearScheduleItemCreateOrConnectWithoutEventInput!]
    create: [ClearScheduleItemCreateWithoutEventInput!]
    createMany: ClearScheduleItemCreateManyEventInputEnvelope
    delete: [ClearScheduleItemWhereUniqueInput!]
    deleteMany: [ClearScheduleItemScalarWhereInput!]
    disconnect: [ClearScheduleItemWhereUniqueInput!]
    set: [ClearScheduleItemWhereUniqueInput!]
    update: [ClearScheduleItemUpdateWithWhereUniqueWithoutEventInput!]
    updateMany: [ClearScheduleItemUpdateManyWithWhereWithoutEventInput!]
    upsert: [ClearScheduleItemUpsertWithWhereUniqueWithoutEventInput!]
}

input ClearScheduleItemUpdateWithWhereUniqueWithoutEventGroupInput {
    data: ClearScheduleItemUpdateWithoutEventGroupInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemUpdateWithWhereUniqueWithoutEventInput {
    data: ClearScheduleItemUpdateWithoutEventInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemUpdateWithoutEventGroupInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    end: ClearNullableDateTimeFieldUpdateOperationsInput
    event: ClearEventUpdateOneWithoutScheduleInput
    finalized: ClearBoolFieldUpdateOperationsInput
    hostEmail: ClearNullableStringFieldUpdateOperationsInput
    hostName: ClearNullableStringFieldUpdateOperationsInput
    hostPronoun: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    internal: ClearBoolFieldUpdateOperationsInput
    link: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    organizerEmail: ClearNullableStringFieldUpdateOperationsInput
    organizerName: ClearNullableStringFieldUpdateOperationsInput
    organizerPhone: ClearNullableStringFieldUpdateOperationsInput
    start: ClearDateTimeFieldUpdateOperationsInput
    type: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearScheduleItemUpdateWithoutEventInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    end: ClearNullableDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneWithoutScheduleInput
    finalized: ClearBoolFieldUpdateOperationsInput
    hostEmail: ClearNullableStringFieldUpdateOperationsInput
    hostName: ClearNullableStringFieldUpdateOperationsInput
    hostPronoun: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    internal: ClearBoolFieldUpdateOperationsInput
    link: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    organizerEmail: ClearNullableStringFieldUpdateOperationsInput
    organizerName: ClearNullableStringFieldUpdateOperationsInput
    organizerPhone: ClearNullableStringFieldUpdateOperationsInput
    start: ClearDateTimeFieldUpdateOperationsInput
    type: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearScheduleItemUpsertWithWhereUniqueWithoutEventGroupInput {
    create: ClearScheduleItemCreateWithoutEventGroupInput!
    update: ClearScheduleItemUpdateWithoutEventGroupInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemUpsertWithWhereUniqueWithoutEventInput {
    create: ClearScheduleItemCreateWithoutEventInput!
    update: ClearScheduleItemUpdateWithoutEventInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemWhereInput {
    AND: [ClearScheduleItemWhereInput!]
    NOT: [ClearScheduleItemWhereInput!]
    OR: [ClearScheduleItemWhereInput!]
    createdAt: ClearDateTimeFilter
    description: ClearStringNullableFilter
    end: ClearDateTimeNullableFilter
    event: ClearEventRelationFilter
    eventGroup: ClearEventGroupRelationFilter
    eventGroupId: ClearStringNullableFilter
    eventId: ClearStringNullableFilter
    finalized: ClearBoolFilter
    hostEmail: ClearStringNullableFilter
    hostName: ClearStringNullableFilter
    hostPronoun: ClearStringNullableFilter
    id: ClearStringFilter
    internal: ClearBoolFilter
    link: ClearStringNullableFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    organizerEmail: ClearStringNullableFilter
    organizerName: ClearStringNullableFilter
    organizerPhone: ClearStringNullableFilter
    start: ClearDateTimeFilter
    type: ClearStringFilter
    updatedAt: ClearDateTimeFilter
}

input ClearScheduleItemWhereUniqueInput {
    id: String
}

input ClearSponsorAvgOrderByAggregateInput {
    amount: ClearSortOrder
}

input ClearSponsorCountOrderByAggregateInput {
    amount: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    darkLogoImageUri: ClearSortOrder
    description: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    link: ClearSortOrder
    logoImageUri: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    perks: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearSponsorCreateInput {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    darkLogoImageUri: String
    description: String
    event: ClearEventCreateNestedOneWithoutSponsorsInput
    id: String
    link: String
    logoImageUri: String
    metadata: ClearJSON
    name: String!
    perks: String
    updatedAt: ClearDateTime
}

input ClearSponsorCreateManyEventInput {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    darkLogoImageUri: String
    description: String
    id: String
    link: String
    logoImageUri: String
    metadata: ClearJSON
    name: String!
    perks: String
    updatedAt: ClearDateTime
}

input ClearSponsorCreateManyEventInputEnvelope {
    data: [ClearSponsorCreateManyEventInput!]!
    skipDuplicates: Boolean
}

input ClearSponsorCreateManyInput {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    darkLogoImageUri: String
    description: String
    eventId: String
    id: String
    link: String
    logoImageUri: String
    metadata: ClearJSON
    name: String!
    perks: String
    updatedAt: ClearDateTime
}

input ClearSponsorCreateNestedManyWithoutEventInput {
    connect: [ClearSponsorWhereUniqueInput!]
    connectOrCreate: [ClearSponsorCreateOrConnectWithoutEventInput!]
    create: [ClearSponsorCreateWithoutEventInput!]
    createMany: ClearSponsorCreateManyEventInputEnvelope
}

input ClearSponsorCreateOrConnectWithoutEventInput {
    create: ClearSponsorCreateWithoutEventInput!
    where: ClearSponsorWhereUniqueInput!
}

input ClearSponsorCreateWithoutEventInput {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    darkLogoImageUri: String
    description: String
    id: String
    link: String
    logoImageUri: String
    metadata: ClearJSON
    name: String!
    perks: String
    updatedAt: ClearDateTime
}

input ClearSponsorListRelationFilter {
    every: ClearSponsorWhereInput
    none: ClearSponsorWhereInput
    some: ClearSponsorWhereInput
}

input ClearSponsorMaxOrderByAggregateInput {
    amount: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    darkLogoImageUri: ClearSortOrder
    description: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    link: ClearSortOrder
    logoImageUri: ClearSortOrder
    name: ClearSortOrder
    perks: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearSponsorMinOrderByAggregateInput {
    amount: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    darkLogoImageUri: ClearSortOrder
    description: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    link: ClearSortOrder
    logoImageUri: ClearSortOrder
    name: ClearSortOrder
    perks: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearSponsorOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearSponsorOrderByWithAggregationInput {
    _avg: ClearSponsorAvgOrderByAggregateInput
    _count: ClearSponsorCountOrderByAggregateInput
    _max: ClearSponsorMaxOrderByAggregateInput
    _min: ClearSponsorMinOrderByAggregateInput
    _sum: ClearSponsorSumOrderByAggregateInput
    amount: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    darkLogoImageUri: ClearSortOrder
    description: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    link: ClearSortOrder
    logoImageUri: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    perks: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearSponsorOrderByWithRelationInput {
    amount: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    darkLogoImageUri: ClearSortOrder
    description: ClearSortOrder
    event: ClearEventOrderByWithRelationInput
    eventId: ClearSortOrder
    id: ClearSortOrder
    link: ClearSortOrder
    logoImageUri: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    perks: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearSponsorScalarWhereInput {
    AND: [ClearSponsorScalarWhereInput!]
    NOT: [ClearSponsorScalarWhereInput!]
    OR: [ClearSponsorScalarWhereInput!]
    amount: ClearIntFilter
    contactEmail: ClearStringNullableFilter
    contactName: ClearStringNullableFilter
    contactPhone: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    darkLogoImageUri: ClearStringNullableFilter
    description: ClearStringNullableFilter
    eventId: ClearStringNullableFilter
    id: ClearStringFilter
    link: ClearStringNullableFilter
    logoImageUri: ClearStringNullableFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    perks: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
}

input ClearSponsorScalarWhereWithAggregatesInput {
    AND: [ClearSponsorScalarWhereWithAggregatesInput!]
    NOT: [ClearSponsorScalarWhereWithAggregatesInput!]
    OR: [ClearSponsorScalarWhereWithAggregatesInput!]
    amount: ClearIntWithAggregatesFilter
    contactEmail: ClearStringNullableWithAggregatesFilter
    contactName: ClearStringNullableWithAggregatesFilter
    contactPhone: ClearStringNullableWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    darkLogoImageUri: ClearStringNullableWithAggregatesFilter
    description: ClearStringNullableWithAggregatesFilter
    eventId: ClearStringNullableWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    link: ClearStringNullableWithAggregatesFilter
    logoImageUri: ClearStringNullableWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringWithAggregatesFilter
    perks: ClearStringNullableWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearSponsorSumOrderByAggregateInput {
    amount: ClearSortOrder
}

input ClearSponsorUpdateInput {
    amount: ClearIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    darkLogoImageUri: ClearNullableStringFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    event: ClearEventUpdateOneWithoutSponsorsInput
    id: ClearStringFieldUpdateOperationsInput
    link: ClearNullableStringFieldUpdateOperationsInput
    logoImageUri: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    perks: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearSponsorUpdateManyMutationInput {
    amount: ClearIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    darkLogoImageUri: ClearNullableStringFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    link: ClearNullableStringFieldUpdateOperationsInput
    logoImageUri: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    perks: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearSponsorUpdateManyWithWhereWithoutEventInput {
    data: ClearSponsorUpdateManyMutationInput!
    where: ClearSponsorScalarWhereInput!
}

input ClearSponsorUpdateManyWithoutEventInput {
    connect: [ClearSponsorWhereUniqueInput!]
    connectOrCreate: [ClearSponsorCreateOrConnectWithoutEventInput!]
    create: [ClearSponsorCreateWithoutEventInput!]
    createMany: ClearSponsorCreateManyEventInputEnvelope
    delete: [ClearSponsorWhereUniqueInput!]
    deleteMany: [ClearSponsorScalarWhereInput!]
    disconnect: [ClearSponsorWhereUniqueInput!]
    set: [ClearSponsorWhereUniqueInput!]
    update: [ClearSponsorUpdateWithWhereUniqueWithoutEventInput!]
    updateMany: [ClearSponsorUpdateManyWithWhereWithoutEventInput!]
    upsert: [ClearSponsorUpsertWithWhereUniqueWithoutEventInput!]
}

input ClearSponsorUpdateWithWhereUniqueWithoutEventInput {
    data: ClearSponsorUpdateWithoutEventInput!
    where: ClearSponsorWhereUniqueInput!
}

input ClearSponsorUpdateWithoutEventInput {
    amount: ClearIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    darkLogoImageUri: ClearNullableStringFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    link: ClearNullableStringFieldUpdateOperationsInput
    logoImageUri: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    perks: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearSponsorUpsertWithWhereUniqueWithoutEventInput {
    create: ClearSponsorCreateWithoutEventInput!
    update: ClearSponsorUpdateWithoutEventInput!
    where: ClearSponsorWhereUniqueInput!
}

input ClearSponsorWhereInput {
    AND: [ClearSponsorWhereInput!]
    NOT: [ClearSponsorWhereInput!]
    OR: [ClearSponsorWhereInput!]
    amount: ClearIntFilter
    contactEmail: ClearStringNullableFilter
    contactName: ClearStringNullableFilter
    contactPhone: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    darkLogoImageUri: ClearStringNullableFilter
    description: ClearStringNullableFilter
    event: ClearEventRelationFilter
    eventId: ClearStringNullableFilter
    id: ClearStringFilter
    link: ClearStringNullableFilter
    logoImageUri: ClearStringNullableFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    perks: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
}

input ClearSponsorWhereUniqueInput {
    id: String
}

input ClearStringFieldUpdateOperationsInput {
    set: String
}

input ClearStringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: ClearQueryMode
    not: ClearNestedStringFilter
    notIn: [String!]
    startsWith: String
}

input ClearStringNullableFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: ClearQueryMode
    not: ClearNestedStringNullableFilter
    notIn: [String!]
    startsWith: String
}

input ClearStringNullableListFilter {
    equals: [String!]
    has: String
    hasEvery: [String!]
    hasSome: [String!]
    isEmpty: Boolean
}

input ClearStringNullableWithAggregatesFilter {
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedStringNullableFilter
    _min: ClearNestedStringNullableFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: ClearQueryMode
    not: ClearNestedStringNullableWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input ClearStringWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedStringFilter
    _min: ClearNestedStringFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: ClearQueryMode
    not: ClearNestedStringWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input ClearTicketAvgOrderByAggregateInput {
    age: ClearSortOrder
}

input ClearTicketCountOrderByAggregateInput {
    age: ClearSortOrder
    couponCode: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    eventId: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    paymentId: ClearSortOrder
    personId: ClearSortOrder
    phone: ClearSortOrder
    promoCodeId: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    waiverSigned: ClearSortOrder
}

input ClearTicketCreateInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    event: ClearEventCreateNestedOneWithoutTicketsInput!
    firstName: String!
    guardian: ClearPersonCreateNestedOneWithoutTicketInput
    id: String
    lastName: String!
    metadata: ClearJSON
    payment: ClearPaymentCreateNestedOneWithoutTicketsInput
    phone: String
    promoCode: ClearPromoCodeCreateNestedOneWithoutTicketsInput
    sentEmails: ClearEmailTemplateCreateNestedManyWithoutSentToInput
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateManyEventInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    paymentId: String
    personId: String
    phone: String
    promoCodeId: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateManyEventInputEnvelope {
    data: [ClearTicketCreateManyEventInput!]!
    skipDuplicates: Boolean
}

input ClearTicketCreateManyGuardianInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    eventId: String!
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    paymentId: String
    phone: String
    promoCodeId: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateManyGuardianInputEnvelope {
    data: [ClearTicketCreateManyGuardianInput!]!
    skipDuplicates: Boolean
}

input ClearTicketCreateManyInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    eventId: String!
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    paymentId: String
    personId: String
    phone: String
    promoCodeId: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateManyPaymentInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    eventId: String!
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    personId: String
    phone: String
    promoCodeId: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateManyPaymentInputEnvelope {
    data: [ClearTicketCreateManyPaymentInput!]!
    skipDuplicates: Boolean
}

input ClearTicketCreateManyPromoCodeInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    eventId: String!
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    paymentId: String
    personId: String
    phone: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateManyPromoCodeInputEnvelope {
    data: [ClearTicketCreateManyPromoCodeInput!]!
    skipDuplicates: Boolean
}

input ClearTicketCreateNestedManyWithoutEventInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutEventInput!]
    create: [ClearTicketCreateWithoutEventInput!]
    createMany: ClearTicketCreateManyEventInputEnvelope
}

input ClearTicketCreateNestedManyWithoutGuardianInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutGuardianInput!]
    create: [ClearTicketCreateWithoutGuardianInput!]
    createMany: ClearTicketCreateManyGuardianInputEnvelope
}

input ClearTicketCreateNestedManyWithoutPaymentInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutPaymentInput!]
    create: [ClearTicketCreateWithoutPaymentInput!]
    createMany: ClearTicketCreateManyPaymentInputEnvelope
}

input ClearTicketCreateNestedManyWithoutPromoCodeInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutPromoCodeInput!]
    create: [ClearTicketCreateWithoutPromoCodeInput!]
    createMany: ClearTicketCreateManyPromoCodeInputEnvelope
}

input ClearTicketCreateNestedManyWithoutSentEmailsInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutSentEmailsInput!]
    create: [ClearTicketCreateWithoutSentEmailsInput!]
}

input ClearTicketCreateOrConnectWithoutEventInput {
    create: ClearTicketCreateWithoutEventInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketCreateOrConnectWithoutGuardianInput {
    create: ClearTicketCreateWithoutGuardianInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketCreateOrConnectWithoutPaymentInput {
    create: ClearTicketCreateWithoutPaymentInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketCreateOrConnectWithoutPromoCodeInput {
    create: ClearTicketCreateWithoutPromoCodeInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketCreateOrConnectWithoutSentEmailsInput {
    create: ClearTicketCreateWithoutSentEmailsInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketCreateWithoutEventInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    firstName: String!
    guardian: ClearPersonCreateNestedOneWithoutTicketInput
    id: String
    lastName: String!
    metadata: ClearJSON
    payment: ClearPaymentCreateNestedOneWithoutTicketsInput
    phone: String
    promoCode: ClearPromoCodeCreateNestedOneWithoutTicketsInput
    sentEmails: ClearEmailTemplateCreateNestedManyWithoutSentToInput
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateWithoutGuardianInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    event: ClearEventCreateNestedOneWithoutTicketsInput!
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    payment: ClearPaymentCreateNestedOneWithoutTicketsInput
    phone: String
    promoCode: ClearPromoCodeCreateNestedOneWithoutTicketsInput
    sentEmails: ClearEmailTemplateCreateNestedManyWithoutSentToInput
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateWithoutPaymentInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    event: ClearEventCreateNestedOneWithoutTicketsInput!
    firstName: String!
    guardian: ClearPersonCreateNestedOneWithoutTicketInput
    id: String
    lastName: String!
    metadata: ClearJSON
    phone: String
    promoCode: ClearPromoCodeCreateNestedOneWithoutTicketsInput
    sentEmails: ClearEmailTemplateCreateNestedManyWithoutSentToInput
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateWithoutPromoCodeInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    event: ClearEventCreateNestedOneWithoutTicketsInput!
    firstName: String!
    guardian: ClearPersonCreateNestedOneWithoutTicketInput
    id: String
    lastName: String!
    metadata: ClearJSON
    payment: ClearPaymentCreateNestedOneWithoutTicketsInput
    phone: String
    sentEmails: ClearEmailTemplateCreateNestedManyWithoutSentToInput
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateWithoutSentEmailsInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    event: ClearEventCreateNestedOneWithoutTicketsInput!
    firstName: String!
    guardian: ClearPersonCreateNestedOneWithoutTicketInput
    id: String
    lastName: String!
    metadata: ClearJSON
    payment: ClearPaymentCreateNestedOneWithoutTicketsInput
    phone: String
    promoCode: ClearPromoCodeCreateNestedOneWithoutTicketsInput
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketListRelationFilter {
    every: ClearTicketWhereInput
    none: ClearTicketWhereInput
    some: ClearTicketWhereInput
}

input ClearTicketMaxOrderByAggregateInput {
    age: ClearSortOrder
    couponCode: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    eventId: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    paymentId: ClearSortOrder
    personId: ClearSortOrder
    phone: ClearSortOrder
    promoCodeId: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    waiverSigned: ClearSortOrder
}

input ClearTicketMinOrderByAggregateInput {
    age: ClearSortOrder
    couponCode: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    eventId: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    paymentId: ClearSortOrder
    personId: ClearSortOrder
    phone: ClearSortOrder
    promoCodeId: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    waiverSigned: ClearSortOrder
}

input ClearTicketOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearTicketOrderByWithAggregationInput {
    _avg: ClearTicketAvgOrderByAggregateInput
    _count: ClearTicketCountOrderByAggregateInput
    _max: ClearTicketMaxOrderByAggregateInput
    _min: ClearTicketMinOrderByAggregateInput
    _sum: ClearTicketSumOrderByAggregateInput
    age: ClearSortOrder
    couponCode: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    eventId: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    paymentId: ClearSortOrder
    personId: ClearSortOrder
    phone: ClearSortOrder
    promoCodeId: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    waiverSigned: ClearSortOrder
}

input ClearTicketOrderByWithRelationInput {
    age: ClearSortOrder
    couponCode: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    event: ClearEventOrderByWithRelationInput
    eventId: ClearSortOrder
    firstName: ClearSortOrder
    guardian: ClearPersonOrderByWithRelationInput
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    payment: ClearPaymentOrderByWithRelationInput
    paymentId: ClearSortOrder
    personId: ClearSortOrder
    phone: ClearSortOrder
    promoCode: ClearPromoCodeOrderByWithRelationInput
    promoCodeId: ClearSortOrder
    sentEmails: ClearEmailTemplateOrderByRelationAggregateInput
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    waiverSigned: ClearSortOrder
}

input ClearTicketScalarWhereInput {
    AND: [ClearTicketScalarWhereInput!]
    NOT: [ClearTicketScalarWhereInput!]
    OR: [ClearTicketScalarWhereInput!]
    age: ClearIntNullableFilter
    couponCode: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    email: ClearStringNullableFilter
    eventId: ClearStringFilter
    firstName: ClearStringFilter
    id: ClearStringFilter
    lastName: ClearStringFilter
    metadata: ClearJsonNullableFilter
    paymentId: ClearStringNullableFilter
    personId: ClearStringNullableFilter
    phone: ClearStringNullableFilter
    promoCodeId: ClearStringNullableFilter
    type: ClearEnumTicketTypeFilter
    updatedAt: ClearDateTimeFilter
    waiverSigned: ClearBoolFilter
}

input ClearTicketScalarWhereWithAggregatesInput {
    AND: [ClearTicketScalarWhereWithAggregatesInput!]
    NOT: [ClearTicketScalarWhereWithAggregatesInput!]
    OR: [ClearTicketScalarWhereWithAggregatesInput!]
    age: ClearIntNullableWithAggregatesFilter
    couponCode: ClearStringNullableWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    email: ClearStringNullableWithAggregatesFilter
    eventId: ClearStringWithAggregatesFilter
    firstName: ClearStringWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    lastName: ClearStringWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    paymentId: ClearStringNullableWithAggregatesFilter
    personId: ClearStringNullableWithAggregatesFilter
    phone: ClearStringNullableWithAggregatesFilter
    promoCodeId: ClearStringNullableWithAggregatesFilter
    type: ClearEnumTicketTypeWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
    waiverSigned: ClearBoolWithAggregatesFilter
}

input ClearTicketSumOrderByAggregateInput {
    age: ClearSortOrder
}

input ClearTicketUpdateInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    event: ClearEventUpdateOneRequiredWithoutTicketsInput
    firstName: ClearStringFieldUpdateOperationsInput
    guardian: ClearPersonUpdateOneWithoutTicketInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    payment: ClearPaymentUpdateOneWithoutTicketsInput
    phone: ClearNullableStringFieldUpdateOperationsInput
    promoCode: ClearPromoCodeUpdateOneWithoutTicketsInput
    sentEmails: ClearEmailTemplateUpdateManyWithoutSentToInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpdateManyMutationInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    firstName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    phone: ClearNullableStringFieldUpdateOperationsInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpdateManyWithWhereWithoutEventInput {
    data: ClearTicketUpdateManyMutationInput!
    where: ClearTicketScalarWhereInput!
}

input ClearTicketUpdateManyWithWhereWithoutGuardianInput {
    data: ClearTicketUpdateManyMutationInput!
    where: ClearTicketScalarWhereInput!
}

input ClearTicketUpdateManyWithWhereWithoutPaymentInput {
    data: ClearTicketUpdateManyMutationInput!
    where: ClearTicketScalarWhereInput!
}

input ClearTicketUpdateManyWithWhereWithoutPromoCodeInput {
    data: ClearTicketUpdateManyMutationInput!
    where: ClearTicketScalarWhereInput!
}

input ClearTicketUpdateManyWithWhereWithoutSentEmailsInput {
    data: ClearTicketUpdateManyMutationInput!
    where: ClearTicketScalarWhereInput!
}

input ClearTicketUpdateManyWithoutEventInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutEventInput!]
    create: [ClearTicketCreateWithoutEventInput!]
    createMany: ClearTicketCreateManyEventInputEnvelope
    delete: [ClearTicketWhereUniqueInput!]
    deleteMany: [ClearTicketScalarWhereInput!]
    disconnect: [ClearTicketWhereUniqueInput!]
    set: [ClearTicketWhereUniqueInput!]
    update: [ClearTicketUpdateWithWhereUniqueWithoutEventInput!]
    updateMany: [ClearTicketUpdateManyWithWhereWithoutEventInput!]
    upsert: [ClearTicketUpsertWithWhereUniqueWithoutEventInput!]
}

input ClearTicketUpdateManyWithoutGuardianInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutGuardianInput!]
    create: [ClearTicketCreateWithoutGuardianInput!]
    createMany: ClearTicketCreateManyGuardianInputEnvelope
    delete: [ClearTicketWhereUniqueInput!]
    deleteMany: [ClearTicketScalarWhereInput!]
    disconnect: [ClearTicketWhereUniqueInput!]
    set: [ClearTicketWhereUniqueInput!]
    update: [ClearTicketUpdateWithWhereUniqueWithoutGuardianInput!]
    updateMany: [ClearTicketUpdateManyWithWhereWithoutGuardianInput!]
    upsert: [ClearTicketUpsertWithWhereUniqueWithoutGuardianInput!]
}

input ClearTicketUpdateManyWithoutPaymentInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutPaymentInput!]
    create: [ClearTicketCreateWithoutPaymentInput!]
    createMany: ClearTicketCreateManyPaymentInputEnvelope
    delete: [ClearTicketWhereUniqueInput!]
    deleteMany: [ClearTicketScalarWhereInput!]
    disconnect: [ClearTicketWhereUniqueInput!]
    set: [ClearTicketWhereUniqueInput!]
    update: [ClearTicketUpdateWithWhereUniqueWithoutPaymentInput!]
    updateMany: [ClearTicketUpdateManyWithWhereWithoutPaymentInput!]
    upsert: [ClearTicketUpsertWithWhereUniqueWithoutPaymentInput!]
}

input ClearTicketUpdateManyWithoutPromoCodeInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutPromoCodeInput!]
    create: [ClearTicketCreateWithoutPromoCodeInput!]
    createMany: ClearTicketCreateManyPromoCodeInputEnvelope
    delete: [ClearTicketWhereUniqueInput!]
    deleteMany: [ClearTicketScalarWhereInput!]
    disconnect: [ClearTicketWhereUniqueInput!]
    set: [ClearTicketWhereUniqueInput!]
    update: [ClearTicketUpdateWithWhereUniqueWithoutPromoCodeInput!]
    updateMany: [ClearTicketUpdateManyWithWhereWithoutPromoCodeInput!]
    upsert: [ClearTicketUpsertWithWhereUniqueWithoutPromoCodeInput!]
}

input ClearTicketUpdateManyWithoutSentEmailsInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutSentEmailsInput!]
    create: [ClearTicketCreateWithoutSentEmailsInput!]
    delete: [ClearTicketWhereUniqueInput!]
    deleteMany: [ClearTicketScalarWhereInput!]
    disconnect: [ClearTicketWhereUniqueInput!]
    set: [ClearTicketWhereUniqueInput!]
    update: [ClearTicketUpdateWithWhereUniqueWithoutSentEmailsInput!]
    updateMany: [ClearTicketUpdateManyWithWhereWithoutSentEmailsInput!]
    upsert: [ClearTicketUpsertWithWhereUniqueWithoutSentEmailsInput!]
}

input ClearTicketUpdateWithWhereUniqueWithoutEventInput {
    data: ClearTicketUpdateWithoutEventInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpdateWithWhereUniqueWithoutGuardianInput {
    data: ClearTicketUpdateWithoutGuardianInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpdateWithWhereUniqueWithoutPaymentInput {
    data: ClearTicketUpdateWithoutPaymentInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpdateWithWhereUniqueWithoutPromoCodeInput {
    data: ClearTicketUpdateWithoutPromoCodeInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpdateWithWhereUniqueWithoutSentEmailsInput {
    data: ClearTicketUpdateWithoutSentEmailsInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpdateWithoutEventInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    firstName: ClearStringFieldUpdateOperationsInput
    guardian: ClearPersonUpdateOneWithoutTicketInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    payment: ClearPaymentUpdateOneWithoutTicketsInput
    phone: ClearNullableStringFieldUpdateOperationsInput
    promoCode: ClearPromoCodeUpdateOneWithoutTicketsInput
    sentEmails: ClearEmailTemplateUpdateManyWithoutSentToInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpdateWithoutGuardianInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    event: ClearEventUpdateOneRequiredWithoutTicketsInput
    firstName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    payment: ClearPaymentUpdateOneWithoutTicketsInput
    phone: ClearNullableStringFieldUpdateOperationsInput
    promoCode: ClearPromoCodeUpdateOneWithoutTicketsInput
    sentEmails: ClearEmailTemplateUpdateManyWithoutSentToInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpdateWithoutPaymentInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    event: ClearEventUpdateOneRequiredWithoutTicketsInput
    firstName: ClearStringFieldUpdateOperationsInput
    guardian: ClearPersonUpdateOneWithoutTicketInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    phone: ClearNullableStringFieldUpdateOperationsInput
    promoCode: ClearPromoCodeUpdateOneWithoutTicketsInput
    sentEmails: ClearEmailTemplateUpdateManyWithoutSentToInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpdateWithoutPromoCodeInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    event: ClearEventUpdateOneRequiredWithoutTicketsInput
    firstName: ClearStringFieldUpdateOperationsInput
    guardian: ClearPersonUpdateOneWithoutTicketInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    payment: ClearPaymentUpdateOneWithoutTicketsInput
    phone: ClearNullableStringFieldUpdateOperationsInput
    sentEmails: ClearEmailTemplateUpdateManyWithoutSentToInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpdateWithoutSentEmailsInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    event: ClearEventUpdateOneRequiredWithoutTicketsInput
    firstName: ClearStringFieldUpdateOperationsInput
    guardian: ClearPersonUpdateOneWithoutTicketInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    payment: ClearPaymentUpdateOneWithoutTicketsInput
    phone: ClearNullableStringFieldUpdateOperationsInput
    promoCode: ClearPromoCodeUpdateOneWithoutTicketsInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpsertWithWhereUniqueWithoutEventInput {
    create: ClearTicketCreateWithoutEventInput!
    update: ClearTicketUpdateWithoutEventInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpsertWithWhereUniqueWithoutGuardianInput {
    create: ClearTicketCreateWithoutGuardianInput!
    update: ClearTicketUpdateWithoutGuardianInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpsertWithWhereUniqueWithoutPaymentInput {
    create: ClearTicketCreateWithoutPaymentInput!
    update: ClearTicketUpdateWithoutPaymentInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpsertWithWhereUniqueWithoutPromoCodeInput {
    create: ClearTicketCreateWithoutPromoCodeInput!
    update: ClearTicketUpdateWithoutPromoCodeInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpsertWithWhereUniqueWithoutSentEmailsInput {
    create: ClearTicketCreateWithoutSentEmailsInput!
    update: ClearTicketUpdateWithoutSentEmailsInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketWhereInput {
    AND: [ClearTicketWhereInput!]
    NOT: [ClearTicketWhereInput!]
    OR: [ClearTicketWhereInput!]
    age: ClearIntNullableFilter
    couponCode: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    email: ClearStringNullableFilter
    event: ClearEventRelationFilter
    eventId: ClearStringFilter
    firstName: ClearStringFilter
    guardian: ClearPersonRelationFilter
    id: ClearStringFilter
    lastName: ClearStringFilter
    metadata: ClearJsonNullableFilter
    payment: ClearPaymentRelationFilter
    paymentId: ClearStringNullableFilter
    personId: ClearStringNullableFilter
    phone: ClearStringNullableFilter
    promoCode: ClearPromoCodeRelationFilter
    promoCodeId: ClearStringNullableFilter
    sentEmails: ClearEmailTemplateListRelationFilter
    type: ClearEnumTicketTypeFilter
    updatedAt: ClearDateTimeFilter
    waiverSigned: ClearBoolFilter
}

input ClearTicketWhereUniqueInput {
    id: String
}

input ClearVenueAvgOrderByAggregateInput {
    capacity: ClearSortOrder
}

input ClearVenueCountOrderByAggregateInput {
    address: ClearSortOrder
    capacity: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    mapLink: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearVenueCreateInput {
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    events: ClearEventCreateNestedManyWithoutVenueInput
    id: String
    mapLink: String
    metadata: ClearJSON
    name: String!
    updatedAt: ClearDateTime
}

input ClearVenueCreateManyInput {
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    id: String
    mapLink: String
    metadata: ClearJSON
    name: String!
    updatedAt: ClearDateTime
}

input ClearVenueCreateNestedOneWithoutEventsInput {
    connect: ClearVenueWhereUniqueInput
    connectOrCreate: ClearVenueCreateOrConnectWithoutEventsInput
    create: ClearVenueCreateWithoutEventsInput
}

input ClearVenueCreateOrConnectWithoutEventsInput {
    create: ClearVenueCreateWithoutEventsInput!
    where: ClearVenueWhereUniqueInput!
}

input ClearVenueCreateWithoutEventsInput {
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    id: String
    mapLink: String
    metadata: ClearJSON
    name: String!
    updatedAt: ClearDateTime
}

input ClearVenueMaxOrderByAggregateInput {
    address: ClearSortOrder
    capacity: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    mapLink: ClearSortOrder
    name: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearVenueMinOrderByAggregateInput {
    address: ClearSortOrder
    capacity: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    mapLink: ClearSortOrder
    name: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearVenueOrderByWithAggregationInput {
    _avg: ClearVenueAvgOrderByAggregateInput
    _count: ClearVenueCountOrderByAggregateInput
    _max: ClearVenueMaxOrderByAggregateInput
    _min: ClearVenueMinOrderByAggregateInput
    _sum: ClearVenueSumOrderByAggregateInput
    address: ClearSortOrder
    capacity: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    mapLink: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearVenueOrderByWithRelationInput {
    address: ClearSortOrder
    capacity: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    events: ClearEventOrderByRelationAggregateInput
    id: ClearSortOrder
    mapLink: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearVenueRelationFilter {
    is: ClearVenueWhereInput
    isNot: ClearVenueWhereInput
}

input ClearVenueScalarWhereWithAggregatesInput {
    AND: [ClearVenueScalarWhereWithAggregatesInput!]
    NOT: [ClearVenueScalarWhereWithAggregatesInput!]
    OR: [ClearVenueScalarWhereWithAggregatesInput!]
    address: ClearStringNullableWithAggregatesFilter
    capacity: ClearIntNullableWithAggregatesFilter
    contactEmail: ClearStringNullableWithAggregatesFilter
    contactName: ClearStringNullableWithAggregatesFilter
    contactPhone: ClearStringNullableWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    mapLink: ClearStringNullableWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearVenueSumOrderByAggregateInput {
    capacity: ClearSortOrder
}

input ClearVenueUpdateInput {
    address: ClearNullableStringFieldUpdateOperationsInput
    capacity: ClearNullableIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    events: ClearEventUpdateManyWithoutVenueInput
    id: ClearStringFieldUpdateOperationsInput
    mapLink: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearVenueUpdateManyMutationInput {
    address: ClearNullableStringFieldUpdateOperationsInput
    capacity: ClearNullableIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    mapLink: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearVenueUpdateOneWithoutEventsInput {
    connect: ClearVenueWhereUniqueInput
    connectOrCreate: ClearVenueCreateOrConnectWithoutEventsInput
    create: ClearVenueCreateWithoutEventsInput
    delete: Boolean
    disconnect: Boolean
    update: ClearVenueUpdateWithoutEventsInput
    upsert: ClearVenueUpsertWithoutEventsInput
}

input ClearVenueUpdateWithoutEventsInput {
    address: ClearNullableStringFieldUpdateOperationsInput
    capacity: ClearNullableIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    mapLink: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearVenueUpsertWithoutEventsInput {
    create: ClearVenueCreateWithoutEventsInput!
    update: ClearVenueUpdateWithoutEventsInput!
}

input ClearVenueWhereInput {
    AND: [ClearVenueWhereInput!]
    NOT: [ClearVenueWhereInput!]
    OR: [ClearVenueWhereInput!]
    address: ClearStringNullableFilter
    capacity: ClearIntNullableFilter
    contactEmail: ClearStringNullableFilter
    contactName: ClearStringNullableFilter
    contactPhone: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    events: ClearEventListRelationFilter
    id: ClearStringFilter
    mapLink: ClearStringNullableFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    updatedAt: ClearDateTimeFilter
}

input ClearVenueWhereUniqueInput {
    id: String
}

input CmsAnnouncementFilter {
    AND: [CmsAnnouncementFilter]
    OR: [CmsAnnouncementFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    displayAt: CmsDateTime
    displayAt_exists: Boolean
    displayAt_gt: CmsDateTime
    displayAt_gte: CmsDateTime
    displayAt_in: [CmsDateTime]
    displayAt_lt: CmsDateTime
    displayAt_lte: CmsDateTime
    displayAt_not: CmsDateTime
    displayAt_not_in: [CmsDateTime]
    endAt: CmsDateTime
    endAt_exists: Boolean
    endAt_gt: CmsDateTime
    endAt_gte: CmsDateTime
    endAt_in: [CmsDateTime]
    endAt_lt: CmsDateTime
    endAt_lte: CmsDateTime
    endAt_not: CmsDateTime
    endAt_not_in: [CmsDateTime]
    link: String
    link_contains: String
    link_exists: Boolean
    link_in: [String]
    link_not: String
    link_not_contains: String
    link_not_in: [String]
    oneline: String
    oneline_contains: String
    oneline_exists: Boolean
    oneline_in: [String]
    oneline_not: String
    oneline_not_contains: String
    oneline_not_in: [String]
    programCollection_exists: Boolean
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
    visibility: String
    visibility_contains: String
    visibility_exists: Boolean
    visibility_in: [String]
    visibility_not: String
    visibility_not_contains: String
    visibility_not_in: [String]
}

input CmsAssetFilter {
    AND: [CmsAssetFilter]
    OR: [CmsAssetFilter]
    contentType: String
    contentType_contains: String
    contentType_exists: Boolean
    contentType_in: [String]
    contentType_not: String
    contentType_not_contains: String
    contentType_not_in: [String]
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    fileName: String
    fileName_contains: String
    fileName_exists: Boolean
    fileName_in: [String]
    fileName_not: String
    fileName_not_contains: String
    fileName_not_in: [String]
    height: Int
    height_exists: Boolean
    height_gt: Int
    height_gte: Int
    height_in: [Int]
    height_lt: Int
    height_lte: Int
    height_not: Int
    height_not_in: [Int]
    size: Int
    size_exists: Boolean
    size_gt: Int
    size_gte: Int
    size_in: [Int]
    size_lt: Int
    size_lte: Int
    size_not: Int
    size_not_in: [Int]
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
    width: Int
    width_exists: Boolean
    width_gt: Int
    width_gte: Int
    width_in: [Int]
    width_lt: Int
    width_lte: Int
    width_not: Int
    width_not_in: [Int]
}

input CmsAwardFilter {
    AND: [CmsAwardFilter]
    OR: [CmsAwardFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    icon_exists: Boolean
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    programsCollection_exists: Boolean
    ranking: Int
    ranking_exists: Boolean
    ranking_gt: Int
    ranking_gte: Int
    ranking_in: [Int]
    ranking_lt: Int
    ranking_lte: Int
    ranking_not: Int
    ranking_not_in: [Int]
    sys: CmsSysFilter
}

input CmsBadgeFilter {
    AND: [CmsBadgeFilter]
    OR: [CmsBadgeFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    earnCriteria: String
    earnCriteria_contains: String
    earnCriteria_exists: Boolean
    earnCriteria_in: [String]
    earnCriteria_not: String
    earnCriteria_not_contains: String
    earnCriteria_not_in: [String]
    earnMessage: String
    earnMessage_contains: String
    earnMessage_exists: Boolean
    earnMessage_in: [String]
    earnMessage_not: String
    earnMessage_not_contains: String
    earnMessage_not_in: [String]
    emoji: String
    emoji_contains: String
    emoji_exists: Boolean
    emoji_in: [String]
    emoji_not: String
    emoji_not_contains: String
    emoji_not_in: [String]
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    image_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    sys: CmsSysFilter
}

input CmsBumperFilter {
    AND: [CmsBumperFilter]
    OR: [CmsBumperFilter]
    ambient: Boolean
    ambient_exists: Boolean
    ambient_not: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    purpose_contains_all: [String]
    purpose_contains_none: [String]
    purpose_contains_some: [String]
    purpose_exists: Boolean
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmsCommunityPartnerFilter {
    AND: [CmsCommunityPartnerFilter]
    OR: [CmsCommunityPartnerFilter]
    audience_contains_all: [String]
    audience_contains_none: [String]
    audience_contains_some: [String]
    audience_exists: Boolean
    blurb: String
    blurb_contains: String
    blurb_exists: Boolean
    blurb_in: [String]
    blurb_not: String
    blurb_not_contains: String
    blurb_not_in: [String]
    contentfulMetadata: CmsContentfulMetadataFilter
    cost: Int
    cost_exists: Boolean
    cost_gt: Int
    cost_gte: Int
    cost_in: [Int]
    cost_lt: Int
    cost_lte: Int
    cost_not: Int
    cost_not_in: [Int]
    details: String
    details_contains: String
    details_exists: Boolean
    details_in: [String]
    details_not: String
    details_not_contains: String
    details_not_in: [String]
    displayUrl: String
    displayUrl_contains: String
    displayUrl_exists: Boolean
    displayUrl_in: [String]
    displayUrl_not: String
    displayUrl_not_contains: String
    displayUrl_not_in: [String]
    eligibility: String
    eligibility_contains: String
    eligibility_exists: Boolean
    eligibility_in: [String]
    eligibility_not: String
    eligibility_not_contains: String
    eligibility_not_in: [String]
    expires: CmsDateTime
    expires_exists: Boolean
    expires_gt: CmsDateTime
    expires_gte: CmsDateTime
    expires_in: [CmsDateTime]
    expires_lt: CmsDateTime
    expires_lte: CmsDateTime
    expires_not: CmsDateTime
    expires_not_in: [CmsDateTime]
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    regionCollection_exists: Boolean
    sys: CmsSysFilter
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
}

input CmsContentTypeStringFilter {
    AND: [CmsContentTypeStringFilter]
    OR: [CmsContentTypeStringFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    key: String
    key_contains: String
    key_exists: Boolean
    key_in: [String]
    key_not: String
    key_not_contains: String
    key_not_in: [String]
    richValue_contains: String
    richValue_exists: Boolean
    richValue_not_contains: String
    subvalueCollection_exists: Boolean
    sys: CmsSysFilter
    value: String
    value_contains: String
    value_exists: Boolean
    value_in: [String]
    value_not: String
    value_not_contains: String
    value_not_in: [String]
}

input CmsContentfulMetadataFilter {
    tags: CmsContentfulMetadataTagsFilter
    tags_exists: Boolean
}

input CmsContentfulMetadataTagsFilter {
    id_contains_all: [String]
    id_contains_none: [String]
    id_contains_some: [String]
}

input CmsEntryFilter {
    AND: [CmsEntryFilter]
    OR: [CmsEntryFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    sys: CmsSysFilter
}

input CmsEventFilter {
    AND: [CmsEventFilter]
    OR: [CmsEventFilter]
    awardsAt: CmsDateTime
    awardsAt_exists: Boolean
    awardsAt_gt: CmsDateTime
    awardsAt_gte: CmsDateTime
    awardsAt_in: [CmsDateTime]
    awardsAt_lt: CmsDateTime
    awardsAt_lte: CmsDateTime
    awardsAt_not: CmsDateTime
    awardsAt_not_in: [CmsDateTime]
    calendarReleaseDate: CmsDateTime
    calendarReleaseDate_exists: Boolean
    calendarReleaseDate_gt: CmsDateTime
    calendarReleaseDate_gte: CmsDateTime
    calendarReleaseDate_in: [CmsDateTime]
    calendarReleaseDate_lt: CmsDateTime
    calendarReleaseDate_lte: CmsDateTime
    calendarReleaseDate_not: CmsDateTime
    calendarReleaseDate_not_in: [CmsDateTime]
    contentfulMetadata: CmsContentfulMetadataFilter
    endsAt: CmsDateTime
    endsAt_exists: Boolean
    endsAt_gt: CmsDateTime
    endsAt_gte: CmsDateTime
    endsAt_in: [CmsDateTime]
    endsAt_lt: CmsDateTime
    endsAt_lte: CmsDateTime
    endsAt_not: CmsDateTime
    endsAt_not_in: [CmsDateTime]
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    kickoffVideoCaptions_exists: Boolean
    kickoffVideo_exists: Boolean
    notice_contains: String
    notice_exists: Boolean
    notice_not_contains: String
    participantRoleId: String
    participantRoleId_contains: String
    participantRoleId_exists: Boolean
    participantRoleId_in: [String]
    participantRoleId_not: String
    participantRoleId_not_contains: String
    participantRoleId_not_in: [String]
    postersCollection_exists: Boolean
    program: CmscfProgramNestedFilter
    program_exists: Boolean
    registrationsCloseAt: CmsDateTime
    registrationsCloseAt_exists: Boolean
    registrationsCloseAt_gt: CmsDateTime
    registrationsCloseAt_gte: CmsDateTime
    registrationsCloseAt_in: [CmsDateTime]
    registrationsCloseAt_lt: CmsDateTime
    registrationsCloseAt_lte: CmsDateTime
    registrationsCloseAt_not: CmsDateTime
    registrationsCloseAt_not_in: [CmsDateTime]
    registrationsOpenAt: CmsDateTime
    registrationsOpenAt_exists: Boolean
    registrationsOpenAt_gt: CmsDateTime
    registrationsOpenAt_gte: CmsDateTime
    registrationsOpenAt_in: [CmsDateTime]
    registrationsOpenAt_lt: CmsDateTime
    registrationsOpenAt_lte: CmsDateTime
    registrationsOpenAt_not: CmsDateTime
    registrationsOpenAt_not_in: [CmsDateTime]
    startsAt: CmsDateTime
    startsAt_exists: Boolean
    startsAt_gt: CmsDateTime
    startsAt_gte: CmsDateTime
    startsAt_in: [CmsDateTime]
    startsAt_lt: CmsDateTime
    startsAt_lte: CmsDateTime
    startsAt_not: CmsDateTime
    startsAt_not_in: [CmsDateTime]
    statEventCount: Int
    statEventCount_exists: Boolean
    statEventCount_gt: Int
    statEventCount_gte: Int
    statEventCount_in: [Int]
    statEventCount_lt: Int
    statEventCount_lte: Int
    statEventCount_not: Int
    statEventCount_not_in: [Int]
    statLowInterestContinuedCount: Int
    statLowInterestContinuedCount_exists: Boolean
    statLowInterestContinuedCount_gt: Int
    statLowInterestContinuedCount_gte: Int
    statLowInterestContinuedCount_in: [Int]
    statLowInterestContinuedCount_lt: Int
    statLowInterestContinuedCount_lte: Int
    statLowInterestContinuedCount_not: Int
    statLowInterestContinuedCount_not_in: [Int]
    statLowInterestCount: Int
    statLowInterestCount_exists: Boolean
    statLowInterestCount_gt: Int
    statLowInterestCount_gte: Int
    statLowInterestCount_in: [Int]
    statLowInterestCount_lt: Int
    statLowInterestCount_lte: Int
    statLowInterestCount_not: Int
    statLowInterestCount_not_in: [Int]
    statStudentCount: Int
    statStudentCount_exists: Boolean
    statStudentCount_gt: Int
    statStudentCount_gte: Int
    statStudentCount_in: [Int]
    statStudentCount_lt: Int
    statStudentCount_lte: Int
    statStudentCount_not: Int
    statStudentCount_not_in: [Int]
    sys: CmsSysFilter
    theme: String
    themeBackgroundsCollection_exists: Boolean
    themeLogoBackgroundsCollection_exists: Boolean
    theme_contains: String
    theme_exists: Boolean
    theme_in: [String]
    theme_not: String
    theme_not_contains: String
    theme_not_in: [String]
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmsFaqFilter {
    AND: [CmsFaqFilter]
    OR: [CmsFaqFilter]
    answer_contains: String
    answer_exists: Boolean
    answer_not_contains: String
    audience_contains_all: [String]
    audience_contains_none: [String]
    audience_contains_some: [String]
    audience_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    featured: Boolean
    featured_exists: Boolean
    featured_not: Boolean
    program: CmscfProgramNestedFilter
    program_exists: Boolean
    relatedAnswersCollection_exists: Boolean
    sys: CmsSysFilter
    tags_contains_all: [String]
    tags_contains_none: [String]
    tags_contains_some: [String]
    tags_exists: Boolean
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmsFormFilter {
    AND: [CmsFormFilter]
    OR: [CmsFormFilter]
    cognitoForm: Int
    cognitoForm_exists: Boolean
    cognitoForm_gt: Int
    cognitoForm_gte: Int
    cognitoForm_in: [Int]
    cognitoForm_lt: Int
    cognitoForm_lte: Int
    cognitoForm_not: Int
    cognitoForm_not_in: [Int]
    contentfulMetadata: CmsContentfulMetadataFilter
    details_contains: String
    details_exists: Boolean
    details_not_contains: String
    image_exists: Boolean
    sidebar_contains: String
    sidebar_exists: Boolean
    sidebar_not_contains: String
    slug: String
    slug_contains: String
    slug_exists: Boolean
    slug_in: [String]
    slug_not: String
    slug_not_contains: String
    slug_not_in: [String]
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmsGlobalSponsorFilter {
    AND: [CmsGlobalSponsorFilter]
    OR: [CmsGlobalSponsorFilter]
    audio_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    instagramUsername: String
    instagramUsername_contains: String
    instagramUsername_exists: Boolean
    instagramUsername_in: [String]
    instagramUsername_not: String
    instagramUsername_not_contains: String
    instagramUsername_not_in: [String]
    link: String
    link_contains: String
    link_exists: Boolean
    link_in: [String]
    link_not: String
    link_not_contains: String
    link_not_in: [String]
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    perks: String
    perks_contains: String
    perks_exists: Boolean
    perks_in: [String]
    perks_not: String
    perks_not_contains: String
    perks_not_in: [String]
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: CmsSysFilter
    twitterUsername: String
    twitterUsername_contains: String
    twitterUsername_exists: Boolean
    twitterUsername_in: [String]
    twitterUsername_not: String
    twitterUsername_not_contains: String
    twitterUsername_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
}

input CmsHiringCompanyFilter {
    AND: [CmsHiringCompanyFilter]
    OR: [CmsHiringCompanyFilter]
    alumniReferrals_contains_all: [String]
    alumniReferrals_contains_none: [String]
    alumniReferrals_contains_some: [String]
    alumniReferrals_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description_contains: String
    description_exists: Boolean
    description_not_contains: String
    featured: Boolean
    featured_exists: Boolean
    featured_not: Boolean
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    relatedSponsor: CmscfGlobalSponsorNestedFilter
    relatedSponsor_exists: Boolean
    sys: CmsSysFilter
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
}

input CmsHiringPostFilter {
    AND: [CmsHiringPostFilter]
    OR: [CmsHiringPostFilter]
    company: CmscfHiringCompanyNestedFilter
    company_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description_contains: String
    description_exists: Boolean
    description_not_contains: String
    paid: Boolean
    paid_exists: Boolean
    paid_not: Boolean
    regionsCollection_exists: Boolean
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
}

input CmsImageTransformOptions {
    """

    Desired background color, used with corner radius or `PAD` resize strategy.
    Defaults to transparent (for `PNG`, `PNG8` and `WEBP`) or white (for `JPG` and `JPG_PROGRESSIVE`).
    """
    backgroundColor: CmsHexColor
    """

    Desired corner radius in pixels.
    Results in an image with rounded corners (pass `-1` for a full circle/ellipse).
    Defaults to `0`. Uses desired background color as padding color,
    unless the format is `JPG` or `JPG_PROGRESSIVE` and resize strategy is `PAD`, then defaults to white.
    """
    cornerRadius: Int
    "Desired image format. Defaults to the original image format."
    format: CmsImageFormat
    "Desired height in pixels. Defaults to the original image height."
    height: CmsDimension
    """

    Desired quality of the image in percents.
    Used for `PNG8`, `JPG`, `JPG_PROGRESSIVE` and `WEBP` formats.
    """
    quality: CmsQuality
    "Desired resize focus area. Defaults to `CENTER`."
    resizeFocus: CmsImageResizeFocus
    "Desired resize strategy. Defaults to `FIT`."
    resizeStrategy: CmsImageResizeStrategy
    "Desired width in pixels. Defaults to the original image width."
    width: CmsDimension
}

input CmsLegalDocumentFilter {
    AND: [CmsLegalDocumentFilter]
    OR: [CmsLegalDocumentFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    date: CmsDateTime
    date_exists: Boolean
    date_gt: CmsDateTime
    date_gte: CmsDateTime
    date_in: [CmsDateTime]
    date_lt: CmsDateTime
    date_lte: CmsDateTime
    date_not: CmsDateTime
    date_not_in: [CmsDateTime]
    file_exists: Boolean
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
}

input CmsNewsCoverageFilter {
    AND: [CmsNewsCoverageFilter]
    OR: [CmsNewsCoverageFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    date: CmsDateTime
    date_exists: Boolean
    date_gt: CmsDateTime
    date_gte: CmsDateTime
    date_in: [CmsDateTime]
    date_lt: CmsDateTime
    date_lte: CmsDateTime
    date_not: CmsDateTime
    date_not_in: [CmsDateTime]
    featured: Boolean
    featured_exists: Boolean
    featured_not: Boolean
    publicationLogo_exists: Boolean
    publicationName: String
    publicationName_contains: String
    publicationName_exists: Boolean
    publicationName_in: [String]
    publicationName_not: String
    publicationName_not_contains: String
    publicationName_not_in: [String]
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
}

input CmsPressPhotoFilter {
    AND: [CmsPressPhotoFilter]
    OR: [CmsPressPhotoFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    event: CmscfEventNestedFilter
    event_exists: Boolean
    photo_exists: Boolean
    region: CmscfRegionNestedFilter
    region_exists: Boolean
    subProgram: CmscfProgramNestedFilter
    subProgram_exists: Boolean
    sys: CmsSysFilter
    tags_contains_all: [String]
    tags_contains_none: [String]
    tags_contains_some: [String]
    tags_exists: Boolean
}

input CmsProgramFilter {
    AND: [CmsProgramFilter]
    OR: [CmsProgramFilter]
    archived: Boolean
    archived_exists: Boolean
    archived_not: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    educationDetails_contains: String
    educationDetails_exists: Boolean
    educationDetails_not_contains: String
    eligibility_contains: String
    eligibility_exists: Boolean
    eligibility_not_contains: String
    logoWhite_exists: Boolean
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    postersCollection_exists: Boolean
    presentingSponsorsCollection_exists: Boolean
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: CmsSysFilter
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
    virtual: Boolean
    virtual_exists: Boolean
    virtual_not: Boolean
    volunteerBlurb_contains: String
    volunteerBlurb_exists: Boolean
    volunteerBlurb_not_contains: String
    volunteerDetails_contains: String
    volunteerDetails_exists: Boolean
    volunteerDetails_not_contains: String
    volunteerPositions_contains_all: [String]
    volunteerPositions_contains_none: [String]
    volunteerPositions_contains_some: [String]
    volunteerPositions_exists: Boolean
    volunteerRecruitingResourcesCollection_exists: Boolean
    volunteerUrl: String
    volunteerUrl_contains: String
    volunteerUrl_exists: Boolean
    volunteerUrl_in: [String]
    volunteerUrl_not: String
    volunteerUrl_not_contains: String
    volunteerUrl_not_in: [String]
    webname: String
    webname_contains: String
    webname_exists: Boolean
    webname_in: [String]
    webname_not: String
    webname_not_contains: String
    webname_not_in: [String]
}

input CmsRegionFilter {
    AND: [CmsRegionFilter]
    OR: [CmsRegionFilter]
    abbr: String
    abbr_contains: String
    abbr_exists: Boolean
    abbr_in: [String]
    abbr_not: String
    abbr_not_contains: String
    abbr_not_in: [String]
    accountingName: String
    accountingName_contains: String
    accountingName_exists: Boolean
    accountingName_in: [String]
    accountingName_not: String
    accountingName_not_contains: String
    accountingName_not_in: [String]
    aliases_contains_all: [String]
    aliases_contains_none: [String]
    aliases_contains_some: [String]
    aliases_exists: Boolean
    complication_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    countryName: String
    countryNameAdjective: String
    countryNameAdjective_contains: String
    countryNameAdjective_exists: Boolean
    countryNameAdjective_in: [String]
    countryNameAdjective_not: String
    countryNameAdjective_not_contains: String
    countryNameAdjective_not_in: [String]
    countryNameShort: String
    countryNameShortAdjective: String
    countryNameShortAdjective_contains: String
    countryNameShortAdjective_exists: Boolean
    countryNameShortAdjective_in: [String]
    countryNameShortAdjective_not: String
    countryNameShortAdjective_not_contains: String
    countryNameShortAdjective_not_in: [String]
    countryNameShort_contains: String
    countryNameShort_exists: Boolean
    countryNameShort_in: [String]
    countryNameShort_not: String
    countryNameShort_not_contains: String
    countryNameShort_not_in: [String]
    countryName_contains: String
    countryName_exists: Boolean
    countryName_in: [String]
    countryName_not: String
    countryName_not_contains: String
    countryName_not_in: [String]
    e164CountryCode: String
    e164CountryCode_contains: String
    e164CountryCode_exists: Boolean
    e164CountryCode_in: [String]
    e164CountryCode_not: String
    e164CountryCode_not_contains: String
    e164CountryCode_not_in: [String]
    iso3166Alpha2Code: String
    iso3166Alpha2Code_contains: String
    iso3166Alpha2Code_exists: Boolean
    iso3166Alpha2Code_in: [String]
    iso3166Alpha2Code_not: String
    iso3166Alpha2Code_not_contains: String
    iso3166Alpha2Code_not_in: [String]
    iso3166Alpha3Code: String
    iso3166Alpha3Code_contains: String
    iso3166Alpha3Code_exists: Boolean
    iso3166Alpha3Code_in: [String]
    iso3166Alpha3Code_not: String
    iso3166Alpha3Code_not_contains: String
    iso3166Alpha3Code_not_in: [String]
    location_exists: Boolean
    location_within_circle: CmsCircle
    location_within_rectangle: CmsRectangle
    motto: String
    motto_contains: String
    motto_exists: Boolean
    motto_in: [String]
    motto_not: String
    motto_not_contains: String
    motto_not_in: [String]
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    primaryColor: String
    primaryColor_contains: String
    primaryColor_exists: Boolean
    primaryColor_in: [String]
    primaryColor_not: String
    primaryColor_not_contains: String
    primaryColor_not_in: [String]
    regionPhotosCollection_exists: Boolean
    skylinePhoto_exists: Boolean
    stickerLarge_exists: Boolean
    stickerSmall_exists: Boolean
    sys: CmsSysFilter
    timezone: String
    timezone_contains: String
    timezone_exists: Boolean
    timezone_in: [String]
    timezone_not: String
    timezone_not_contains: String
    timezone_not_in: [String]
    webname: String
    webname_contains: String
    webname_exists: Boolean
    webname_in: [String]
    webname_not: String
    webname_not_contains: String
    webname_not_in: [String]
}

input CmsSiteFilter {
    AND: [CmsSiteFilter]
    OR: [CmsSiteFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    display_contains_all: [String]
    display_contains_none: [String]
    display_contains_some: [String]
    display_exists: Boolean
    link: String
    link_contains: String
    link_exists: Boolean
    link_in: [String]
    link_not: String
    link_not_contains: String
    link_not_in: [String]
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
}

input CmsSocialMediaFilter {
    AND: [CmsSocialMediaFilter]
    OR: [CmsSocialMediaFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    icon_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    sys: CmsSysFilter
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
}

input CmsStockMusicFilter {
    AND: [CmsStockMusicFilter]
    OR: [CmsStockMusicFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    music_exists: Boolean
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmsSysFilter {
    firstPublishedAt: CmsDateTime
    firstPublishedAt_exists: Boolean
    firstPublishedAt_gt: CmsDateTime
    firstPublishedAt_gte: CmsDateTime
    firstPublishedAt_in: [CmsDateTime]
    firstPublishedAt_lt: CmsDateTime
    firstPublishedAt_lte: CmsDateTime
    firstPublishedAt_not: CmsDateTime
    firstPublishedAt_not_in: [CmsDateTime]
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    publishedAt: CmsDateTime
    publishedAt_exists: Boolean
    publishedAt_gt: CmsDateTime
    publishedAt_gte: CmsDateTime
    publishedAt_in: [CmsDateTime]
    publishedAt_lt: CmsDateTime
    publishedAt_lte: CmsDateTime
    publishedAt_not: CmsDateTime
    publishedAt_not_in: [CmsDateTime]
    publishedVersion: Float
    publishedVersion_exists: Boolean
    publishedVersion_gt: Float
    publishedVersion_gte: Float
    publishedVersion_in: [Float]
    publishedVersion_lt: Float
    publishedVersion_lte: Float
    publishedVersion_not: Float
    publishedVersion_not_in: [Float]
}

input CmsTestimonialFilter {
    AND: [CmsTestimonialFilter]
    OR: [CmsTestimonialFilter]
    company: String
    company_contains: String
    company_exists: Boolean
    company_in: [String]
    company_not: String
    company_not_contains: String
    company_not_in: [String]
    contentfulMetadata: CmsContentfulMetadataFilter
    experience: String
    experience_contains: String
    experience_exists: Boolean
    experience_in: [String]
    experience_not: String
    experience_not_contains: String
    experience_not_in: [String]
    featured: Boolean
    featured_exists: Boolean
    featured_not: Boolean
    firstName: String
    firstName_contains: String
    firstName_exists: Boolean
    firstName_in: [String]
    firstName_not: String
    firstName_not_contains: String
    firstName_not_in: [String]
    groupName: String
    groupName_contains: String
    groupName_exists: Boolean
    groupName_in: [String]
    groupName_not: String
    groupName_not_contains: String
    groupName_not_in: [String]
    image_exists: Boolean
    lastName: String
    lastName_contains: String
    lastName_exists: Boolean
    lastName_in: [String]
    lastName_not: String
    lastName_not_contains: String
    lastName_not_in: [String]
    program: CmscfProgramNestedFilter
    program_exists: Boolean
    quote: String
    quote_contains: String
    quote_exists: Boolean
    quote_in: [String]
    quote_not: String
    quote_not_contains: String
    quote_not_in: [String]
    region: CmscfRegionNestedFilter
    region_exists: Boolean
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
    video_exists: Boolean
}

input CmscfEventNestedFilter {
    AND: [CmscfEventNestedFilter]
    OR: [CmscfEventNestedFilter]
    awardsAt: CmsDateTime
    awardsAt_exists: Boolean
    awardsAt_gt: CmsDateTime
    awardsAt_gte: CmsDateTime
    awardsAt_in: [CmsDateTime]
    awardsAt_lt: CmsDateTime
    awardsAt_lte: CmsDateTime
    awardsAt_not: CmsDateTime
    awardsAt_not_in: [CmsDateTime]
    calendarReleaseDate: CmsDateTime
    calendarReleaseDate_exists: Boolean
    calendarReleaseDate_gt: CmsDateTime
    calendarReleaseDate_gte: CmsDateTime
    calendarReleaseDate_in: [CmsDateTime]
    calendarReleaseDate_lt: CmsDateTime
    calendarReleaseDate_lte: CmsDateTime
    calendarReleaseDate_not: CmsDateTime
    calendarReleaseDate_not_in: [CmsDateTime]
    contentfulMetadata: CmsContentfulMetadataFilter
    endsAt: CmsDateTime
    endsAt_exists: Boolean
    endsAt_gt: CmsDateTime
    endsAt_gte: CmsDateTime
    endsAt_in: [CmsDateTime]
    endsAt_lt: CmsDateTime
    endsAt_lte: CmsDateTime
    endsAt_not: CmsDateTime
    endsAt_not_in: [CmsDateTime]
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    kickoffVideoCaptions_exists: Boolean
    kickoffVideo_exists: Boolean
    notice_contains: String
    notice_exists: Boolean
    notice_not_contains: String
    participantRoleId: String
    participantRoleId_contains: String
    participantRoleId_exists: Boolean
    participantRoleId_in: [String]
    participantRoleId_not: String
    participantRoleId_not_contains: String
    participantRoleId_not_in: [String]
    postersCollection_exists: Boolean
    program_exists: Boolean
    registrationsCloseAt: CmsDateTime
    registrationsCloseAt_exists: Boolean
    registrationsCloseAt_gt: CmsDateTime
    registrationsCloseAt_gte: CmsDateTime
    registrationsCloseAt_in: [CmsDateTime]
    registrationsCloseAt_lt: CmsDateTime
    registrationsCloseAt_lte: CmsDateTime
    registrationsCloseAt_not: CmsDateTime
    registrationsCloseAt_not_in: [CmsDateTime]
    registrationsOpenAt: CmsDateTime
    registrationsOpenAt_exists: Boolean
    registrationsOpenAt_gt: CmsDateTime
    registrationsOpenAt_gte: CmsDateTime
    registrationsOpenAt_in: [CmsDateTime]
    registrationsOpenAt_lt: CmsDateTime
    registrationsOpenAt_lte: CmsDateTime
    registrationsOpenAt_not: CmsDateTime
    registrationsOpenAt_not_in: [CmsDateTime]
    startsAt: CmsDateTime
    startsAt_exists: Boolean
    startsAt_gt: CmsDateTime
    startsAt_gte: CmsDateTime
    startsAt_in: [CmsDateTime]
    startsAt_lt: CmsDateTime
    startsAt_lte: CmsDateTime
    startsAt_not: CmsDateTime
    startsAt_not_in: [CmsDateTime]
    statEventCount: Int
    statEventCount_exists: Boolean
    statEventCount_gt: Int
    statEventCount_gte: Int
    statEventCount_in: [Int]
    statEventCount_lt: Int
    statEventCount_lte: Int
    statEventCount_not: Int
    statEventCount_not_in: [Int]
    statLowInterestContinuedCount: Int
    statLowInterestContinuedCount_exists: Boolean
    statLowInterestContinuedCount_gt: Int
    statLowInterestContinuedCount_gte: Int
    statLowInterestContinuedCount_in: [Int]
    statLowInterestContinuedCount_lt: Int
    statLowInterestContinuedCount_lte: Int
    statLowInterestContinuedCount_not: Int
    statLowInterestContinuedCount_not_in: [Int]
    statLowInterestCount: Int
    statLowInterestCount_exists: Boolean
    statLowInterestCount_gt: Int
    statLowInterestCount_gte: Int
    statLowInterestCount_in: [Int]
    statLowInterestCount_lt: Int
    statLowInterestCount_lte: Int
    statLowInterestCount_not: Int
    statLowInterestCount_not_in: [Int]
    statStudentCount: Int
    statStudentCount_exists: Boolean
    statStudentCount_gt: Int
    statStudentCount_gte: Int
    statStudentCount_in: [Int]
    statStudentCount_lt: Int
    statStudentCount_lte: Int
    statStudentCount_not: Int
    statStudentCount_not_in: [Int]
    sys: CmsSysFilter
    theme: String
    themeBackgroundsCollection_exists: Boolean
    themeLogoBackgroundsCollection_exists: Boolean
    theme_contains: String
    theme_exists: Boolean
    theme_in: [String]
    theme_not: String
    theme_not_contains: String
    theme_not_in: [String]
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmscfGlobalSponsorNestedFilter {
    AND: [CmscfGlobalSponsorNestedFilter]
    OR: [CmscfGlobalSponsorNestedFilter]
    audio_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    instagramUsername: String
    instagramUsername_contains: String
    instagramUsername_exists: Boolean
    instagramUsername_in: [String]
    instagramUsername_not: String
    instagramUsername_not_contains: String
    instagramUsername_not_in: [String]
    link: String
    link_contains: String
    link_exists: Boolean
    link_in: [String]
    link_not: String
    link_not_contains: String
    link_not_in: [String]
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    perks: String
    perks_contains: String
    perks_exists: Boolean
    perks_in: [String]
    perks_not: String
    perks_not_contains: String
    perks_not_in: [String]
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: CmsSysFilter
    twitterUsername: String
    twitterUsername_contains: String
    twitterUsername_exists: Boolean
    twitterUsername_in: [String]
    twitterUsername_not: String
    twitterUsername_not_contains: String
    twitterUsername_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
}

input CmscfHiringCompanyNestedFilter {
    AND: [CmscfHiringCompanyNestedFilter]
    OR: [CmscfHiringCompanyNestedFilter]
    alumniReferrals_contains_all: [String]
    alumniReferrals_contains_none: [String]
    alumniReferrals_contains_some: [String]
    alumniReferrals_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description_contains: String
    description_exists: Boolean
    description_not_contains: String
    featured: Boolean
    featured_exists: Boolean
    featured_not: Boolean
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    relatedSponsor_exists: Boolean
    sys: CmsSysFilter
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
}

input CmscfProgramNestedFilter {
    AND: [CmscfProgramNestedFilter]
    OR: [CmscfProgramNestedFilter]
    archived: Boolean
    archived_exists: Boolean
    archived_not: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    educationDetails_contains: String
    educationDetails_exists: Boolean
    educationDetails_not_contains: String
    eligibility_contains: String
    eligibility_exists: Boolean
    eligibility_not_contains: String
    logoWhite_exists: Boolean
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    postersCollection_exists: Boolean
    presentingSponsorsCollection_exists: Boolean
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: CmsSysFilter
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
    virtual: Boolean
    virtual_exists: Boolean
    virtual_not: Boolean
    volunteerBlurb_contains: String
    volunteerBlurb_exists: Boolean
    volunteerBlurb_not_contains: String
    volunteerDetails_contains: String
    volunteerDetails_exists: Boolean
    volunteerDetails_not_contains: String
    volunteerPositions_contains_all: [String]
    volunteerPositions_contains_none: [String]
    volunteerPositions_contains_some: [String]
    volunteerPositions_exists: Boolean
    volunteerRecruitingResourcesCollection_exists: Boolean
    volunteerUrl: String
    volunteerUrl_contains: String
    volunteerUrl_exists: Boolean
    volunteerUrl_in: [String]
    volunteerUrl_not: String
    volunteerUrl_not_contains: String
    volunteerUrl_not_in: [String]
    webname: String
    webname_contains: String
    webname_exists: Boolean
    webname_in: [String]
    webname_not: String
    webname_not_contains: String
    webname_not_in: [String]
}

input CmscfRegionNestedFilter {
    AND: [CmscfRegionNestedFilter]
    OR: [CmscfRegionNestedFilter]
    abbr: String
    abbr_contains: String
    abbr_exists: Boolean
    abbr_in: [String]
    abbr_not: String
    abbr_not_contains: String
    abbr_not_in: [String]
    accountingName: String
    accountingName_contains: String
    accountingName_exists: Boolean
    accountingName_in: [String]
    accountingName_not: String
    accountingName_not_contains: String
    accountingName_not_in: [String]
    aliases_contains_all: [String]
    aliases_contains_none: [String]
    aliases_contains_some: [String]
    aliases_exists: Boolean
    complication_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    countryName: String
    countryNameAdjective: String
    countryNameAdjective_contains: String
    countryNameAdjective_exists: Boolean
    countryNameAdjective_in: [String]
    countryNameAdjective_not: String
    countryNameAdjective_not_contains: String
    countryNameAdjective_not_in: [String]
    countryNameShort: String
    countryNameShortAdjective: String
    countryNameShortAdjective_contains: String
    countryNameShortAdjective_exists: Boolean
    countryNameShortAdjective_in: [String]
    countryNameShortAdjective_not: String
    countryNameShortAdjective_not_contains: String
    countryNameShortAdjective_not_in: [String]
    countryNameShort_contains: String
    countryNameShort_exists: Boolean
    countryNameShort_in: [String]
    countryNameShort_not: String
    countryNameShort_not_contains: String
    countryNameShort_not_in: [String]
    countryName_contains: String
    countryName_exists: Boolean
    countryName_in: [String]
    countryName_not: String
    countryName_not_contains: String
    countryName_not_in: [String]
    e164CountryCode: String
    e164CountryCode_contains: String
    e164CountryCode_exists: Boolean
    e164CountryCode_in: [String]
    e164CountryCode_not: String
    e164CountryCode_not_contains: String
    e164CountryCode_not_in: [String]
    iso3166Alpha2Code: String
    iso3166Alpha2Code_contains: String
    iso3166Alpha2Code_exists: Boolean
    iso3166Alpha2Code_in: [String]
    iso3166Alpha2Code_not: String
    iso3166Alpha2Code_not_contains: String
    iso3166Alpha2Code_not_in: [String]
    iso3166Alpha3Code: String
    iso3166Alpha3Code_contains: String
    iso3166Alpha3Code_exists: Boolean
    iso3166Alpha3Code_in: [String]
    iso3166Alpha3Code_not: String
    iso3166Alpha3Code_not_contains: String
    iso3166Alpha3Code_not_in: [String]
    location_exists: Boolean
    location_within_circle: CmsCircle
    location_within_rectangle: CmsRectangle
    motto: String
    motto_contains: String
    motto_exists: Boolean
    motto_in: [String]
    motto_not: String
    motto_not_contains: String
    motto_not_in: [String]
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    primaryColor: String
    primaryColor_contains: String
    primaryColor_exists: Boolean
    primaryColor_in: [String]
    primaryColor_not: String
    primaryColor_not_contains: String
    primaryColor_not_in: [String]
    regionPhotosCollection_exists: Boolean
    skylinePhoto_exists: Boolean
    stickerLarge_exists: Boolean
    stickerSmall_exists: Boolean
    sys: CmsSysFilter
    timezone: String
    timezone_contains: String
    timezone_exists: Boolean
    timezone_in: [String]
    timezone_not: String
    timezone_not_contains: String
    timezone_not_in: [String]
    webname: String
    webname_contains: String
    webname_exists: Boolean
    webname_in: [String]
    webname_not: String
    webname_not_contains: String
    webname_not_in: [String]
}

input LabsGtLtEq {
    eq: Float
    gt: Float
    gte: Float
    lt: Float
    lte: Float
}

input LabsIdOrUsernameInput {
    id: String
    username: String
}

input LabsMentorApplyInput {
    email: String!
    givenName: String!
    maxWeeks: Int
    profile: LabsJSONObject
    projects: [LabsProjectCreateInput!]!
    surname: String!
}

input LabsMentorCreateInput {
    email: String!
    givenName: String!
    maxWeeks: Int
    profile: LabsJSONObject
    status: LabsMentorStatus
    surname: String!
    username: String
}

input LabsMentorEditInput {
    email: String
    givenName: String
    managerUsername: String
    maxWeeks: Int
    profile: LabsJSONObject
    status: LabsMentorStatus
    surname: String
    username: String
}

input LabsMentorFilterInput {
    assignedToManager: String
    inStatus: LabsMentorStatus
    studentWeeks: LabsGtLtEq
    track: LabsTrack
    weeksGte: Float
    withProjects: Boolean
}

input LabsProjectCreateInput {
    deliverables: String
    description: String
    maxStudents: Int
    tags: [String!]
    track: LabsTrack!
}

input LabsProjectEditInput {
    deliverables: String
    description: String
    maxStudents: Int
    status: LabsProjectStatus
    tags: [String!]
    track: LabsTrack
}

input LabsStudentApplyInput {
    email: String!
    givenName: String!
    minHours: Int!
    partnerCode: String
    profile: LabsJSONObject
    surname: String!
    tags: [String!]
    track: LabsTrack!
}

input LabsStudentCreateInput {
    email: String!
    givenName: String!
    minHours: Int!
    partnerCode: String
    profile: LabsJSONObject
    status: LabsStudentStatus
    surname: String!
    tags: [String!]
    track: LabsTrack!
    username: String!
    weeks: Int
}

input LabsStudentEditInput {
    email: String
    givenName: String
    minHours: Int
    partnerCode: String
    profile: LabsJSONObject
    status: LabsStudentStatus
    surname: String
    tags: [String!]
    track: LabsTrack
    username: String
    weeks: Int
}

input LabsStudentFilterInput {
    email: String
    givenName: String
    inStatus: LabsStudentStatus
    partnerCode: String
    surname: String
    track: LabsTrack
    weeks: LabsGtLtEq
    withProjects: Boolean
}

input LabsTagCreateInput {
    id: String!
    mentorDisplayName: String!
    studentDisplayName: String!
    trainingLink: String
    type: LabsTagType!
}

input LabsTagEditInput {
    mentorDisplayName: String
    studentDisplayName: String
    trainingLink: String
    type: LabsTagType
}

input LearnAssetFilter {
    AND: [LearnAssetFilter]
    OR: [LearnAssetFilter]
    contentType: String
    contentType_contains: String
    contentType_exists: Boolean
    contentType_in: [String]
    contentType_not: String
    contentType_not_contains: String
    contentType_not_in: [String]
    contentfulMetadata: LearnContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    fileName: String
    fileName_contains: String
    fileName_exists: Boolean
    fileName_in: [String]
    fileName_not: String
    fileName_not_contains: String
    fileName_not_in: [String]
    height: Int
    height_exists: Boolean
    height_gt: Int
    height_gte: Int
    height_in: [Int]
    height_lt: Int
    height_lte: Int
    height_not: Int
    height_not_in: [Int]
    size: Int
    size_exists: Boolean
    size_gt: Int
    size_gte: Int
    size_in: [Int]
    size_lt: Int
    size_lte: Int
    size_not: Int
    size_not_in: [Int]
    sys: LearnSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
    width: Int
    width_exists: Boolean
    width_gt: Int
    width_gte: Int
    width_in: [Int]
    width_lt: Int
    width_lte: Int
    width_not: Int
    width_not_in: [Int]
}

input LearnCodeBlockFilter {
    AND: [LearnCodeBlockFilter]
    OR: [LearnCodeBlockFilter]
    code: String
    code_contains: String
    code_exists: Boolean
    code_in: [String]
    code_not: String
    code_not_contains: String
    code_not_in: [String]
    contentfulMetadata: LearnContentfulMetadataFilter
    language: String
    language_contains: String
    language_exists: Boolean
    language_in: [String]
    language_not: String
    language_not_contains: String
    language_not_in: [String]
    sys: LearnSysFilter
}

input LearnContentfulMetadataFilter {
    tags: LearnContentfulMetadataTagsFilter
    tags_exists: Boolean
}

input LearnContentfulMetadataTagsFilter {
    id_contains_all: [String]
    id_contains_none: [String]
    id_contains_some: [String]
}

input LearnDifficultyFilter {
    AND: [LearnDifficultyFilter]
    OR: [LearnDifficultyFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    hexCodeColor: String
    hexCodeColor_contains: String
    hexCodeColor_exists: Boolean
    hexCodeColor_in: [String]
    hexCodeColor_not: String
    hexCodeColor_not_contains: String
    hexCodeColor_not_in: [String]
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: LearnSysFilter
}

input LearnEntryFilter {
    AND: [LearnEntryFilter]
    OR: [LearnEntryFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    sys: LearnSysFilter
}

input LearnImageTransformOptions {
    """

    Desired background color, used with corner radius or `PAD` resize strategy.
    Defaults to transparent (for `PNG`, `PNG8` and `WEBP`) or white (for `JPG` and `JPG_PROGRESSIVE`).
    """
    backgroundColor: LearnHexColor
    """

    Desired corner radius in pixels.
    Results in an image with rounded corners (pass `-1` for a full circle/ellipse).
    Defaults to `0`. Uses desired background color as padding color,
    unless the format is `JPG` or `JPG_PROGRESSIVE` and resize strategy is `PAD`, then defaults to white.
    """
    cornerRadius: Int
    "Desired image format. Defaults to the original image format."
    format: LearnImageFormat
    "Desired height in pixels. Defaults to the original image height."
    height: LearnDimension
    """

    Desired quality of the image in percents.
    Used for `PNG8`, `JPG`, `JPG_PROGRESSIVE` and `WEBP` formats.
    """
    quality: LearnQuality
    "Desired resize focus area. Defaults to `CENTER`."
    resizeFocus: LearnImageResizeFocus
    "Desired resize strategy. Defaults to `FIT`."
    resizeStrategy: LearnImageResizeStrategy
    "Desired width in pixels. Defaults to the original image width."
    width: LearnDimension
}

input LearnLessonFilter {
    AND: [LearnLessonFilter]
    OR: [LearnLessonFilter]
    content_contains: String
    content_exists: Boolean
    content_not_contains: String
    contentfulMetadata: LearnContentfulMetadataFilter
    hasNextPage: Boolean
    hasNextPage_exists: Boolean
    hasNextPage_not: Boolean
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    nameHeader: String
    nameHeader_contains: String
    nameHeader_exists: Boolean
    nameHeader_in: [String]
    nameHeader_not: String
    nameHeader_not_contains: String
    nameHeader_not_in: [String]
    pageNumber: Int
    pageNumber_exists: Boolean
    pageNumber_gt: Int
    pageNumber_gte: Int
    pageNumber_in: [Int]
    pageNumber_lt: Int
    pageNumber_lte: Int
    pageNumber_not: Int
    pageNumber_not_in: [Int]
    points: Int
    points_exists: Boolean
    points_gt: Int
    points_gte: Int
    points_in: [Int]
    points_lt: Int
    points_lte: Int
    points_not: Int
    points_not_in: [Int]
    sys: LearnSysFilter
    tags_contains_all: [String]
    tags_contains_none: [String]
    tags_contains_some: [String]
    tags_exists: Boolean
    track: LearncfTrackNestedFilter
    track_exists: Boolean
}

input LearnRewardFilter {
    AND: [LearnRewardFilter]
    OR: [LearnRewardFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: LearnSysFilter
}

input LearnSysFilter {
    firstPublishedAt: LearnDateTime
    firstPublishedAt_exists: Boolean
    firstPublishedAt_gt: LearnDateTime
    firstPublishedAt_gte: LearnDateTime
    firstPublishedAt_in: [LearnDateTime]
    firstPublishedAt_lt: LearnDateTime
    firstPublishedAt_lte: LearnDateTime
    firstPublishedAt_not: LearnDateTime
    firstPublishedAt_not_in: [LearnDateTime]
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    publishedAt: LearnDateTime
    publishedAt_exists: Boolean
    publishedAt_gt: LearnDateTime
    publishedAt_gte: LearnDateTime
    publishedAt_in: [LearnDateTime]
    publishedAt_lt: LearnDateTime
    publishedAt_lte: LearnDateTime
    publishedAt_not: LearnDateTime
    publishedAt_not_in: [LearnDateTime]
    publishedVersion: Float
    publishedVersion_exists: Boolean
    publishedVersion_gt: Float
    publishedVersion_gte: Float
    publishedVersion_in: [Float]
    publishedVersion_lt: Float
    publishedVersion_lte: Float
    publishedVersion_not: Float
    publishedVersion_not_in: [Float]
}

input LearnTechnologyFilter {
    AND: [LearnTechnologyFilter]
    OR: [LearnTechnologyFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    image_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    sys: LearnSysFilter
}

input LearnTrackFilter {
    AND: [LearnTrackFilter]
    OR: [LearnTrackFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    difficulty: LearncfDifficultyNestedFilter
    difficulty_exists: Boolean
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    lessonsCollection_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    previewProjectIds_contains_all: [String]
    previewProjectIds_contains_none: [String]
    previewProjectIds_contains_some: [String]
    previewProjectIds_exists: Boolean
    spotlighted: Boolean
    spotlighted_exists: Boolean
    spotlighted_not: Boolean
    sys: LearnSysFilter
    technologiesCollection_exists: Boolean
}

input LearncfDifficultyNestedFilter {
    AND: [LearncfDifficultyNestedFilter]
    OR: [LearncfDifficultyNestedFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    hexCodeColor: String
    hexCodeColor_contains: String
    hexCodeColor_exists: Boolean
    hexCodeColor_in: [String]
    hexCodeColor_not: String
    hexCodeColor_not_contains: String
    hexCodeColor_not_in: [String]
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: LearnSysFilter
}

input LearncfTrackNestedFilter {
    AND: [LearncfTrackNestedFilter]
    OR: [LearncfTrackNestedFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    difficulty_exists: Boolean
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    lessonsCollection_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    previewProjectIds_contains_all: [String]
    previewProjectIds_contains_none: [String]
    previewProjectIds_contains_some: [String]
    previewProjectIds_exists: Boolean
    spotlighted: Boolean
    spotlighted_exists: Boolean
    spotlighted_not: Boolean
    sys: LearnSysFilter
    technologiesCollection_exists: Boolean
}

input ShowcaseAddReactionsInput {
    count: Float!
    type: ShowcaseReactionType!
}

input ShowcaseCreateJudgingPoolInput {
    eventGroupId: String
    eventId: String
    judgingCriteria: [ShowcaseJudgingCriteriaInput!]!
    name: String!
    programId: String
    regionId: String
}

input ShowcaseCreateProjectInput {
    challengesEncountered: String
    codeLink: String
    description: String
    name: String!
    priorExperience: String
    type: ShowcaseProjectType!
    viewLink: String
}

input ShowcaseEditProjectInput {
    challengesEncountered: String
    codeLink: String
    description: String
    name: String
    priorExperience: String
    slug: String
    type: ShowcaseProjectType
    viewLink: String
}

input ShowcaseJudgingCriteriaInput {
    name: String!
    weight: Float!
}

input ShowcaseMetadataWhere {
    key: String!
    value: String!
}

input ShowcaseProjectsWhere {
    awarded: Boolean
    contains: String
    event: String
    eventGroup: String
    featured: Boolean
    media: ShowcaseMediaFilterType
    mediaTopic: ShowcaseMediaTopic
    metadata: [ShowcaseMetadataWhere!]
    program: String
    region: String
    type: ShowcaseProjectType
    user: String
}


"The `Upload` scalar type represents a file upload."
scalar Upload

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z,
compliant with the 'date-time' format outlined in section 5.6 of
the RFC 3339 profile of the ISO 8601 standard for representation
of dates and times using the Gregorian calendar.
"""
scalar CmsDateTime

"The 'Dimension' type represents dimensions as whole numeric values between `1` and `4000`."
scalar CmsDimension

"The 'Quality' type represents quality as whole numeric values between `1` and `100`."
scalar CmsQuality

"The 'HexColor' type represents color in `rgb:ffffff` string format."
scalar CmsHexColor

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar CmsJSON

"The Circle scalar type represents a circle, defined by the coordinates of its center and a radius. The Circle type is used to represent a searchable area together with the '_within_circle' filter."
scalar CmsCircle

"The Rectangle scalar type represents a rectangle, defined by the coordinates of its top left and bottom right corners. The Rectangle type is used to represent a searchable area together with the '_within_rectangle' filter."
scalar CmsRectangle

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar ShowYourWorkDateTime

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar ShowcaseDateTime

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar CalendarDateTime

"The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar CalendarJSONObject

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z,
compliant with the 'date-time' format outlined in section 5.6 of
the RFC 3339 profile of the ISO 8601 standard for representation
of dates and times using the Gregorian calendar.
"""
scalar LearnDateTime

"The 'Dimension' type represents dimensions as whole numeric values between `1` and `4000`."
scalar LearnDimension

"The 'Quality' type represents quality as whole numeric values between `1` and `100`."
scalar LearnQuality

"The 'HexColor' type represents color in `rgb:ffffff` string format."
scalar LearnHexColor

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar LearnJSON

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar LabsDateTime

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar LabsJSON

"The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar LabsJSONObject

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar AdvisorsDateTime

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar ClearDateTime

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar ClearJSON

"The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar ClearJSONObject
