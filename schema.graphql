# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
    subscription: Subscription
}

"Nodes used to manage content"
interface BlogContentNode {
    "The ID of the object in the database."
    databaseId: Int!
    "Post publishing date."
    date: String
    "The publishing date set in GMT."
    dateGmt: String
    "The desired slug of the post"
    desiredSlug: String
    "The user that most recently edited the object"
    editLast: BlogUser
    "If a user has edited the object within the past 15 seconds, this will return the user and the time they last edited. Null if the edit lock doesn't exist or is greater than 15 seconds"
    editLock: BlogEditLock
    "The RSS enclosure for the object"
    enclosure: String
    "The global unique identifier for this post. This currently matches the value stored in WP_Post->guid and the guid column in the \"post_objects\" database table."
    guid: String
    "The globally unique identifier of the node."
    id: ID!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "The permalink of the post"
    link: String
    "The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time."
    modified: String
    "The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT."
    modifiedGmt: String
    "The uri slug for the post. This is equivalent to the WP_Post->post_name field and the post_name column in the database for the \"post_objects\" table."
    slug: String
    "The current status of the object"
    status: String
    "URI path for the resource"
    uri: String!
}

"Content node with hierarchical (parent/child) relationships"
interface BlogHierarchicalContentNode {
    "The parent of the object. The parent object can be of various types"
    parent: BlogPostObjectUnion
}

"An object with an ID"
interface BlogNode {
    "The globally unique ID for the object"
    id: ID!
}

"A node that can have an author assigned to it"
interface BlogNodeWithAuthor {
    "The author field will return a queryable User type matching the post's author."
    wpAuthor: BlogUser
}

"A node that can have comments associated with it"
interface BlogNodeWithComments {
    "The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility."
    commentCount: Int
    "Whether the comments are open or closed for this particular post."
    commentStatus: String
}

"A node that supports the content editor"
interface BlogNodeWithContentEditor {
    "The content of the post."
    content(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
}

"A node that can have an excerpt"
interface BlogNodeWithExcerpt {
    "The excerpt of the post."
    excerpt(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
}

"A node that can have a featured image set"
interface BlogNodeWithFeaturedImage {
    "The featured image for the object"
    featuredImage: BlogMediaItem
}

"A node that can have page attributes"
interface BlogNodeWithPageAttributes {
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int
}

"A node that can have revisions"
interface BlogNodeWithRevisions {
    "True if the node is a revision of another node"
    isRevision: Boolean
    "If the current node is a revision, this field exposes the node this is a revision of. Returns null if the node is not a revision of another node."
    revisionOf: BlogPostObjectUnion
}

"A node that NodeWith a title"
interface BlogNodeWithTitle {
    "The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made."
    title(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String
}

"A node that can have trackbacks and pingbacks"
interface BlogNodeWithTrackbacks {
    "Whether the pings are open or closed for this particular post."
    pingStatus: String
    "URLs that have been pinged."
    pinged: [String]
    "URLs queued to be pinged."
    toPing: [String]
}

"Terms are nodes within a Taxonomy, used to group and relate other nodes."
interface BlogTermNode {
    "The number of objects connected to the object"
    count: Int
    "Identifies the primary key from the database."
    databaseId: Int!
    "The description of the object"
    description: String
    "Unique identifier for the term"
    id: ID!
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean
    "The link to the term"
    link: String
    "The human friendly name of the object."
    name: String
    "An alphanumeric identifier for the object unique to its type."
    slug: String
    "The ID of the term group that this term object belongs to"
    termGroupId: Int
    "The taxonomy ID that the object is associated with"
    termTaxonomyId: Int
    "The unique resource identifier path"
    uri: String!
}

"Any node that has a URI"
interface BlogUniformResourceIdentifiable {
    "The unique resource identifier path"
    databaseId: Int!
    "The unique resource identifier path"
    id: ID!
    "The unique resource identifier path"
    uri: String!
}

interface CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    sys: CmsSys!
}

interface LearnEntry {
    contentfulMetadata: LearnContentfulMetadata!
    sys: LearnSys!
}

union BlogCommentAuthorUnion = BlogCommentAuthor | BlogUser

union BlogContentRevisionUnion = BlogPage | BlogPost

union BlogMenuItemObjectUnion = BlogCategory | BlogMenuItem | BlogPage | BlogPost | BlogTag

union BlogPostObjectUnion = BlogMediaItem | BlogPage | BlogPost

union BlogTermObjectUnion = BlogCategory | BlogPostFormat | BlogTag

type AccountDiscordInformation {
    avatar: String
    discriminator: String!
    handle: String!
    tag: String!
    username: String!
}

type AccountMutation {
    addRole(id: ID!, roleId: ID!): Boolean
    addRoleByCode(code: String!, where: AccountUserSingleInput!): Boolean
    grantBadge(badge: AccountUserBadgeInput!, where: AccountUserSingleInput!): Boolean
    linkDiscord(discordId: String!, userId: ID!): Boolean
    pizzaOrTurtleCult(pizzaOrTurtle: AccountPizzaOrTurtle!, where: AccountUserSingleInput!): Boolean
    revokeBadge(badge: AccountUserBadgeInput!, where: AccountUserSingleInput!): Boolean
    setDisplayedBadges(badges: [AccountDisplayedUserBadgeInput!], where: AccountUserSingleInput): Boolean
    unlinkDiscord(userId: ID!): Boolean
    updateUser(updates: AccountUpdateUserInput!, username: String): Boolean
    uploadProfilePicture(upload: Upload!, where: AccountUserSingleInput): String
}

type AccountQuery {
    getUser(fresh: Boolean, where: AccountUserSingleInput!): AccountUser
    roleUsers(roleId: String!): [AccountUser]!
    roles: [AccountRole]!
    searchUsers(where: AccountUserSearch!): [AccountUser]!
}

type AccountRole {
    description: String
    id: ID!
    name: String!
}

type AccountSubscriptionBadge {
    badge: AccountUserBadge!
    type: String
    user: AccountSubscriptionUser!
}

type AccountSubscriptionUser {
    badges: [AccountUserBadge]
    bio: String
    discordId: String
    id: ID!
    name: String
    picture(transform: AccountUserPictureTransformInput): String
    pronoun: String
    roles: [AccountRole]
    username: String
}

type AccountUser {
    acceptTos: Boolean
    badges(displayed: Boolean): [AccountUserBadge]
    bio: String
    blocked: Boolean
    discordId: String
    discordInformation: AccountDiscordInformation
    displayNameFormat: String
    email: String
    familyName: String
    givenName: String
    id: ID!
    name: String
    phoneNumber: String
    picture(transform: AccountUserPictureTransformInput): String
    pronoun: String
    roles: [AccountRole]
    sites: [CmsSite]
    title: String
    username: String
}

type AccountUserBadge {
    details: CmsBadge
    displayed: Boolean
    expiresUtc: String
    id: ID!
    order: Int
}

type AdvisorsMutation {
    createAdvisor(data: AdvisorsAdvisorCreateInput!): Boolean!
    createRequest(email: String!, familyName: String!, givenName: String!, resume: Upload, type: AdvisorsRequestType!): Boolean!
    editAdvisorLimits(limits: AdvisorsAdvisorLimitInput!, where: AdvisorsAdvisorWhereInput!): Boolean!
}

type AdvisorsPendingRequests {
    pendingRequests: Float!
    requestType: AdvisorsRequestType!
}

type AdvisorsQuery {
    pendingRequests: [AdvisorsPendingRequests!]!
    remainingRequests: [AdvisorsRemainingRequestsType!]!
}

type AdvisorsRemainingRequestsByAdvisorType {
    advisorType: AdvisorsAdvisorType!
    remainingRequests: Float!
}

type AdvisorsRemainingRequestsType {
    advisorTypes: [AdvisorsRemainingRequestsByAdvisorType!]!
    requestType: AdvisorsRequestType!
    totalRemainingRequests: Float!
}

"Avatars are profile images for users. WordPress by default uses the Gravatar service to host and fetch avatars from."
type BlogAvatar {
    "URL for the default image or a default type. Accepts &#039;404&#039; (return a 404 instead of a default image), &#039;retro&#039; (8bit), &#039;monsterid&#039; (monster), &#039;wavatar&#039; (cartoon face), &#039;indenticon&#039; (the &#039;quilt&#039;), &#039;mystery&#039;, &#039;mm&#039;, or &#039;mysteryman&#039; (The Oyster Man), &#039;blank&#039; (transparent GIF), or &#039;gravatar_default&#039; (the Gravatar logo)."
    default: String @deprecated(reason : "")
    "HTML attributes to insert in the IMG element. Is not sanitized."
    extraAttr: String @deprecated(reason : "")
    "Whether to always show the default image, never the Gravatar."
    forceDefault: Boolean @deprecated(reason : "")
    "Whether the avatar was successfully found."
    foundAvatar: Boolean @deprecated(reason : "")
    "Height of the avatar image."
    height: Int @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "What rating to display avatars up to. Accepts &#039;G&#039;, &#039;PG&#039;, &#039;R&#039;, &#039;X&#039;, and are judged in that order."
    rating: String @deprecated(reason : "")
    "Type of url scheme to use. Typically HTTP vs. HTTPS."
    scheme: String @deprecated(reason : "")
    "The size of the avatar in pixels. A value of 96 will match a 96px x 96px gravatar image."
    size: Int @deprecated(reason : "")
    "URL for the gravatar image source."
    url: String @deprecated(reason : "")
    "Width of the avatar image."
    width: Int @deprecated(reason : "")
}

"The category type"
type BlogCategory implements BlogNode & BlogTermNode & BlogUniformResourceIdentifiable {
    "The ancestors of the object"
    ancestors: [BlogCategory] @deprecated(reason : "")
    "The id field matches the WP_Post-&gt;ID field."
    categoryId: Int @deprecated(reason : "Deprecated in favor of databaseId")
    "Connection between the category type and the category type"
    children(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogCategoryToCategoryConnectionWhereArgs
    ): BlogCategoryToCategoryConnection @deprecated(reason : "")
    "The number of objects connected to the object"
    count: Int @deprecated(reason : "")
    "Identifies the primary key from the database."
    databaseId: Int! @deprecated(reason : "")
    "The description of the object"
    description: String @deprecated(reason : "")
    "Added to the GraphQL Schema because the ACF Field Group &quot;Display&quot; was assigned to the &quot;category&quot; taxonomy"
    display: BlogCategory_Display @deprecated(reason : "")
    "The globally unique ID for the object"
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "The link to the term"
    link: String @deprecated(reason : "")
    "The human friendly name of the object."
    name: String @deprecated(reason : "")
    "The parent object"
    parent: BlogCategory @deprecated(reason : "")
    "Connection between the category type and the post type"
    posts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogCategoryToPostConnectionWhereArgs
    ): BlogCategoryToPostConnection @deprecated(reason : "")
    "An alphanumeric identifier for the object unique to its type."
    slug: String @deprecated(reason : "")
    "Connection between the category type and the Taxonomy type"
    taxonomy: BlogCategoryToTaxonomyConnection @deprecated(reason : "")
    "The ID of the term group that this term object belongs to"
    termGroupId: Int @deprecated(reason : "")
    "The taxonomy ID that the object is associated with"
    termTaxonomyId: Int @deprecated(reason : "")
    "The unique resource identifier path"
    uri: String! @deprecated(reason : "")
}

"Connection between the category type and the category type"
type BlogCategoryToCategoryConnection {
    "Edges for the CategoryToCategoryConnection connection"
    edges: [BlogCategoryToCategoryConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogCategory] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogCategoryToCategoryConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogCategory @deprecated(reason : "")
}

"Connection between the category type and the post type"
type BlogCategoryToPostConnection {
    "Edges for the CategoryToPostConnection connection"
    edges: [BlogCategoryToPostConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPost] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogCategoryToPostConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPost @deprecated(reason : "")
}

"Connection between the category type and the Taxonomy type"
type BlogCategoryToTaxonomyConnection {
    "The nodes of the connection, without the edges"
    node: BlogTaxonomy @deprecated(reason : "")
}

"Field Group"
type BlogCategory_Display {
    color: String @deprecated(reason : "")
    fieldGroupName: String @deprecated(reason : "")
}

"A Comment object"
type BlogComment implements BlogNode {
    "User agent used to post the comment. This field is equivalent to WP_Comment-&gt;comment_agent and the value matching the &quot;comment_agent&quot; column in SQL."
    agent: String @deprecated(reason : "")
    "The approval status of the comment. This field is equivalent to WP_Comment-&gt;comment_approved and the value matching the &quot;comment_approved&quot; column in SQL."
    approved: Boolean @deprecated(reason : "")
    "The author of the comment"
    author: BlogCommentAuthorUnion @deprecated(reason : "")
    "IP address for the author. This field is equivalent to WP_Comment-&gt;comment_author_IP and the value matching the &quot;comment_author_IP&quot; column in SQL."
    authorIp: String @deprecated(reason : "")
    "Connection between the Comment type and the Comment type"
    children(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogCommentToCommentConnectionWhereArgs
    ): BlogCommentToCommentConnection @deprecated(reason : "")
    "ID for the comment, unique among comments."
    commentId: Int @deprecated(reason : "")
    "The object the comment was added to"
    commentedOn: BlogPostObjectUnion @deprecated(reason : "")
    "Content of the comment. This field is equivalent to WP_Comment-&gt;comment_content and the value matching the &quot;comment_content&quot; column in SQL."
    content(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String @deprecated(reason : "")
    "Date the comment was posted in local time. This field is equivalent to WP_Comment-&gt;date and the value matching the &quot;date&quot; column in SQL."
    date: String @deprecated(reason : "")
    "Date the comment was posted in GMT. This field is equivalent to WP_Comment-&gt;date_gmt and the value matching the &quot;date_gmt&quot; column in SQL."
    dateGmt: String @deprecated(reason : "")
    "The globally unique identifier for the comment object"
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "Karma value for the comment. This field is equivalent to WP_Comment-&gt;comment_karma and the value matching the &quot;comment_karma&quot; column in SQL."
    karma: Int @deprecated(reason : "")
    "Parent comment of current comment. This field is equivalent to the WP_Comment instance matching the WP_Comment-&gt;comment_parent ID."
    parent: BlogComment @deprecated(reason : "")
    "Type of comment. This field is equivalent to WP_Comment-&gt;comment_type and the value matching the &quot;comment_type&quot; column in SQL."
    type: String @deprecated(reason : "")
}

"A Comment Author object"
type BlogCommentAuthor implements BlogNode {
    "The email for the comment author"
    email: String @deprecated(reason : "")
    "The globally unique identifier for the comment author object"
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "The name for the comment author."
    name: String @deprecated(reason : "")
    "The url the comment author."
    url: String @deprecated(reason : "")
}

"Connection between the Comment type and the Comment type"
type BlogCommentToCommentConnection {
    "Edges for the CommentToCommentConnection connection"
    edges: [BlogCommentToCommentConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogComment] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogCommentToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogComment @deprecated(reason : "")
}

"An Post Type object"
type BlogContentType implements BlogNode {
    "Whether this content type should can be exported."
    canExport: Boolean @deprecated(reason : "")
    "List of Taxonomies connected to the Post Type"
    connectedTaxonomies(
        "Select which taxonomies to limit the results to"
        taxonomies: [BlogTaxonomyEnum]
    ): [BlogTaxonomy] @deprecated(reason : "")
    "A list of Taxonomies associated with the post type"
    connectedTaxonomyNames(
        "Select which taxonomies to limit the results to"
        taxonomies: [BlogTaxonomyEnum]
    ): [String] @deprecated(reason : "")
    "Whether delete this type of content when the author of it is deleted from the system."
    deleteWithUser: Boolean @deprecated(reason : "")
    "Description of the content type."
    description: String @deprecated(reason : "")
    "Whether to exclude posts with this post type from front end search results."
    excludeFromSearch: Boolean @deprecated(reason : "")
    "The plural name of the post type within the GraphQL Schema."
    graphqlPluralName: String @deprecated(reason : "")
    "The singular name of the post type within the GraphQL Schema."
    graphqlSingleName: String @deprecated(reason : "")
    "Whether this content type should have archives. Content archives are generated by type and by date."
    hasArchive: Boolean @deprecated(reason : "")
    "Whether the post type is hierarchical, for example pages."
    hierarchical: Boolean @deprecated(reason : "")
    "The globally unique identifier of the post-type object."
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "Display name of the content type."
    label: String @deprecated(reason : "")
    "Details about the post type labels."
    labels: BlogPostTypeLabelDetails @deprecated(reason : "")
    "The name of the icon file to display as a menu icon."
    menuIcon: String @deprecated(reason : "")
    "The position of this post type in the menu. Only applies if show_in_menu is true."
    menuPosition: Int @deprecated(reason : "")
    "The internal name of the post type. This should not be used for display purposes."
    name: String @deprecated(reason : "")
    "Whether a post type is intended for use publicly either via the admin interface or by front-end users. While the default settings of exclude_from_search, publicly_queryable, show_ui, and show_in_nav_menus are inherited from public, each does not rely on this relationship and controls a very specific intention."
    public: Boolean @deprecated(reason : "")
    "Whether queries can be performed on the front end for the post type as part of parse_request()."
    publiclyQueryable: Boolean @deprecated(reason : "")
    "Name of content type to diplay in REST API &quot;wp/v2&quot; namespace."
    restBase: String @deprecated(reason : "")
    "The REST Controller class assigned to handling this content type."
    restControllerClass: String @deprecated(reason : "")
    "Makes this post type available via the admin bar."
    showInAdminBar: Boolean @deprecated(reason : "")
    "Whether to add the post type to the GraphQL Schema."
    showInGraphql: Boolean @deprecated(reason : "")
    "Where to show the post type in the admin menu. To work, $show_ui must be true. If true, the post type is shown in its own top level menu. If false, no menu is shown. If a string of an existing top level menu (eg. &quot;tools.php&quot; or &quot;edit.php?post_type=page&quot;), the post type will be placed as a sub-menu of that."
    showInMenu: Boolean @deprecated(reason : "")
    "Makes this post type available for selection in navigation menus."
    showInNavMenus: Boolean @deprecated(reason : "")
    "Whether to add the post type route in the REST API &quot;wp/v2&quot; namespace."
    showInRest: Boolean @deprecated(reason : "")
    "Whether to generate and allow a UI for managing this post type in the admin."
    showUi: Boolean @deprecated(reason : "")
}

"The payload for the createCategory mutation"
type BlogCreateCategoryPayload {
    "The created category"
    category: BlogCategory @deprecated(reason : "")
    clientMutationId: String! @deprecated(reason : "")
}

"The payload for the createComment mutation"
type BlogCreateCommentPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The comment that was created"
    comment: BlogComment @deprecated(reason : "")
    "Whether the mutation succeeded. If the comment is not approved, the server will not return the comment to a non authenticated user, but a success message can be returned if the create succeeded, and the client can optimistically add the comment to the client cache"
    success: Boolean @deprecated(reason : "")
}

"The payload for the createMediaItem mutation"
type BlogCreateMediaItemPayload {
    clientMutationId: String! @deprecated(reason : "")
    mediaItem: BlogMediaItem @deprecated(reason : "")
}

"The payload for the createPage mutation"
type BlogCreatePagePayload {
    clientMutationId: String! @deprecated(reason : "")
    page: BlogPage @deprecated(reason : "")
}

"The payload for the createPostFormat mutation"
type BlogCreatePostFormatPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The created post_format"
    postFormat: BlogPostFormat @deprecated(reason : "")
}

"The payload for the createPost mutation"
type BlogCreatePostPayload {
    clientMutationId: String! @deprecated(reason : "")
    post: BlogPost @deprecated(reason : "")
}

"The payload for the createTag mutation"
type BlogCreateTagPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The created post_tag"
    tag: BlogTag @deprecated(reason : "")
}

"The payload for the createUser mutation"
type BlogCreateUserPayload {
    clientMutationId: String! @deprecated(reason : "")
    user: BlogUser @deprecated(reason : "")
}

"The payload for the deleteCategory mutation"
type BlogDeleteCategoryPayload {
    "The deteted term object"
    category: BlogCategory @deprecated(reason : "")
    clientMutationId: String! @deprecated(reason : "")
    "The ID of the deleted object"
    deletedId: ID @deprecated(reason : "")
}

"The payload for the deleteComment mutation"
type BlogDeleteCommentPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The deleted comment object"
    comment: BlogComment @deprecated(reason : "")
    "The deleted comment ID"
    deletedId: ID @deprecated(reason : "")
}

"The payload for the deleteMediaItem mutation"
type BlogDeleteMediaItemPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The ID of the deleted mediaItem"
    deletedId: ID @deprecated(reason : "")
    "The mediaItem before it was deleted"
    mediaItem: BlogMediaItem @deprecated(reason : "")
}

"The payload for the deletePage mutation"
type BlogDeletePagePayload {
    clientMutationId: String! @deprecated(reason : "")
    "The ID of the deleted object"
    deletedId: ID @deprecated(reason : "")
    "The object before it was deleted"
    page: BlogPage @deprecated(reason : "")
}

"The payload for the deletePostFormat mutation"
type BlogDeletePostFormatPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The ID of the deleted object"
    deletedId: ID @deprecated(reason : "")
    "The deteted term object"
    postFormat: BlogPostFormat @deprecated(reason : "")
}

"The payload for the deletePost mutation"
type BlogDeletePostPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The ID of the deleted object"
    deletedId: ID @deprecated(reason : "")
    "The object before it was deleted"
    post: BlogPost @deprecated(reason : "")
}

"The payload for the deleteTag mutation"
type BlogDeleteTagPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The ID of the deleted object"
    deletedId: ID @deprecated(reason : "")
    "The deteted term object"
    tag: BlogTag @deprecated(reason : "")
}

"The payload for the deleteUser mutation"
type BlogDeleteUserPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The ID of the user that you just deleted"
    deletedId: ID @deprecated(reason : "")
    "The deleted user object"
    user: BlogUser @deprecated(reason : "")
}

"The discussion setting type"
type BlogDiscussionSettings {
    "Allow people to submit comments on new posts."
    defaultCommentStatus: String @deprecated(reason : "")
    "Allow link notifications from other blogs (pingbacks and trackbacks) on new articles."
    defaultPingStatus: String @deprecated(reason : "")
}

"Info on whether the object is locked by another user editing it"
type BlogEditLock {
    "The time when the object was last edited"
    editTime: String @deprecated(reason : "")
    "The user that most recently edited the object"
    user: BlogUser @deprecated(reason : "")
}

"The general setting type"
type BlogGeneralSettings {
    "A date format for all date strings."
    dateFormat: String @deprecated(reason : "")
    "Site tagline."
    description: String @deprecated(reason : "")
    "This address is used for admin purposes, like new user notification."
    email: String @deprecated(reason : "")
    "WordPress locale code."
    language: String @deprecated(reason : "")
    "A day number of the week that the week should start on."
    startOfWeek: Int @deprecated(reason : "")
    "A time format for all time strings."
    timeFormat: String @deprecated(reason : "")
    "A city in the same timezone as you."
    timezone: String @deprecated(reason : "")
    "Site title."
    title: String @deprecated(reason : "")
    "Site URL."
    url: String @deprecated(reason : "")
}

"File details for a Media Item"
type BlogMediaDetails {
    "The height of the mediaItem"
    file: String @deprecated(reason : "")
    "The height of the mediaItem"
    height: Int @deprecated(reason : "")
    meta: BlogMediaItemMeta @deprecated(reason : "")
    "The available sizes of the mediaItem"
    sizes: [BlogMediaSize] @deprecated(reason : "")
    "The width of the mediaItem"
    width: Int @deprecated(reason : "")
}

"The mediaItem type"
type BlogMediaItem implements BlogContentNode & BlogHierarchicalContentNode & BlogNode & BlogNodeWithAuthor & BlogNodeWithComments & BlogNodeWithTitle & BlogUniformResourceIdentifiable {
    "Alternative text to display when resource is not displayed"
    altText: String @deprecated(reason : "")
    "The caption for the resource"
    caption(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String @deprecated(reason : "")
    "The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility."
    commentCount: Int @deprecated(reason : "")
    "Whether the comments are open or closed for this particular post."
    commentStatus: String @deprecated(reason : "")
    "Connection between the mediaItem type and the Comment type"
    comments(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogMediaItemToCommentConnectionWhereArgs
    ): BlogMediaItemToCommentConnection @deprecated(reason : "")
    "Connection between the mediaItem type and the ContentType type"
    contentType: BlogMediaItemToContentTypeConnection @deprecated(reason : "")
    "The ID of the object in the database."
    databaseId: Int! @deprecated(reason : "")
    "Post publishing date."
    date: String @deprecated(reason : "")
    "The publishing date set in GMT."
    dateGmt: String @deprecated(reason : "")
    "Description of the image (stored as post_content)"
    description(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String @deprecated(reason : "")
    "The desired slug of the post"
    desiredSlug: String @deprecated(reason : "")
    "The user that most recently edited the object"
    editLast: BlogUser @deprecated(reason : "")
    "If a user has edited the object within the past 15 seconds, this will return the user and the time they last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds"
    editLock: BlogEditLock @deprecated(reason : "")
    "The RSS enclosure for the object"
    enclosure: String @deprecated(reason : "")
    "The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table."
    guid: String @deprecated(reason : "")
    "The globally unique identifier of the attachment object."
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "The permalink of the post"
    link: String @deprecated(reason : "")
    "Details about the mediaItem"
    mediaDetails: BlogMediaDetails @deprecated(reason : "")
    "The id field matches the WP_Post-&gt;ID field."
    mediaItemId: Int! @deprecated(reason : "Deprecated in favor of the databaseId field")
    "Url of the mediaItem"
    mediaItemUrl: String @deprecated(reason : "")
    "Type of resource"
    mediaType: String @deprecated(reason : "")
    "The mime type of the mediaItem"
    mimeType: String @deprecated(reason : "")
    "The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time."
    modified: String @deprecated(reason : "")
    "The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT."
    modifiedGmt: String @deprecated(reason : "")
    "The parent of the object. The parent object can be of various types"
    parent: BlogPostObjectUnion @deprecated(reason : "")
    "The sizes attribute value for an image."
    sizes(
        "Size of the MediaItem to calculate sizes with"
        size: BlogMediaItemSizeEnum
    ): String @deprecated(reason : "")
    "The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table."
    slug: String @deprecated(reason : "")
    "Url of the mediaItem"
    sourceUrl(
        "Size of the MediaItem to return"
        size: BlogMediaItemSizeEnum
    ): String @deprecated(reason : "")
    "The srcset attribute specifies the URL of the image to use in different situations. It is a comma separated string of urls and their widths."
    srcSet(
        "Size of the MediaItem to calculate srcSet with"
        size: BlogMediaItemSizeEnum
    ): String @deprecated(reason : "")
    "The current status of the object"
    status: String @deprecated(reason : "")
    "The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made."
    title(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String @deprecated(reason : "")
    "URI path for the resource"
    uri: String! @deprecated(reason : "")
    "The author field will return a queryable User type matching the post&#039;s author."
    wpAuthor: BlogUser @deprecated(reason : "")
}

"Meta connected to a MediaItem"
type BlogMediaItemMeta {
    aperture: Float @deprecated(reason : "")
    camera: String @deprecated(reason : "")
    caption: String @deprecated(reason : "")
    copyright: String @deprecated(reason : "")
    createdTimestamp: Int @deprecated(reason : "")
    credit: String @deprecated(reason : "")
    focalLength: Int @deprecated(reason : "")
    iso: Int @deprecated(reason : "")
    keywords: [String] @deprecated(reason : "")
    orientation: String @deprecated(reason : "")
    shutterSpeed: Float @deprecated(reason : "")
    title: String @deprecated(reason : "")
}

"Connection between the mediaItem type and the Comment type"
type BlogMediaItemToCommentConnection {
    "Edges for the MediaItemToCommentConnection connection"
    edges: [BlogMediaItemToCommentConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogComment] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogMediaItemToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogComment @deprecated(reason : "")
}

"Connection between the mediaItem type and the ContentType type"
type BlogMediaItemToContentTypeConnection {
    "The nodes of the connection, without the edges"
    node: BlogContentType @deprecated(reason : "")
}

"Details of an available size for a media item"
type BlogMediaSize {
    "The file of the for the referenced size"
    file: String @deprecated(reason : "")
    "The height of the for the referenced size"
    height: String @deprecated(reason : "")
    "The mime type of the resource"
    mimeType: String @deprecated(reason : "")
    "The referenced size name"
    name: String @deprecated(reason : "")
    "The url of the for the referenced size"
    sourceUrl: String @deprecated(reason : "")
    "The width of the for the referenced size"
    width: String @deprecated(reason : "")
}

"Menus are the containers for navigation items. Menus can be assigned to menu locations, which are typically registered by the active theme."
type BlogMenu implements BlogNode {
    "The number of items in the menu"
    count: Int @deprecated(reason : "")
    "The globally unique identifier of the nav menu object."
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "WP ID of the nav menu."
    menuId: Int @deprecated(reason : "")
    "Connection between the Menu type and the MenuItem type"
    menuItems(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogMenuToMenuItemConnectionWhereArgs
    ): BlogMenuToMenuItemConnection @deprecated(reason : "")
    "Display name of the menu. Equivalent to WP_Term-&gt;name."
    name: String @deprecated(reason : "")
    "The url friendly name of the menu. Equivalent to WP_Term-&gt;slug"
    slug: String @deprecated(reason : "")
}

"Navigation menu items are the individual items assigned to a menu. These are rendered as the links in a navigation menu."
type BlogMenuItem implements BlogNode {
    "Connection between the MenuItem type and the MenuItem type"
    childItems(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogMenuItemToMenuItemConnectionWhereArgs
    ): BlogMenuItemToMenuItemConnection @deprecated(reason : "")
    "The object connected to this menu item."
    connectedObject: BlogMenuItemObjectUnion @deprecated(reason : "")
    "Class attribute for the menu item link"
    cssClasses: [String] @deprecated(reason : "")
    "Description of the menu item."
    description: String @deprecated(reason : "")
    "The globally unique identifier of the nav menu item object."
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "Label or title of the menu item."
    label: String @deprecated(reason : "")
    "Link relationship (XFN) of the menu item."
    linkRelationship: String @deprecated(reason : "")
    "WP ID of the menu item."
    menuItemId: Int @deprecated(reason : "")
    "Target attribute for the menu item link."
    target: String @deprecated(reason : "")
    "Title attribute for the menu item link"
    title: String @deprecated(reason : "")
    "URL or destination of the menu item."
    url: String @deprecated(reason : "")
}

"Connection between the MenuItem type and the MenuItem type"
type BlogMenuItemToMenuItemConnection {
    "Edges for the MenuItemToMenuItemConnection connection"
    edges: [BlogMenuItemToMenuItemConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogMenuItem] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogMenuItemToMenuItemConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogMenuItem @deprecated(reason : "")
}

"Connection between the Menu type and the MenuItem type"
type BlogMenuToMenuItemConnection {
    "Edges for the MenuToMenuItemConnection connection"
    edges: [BlogMenuToMenuItemConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogMenuItem] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogMenuToMenuItemConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogMenuItem @deprecated(reason : "")
}

"The page type"
type BlogPage implements BlogContentNode & BlogHierarchicalContentNode & BlogNode & BlogNodeWithAuthor & BlogNodeWithComments & BlogNodeWithContentEditor & BlogNodeWithFeaturedImage & BlogNodeWithPageAttributes & BlogNodeWithRevisions & BlogNodeWithTitle & BlogUniformResourceIdentifiable {
    "Connection between the page type and the page type"
    childPages(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPageToPageConnectionWhereArgs
    ): BlogPageToPageConnection @deprecated(reason : "")
    "The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility."
    commentCount: Int @deprecated(reason : "")
    "Whether the comments are open or closed for this particular post."
    commentStatus: String @deprecated(reason : "")
    "Connection between the page type and the Comment type"
    comments(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPageToCommentConnectionWhereArgs
    ): BlogPageToCommentConnection @deprecated(reason : "")
    "The content of the post."
    content(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String @deprecated(reason : "")
    "Connection between the page type and the ContentType type"
    contentType: BlogPageToContentTypeConnection @deprecated(reason : "")
    "The ID of the object in the database."
    databaseId: Int! @deprecated(reason : "")
    "Post publishing date."
    date: String @deprecated(reason : "")
    "The publishing date set in GMT."
    dateGmt: String @deprecated(reason : "")
    "The desired slug of the post"
    desiredSlug: String @deprecated(reason : "")
    "The user that most recently edited the object"
    editLast: BlogUser @deprecated(reason : "")
    "If a user has edited the object within the past 15 seconds, this will return the user and the time they last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds"
    editLock: BlogEditLock @deprecated(reason : "")
    "The RSS enclosure for the object"
    enclosure: String @deprecated(reason : "")
    "The featured image for the object"
    featuredImage: BlogMediaItem @deprecated(reason : "")
    "The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table."
    guid: String @deprecated(reason : "")
    "The globally unique identifier of the page object."
    id: ID! @deprecated(reason : "")
    "Whether this page is set to the static front page."
    isFrontPage: Boolean! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "True if the node is a revision of another node"
    isRevision: Boolean @deprecated(reason : "")
    "The permalink of the post"
    link: String @deprecated(reason : "")
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int @deprecated(reason : "")
    "The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time."
    modified: String @deprecated(reason : "")
    "The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT."
    modifiedGmt: String @deprecated(reason : "")
    "The id field matches the WP_Post-&gt;ID field."
    pageId: Int! @deprecated(reason : "Deprecated in favor of the databaseId field")
    "The parent of the object. The parent object can be of various types"
    parent: BlogPostObjectUnion @deprecated(reason : "")
    "If the current node is a revision, this field exposes the node this is a revision of. Returns null if the node is not a revision of another node."
    revisionOf: BlogPostObjectUnion @deprecated(reason : "")
    "Connection between the page type and the page type"
    revisions(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPageToRevisionConnectionWhereArgs
    ): BlogPageToRevisionConnection @deprecated(reason : "")
    "The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table."
    slug: String @deprecated(reason : "")
    "The current status of the object"
    status: String @deprecated(reason : "")
    "The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made."
    title(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String @deprecated(reason : "")
    "URI path for the resource"
    uri: String! @deprecated(reason : "")
    "The author field will return a queryable User type matching the post&#039;s author."
    wpAuthor: BlogUser @deprecated(reason : "")
}

"Connection between the page type and the Comment type"
type BlogPageToCommentConnection {
    "Edges for the PageToCommentConnection connection"
    edges: [BlogPageToCommentConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogComment] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogPageToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogComment @deprecated(reason : "")
}

"Connection between the page type and the ContentType type"
type BlogPageToContentTypeConnection {
    "The nodes of the connection, without the edges"
    node: BlogContentType @deprecated(reason : "")
}

"Connection between the page type and the page type"
type BlogPageToPageConnection {
    "Edges for the PageToPageConnection connection"
    edges: [BlogPageToPageConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPage] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogPageToPageConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPage @deprecated(reason : "")
}

"Connection between the page type and the page type"
type BlogPageToRevisionConnection {
    "Edges for the pageToRevisionConnection connection"
    edges: [BlogPageToRevisionConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPage] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogPageToRevisionConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPage @deprecated(reason : "")
}

"An plugin object"
type BlogPlugin implements BlogNode {
    "Name of the plugin author(s), may also be a company name."
    author: String @deprecated(reason : "")
    "URI for the related author(s)/company website."
    authorUri: String @deprecated(reason : "")
    "Description of the plugin."
    description: String @deprecated(reason : "")
    "The globally unique identifier of the plugin object."
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "Display name of the plugin."
    name: String @deprecated(reason : "")
    "URI for the plugin website. This is useful for directing users for support requests etc."
    pluginUri: String @deprecated(reason : "")
    "Current version of the plugin."
    version: String @deprecated(reason : "")
}

"The post type"
type BlogPost implements BlogContentNode & BlogNode & BlogNodeWithAuthor & BlogNodeWithComments & BlogNodeWithContentEditor & BlogNodeWithExcerpt & BlogNodeWithFeaturedImage & BlogNodeWithRevisions & BlogNodeWithTitle & BlogNodeWithTrackbacks & BlogUniformResourceIdentifiable {
    author: AccountUser
    "This will change the author and/or title which is displayed on the blog to be different from the actual author."
    authorOverride: BlogPost_Authoroverride @deprecated(reason : "")
    "Connection between the post type and the category type"
    categories(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostToCategoryConnectionWhereArgs
    ): BlogPostToCategoryConnection @deprecated(reason : "")
    "The number of comments. Even though WPGraphQL denotes this field as an integer, in WordPress this field should be saved as a numeric string for compatibility."
    commentCount: Int @deprecated(reason : "")
    "Whether the comments are open or closed for this particular post."
    commentStatus: String @deprecated(reason : "")
    "Connection between the post type and the Comment type"
    comments(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostToCommentConnectionWhereArgs
    ): BlogPostToCommentConnection @deprecated(reason : "")
    "The content of the post."
    content(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String @deprecated(reason : "")
    "Connection between the post type and the ContentType type"
    contentType: BlogPostToContentTypeConnection @deprecated(reason : "")
    "The ID of the object in the database."
    databaseId: Int! @deprecated(reason : "")
    "Post publishing date."
    date: String @deprecated(reason : "")
    "The publishing date set in GMT."
    dateGmt: String @deprecated(reason : "")
    "The desired slug of the post"
    desiredSlug: String @deprecated(reason : "")
    "The user that most recently edited the object"
    editLast: BlogUser @deprecated(reason : "")
    "If a user has edited the object within the past 15 seconds, this will return the user and the time they last edited. Null if the edit lock doesn&#039;t exist or is greater than 15 seconds"
    editLock: BlogEditLock @deprecated(reason : "")
    "The RSS enclosure for the object"
    enclosure: String @deprecated(reason : "")
    "The excerpt of the post."
    excerpt(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String @deprecated(reason : "")
    "The featured image for the object"
    featuredImage: BlogMediaItem @deprecated(reason : "")
    "The global unique identifier for this post. This currently matches the value stored in WP_Post-&gt;guid and the guid column in the &quot;post_objects&quot; database table."
    guid: String @deprecated(reason : "")
    "The globally unique identifier of the post object."
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "True if the node is a revision of another node"
    isRevision: Boolean @deprecated(reason : "")
    "The permalink of the post"
    link: String @deprecated(reason : "")
    marketing: BlogPost_Marketing @deprecated(reason : "")
    "The local modified time for a post. If a post was recently updated the modified field will change to match the corresponding time."
    modified: String @deprecated(reason : "")
    "The GMT modified time for a post. If a post was recently updated the modified field will change to match the corresponding time in GMT."
    modifiedGmt: String @deprecated(reason : "")
    "Whether the pings are open or closed for this particular post."
    pingStatus: String @deprecated(reason : "")
    "URLs that have been pinged."
    pinged: [String] @deprecated(reason : "")
    "Connection between the post type and the postFormat type"
    postFormats(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostToPostFormatConnectionWhereArgs
    ): BlogPostToPostFormatConnection @deprecated(reason : "")
    "The id field matches the WP_Post-&gt;ID field."
    postId: Int! @deprecated(reason : "Deprecated in favor of the databaseId field")
    "If the current node is a revision, this field exposes the node this is a revision of. Returns null if the node is not a revision of another node."
    revisionOf: BlogPostObjectUnion @deprecated(reason : "")
    "Connection between the post type and the post type"
    revisions(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostToRevisionConnectionWhereArgs
    ): BlogPostToRevisionConnection @deprecated(reason : "")
    "The uri slug for the post. This is equivalent to the WP_Post-&gt;post_name field and the post_name column in the database for the &quot;post_objects&quot; table."
    slug: String @deprecated(reason : "")
    "The current status of the object"
    status: String @deprecated(reason : "")
    "Connection between the post type and the tag type"
    tags(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostToTagConnectionWhereArgs
    ): BlogPostToTagConnection @deprecated(reason : "")
    "Terms connected to the object"
    termNames(
        "Select which taxonomies to limit the results to"
        taxonomies: [BlogTaxonomyEnum]
    ): [String] @deprecated(reason : "")
    "Terms connected to the object"
    termSlugs(
        "Select which taxonomies to limit the results to"
        taxonomies: [BlogTaxonomyEnum]
    ): [String] @deprecated(reason : "")
    "Terms connected to the object"
    terms(
        "Select which taxonomies to limit the results to"
        taxonomies: [BlogTaxonomyEnum]
    ): [BlogTermObjectUnion] @deprecated(reason : "")
    "The title of the post. This is currently just the raw title. An amendment to support rendered title needs to be made."
    title(
        "Format of the field output"
        format: BlogPostObjectFieldFormatEnum
    ): String @deprecated(reason : "")
    "URLs queued to be pinged."
    toPing: [String] @deprecated(reason : "")
    "URI path for the resource"
    uri: String! @deprecated(reason : "")
    "The author field will return a queryable User type matching the post&#039;s author."
    wpAuthor: BlogUser @deprecated(reason : "")
}

"The postFormat type"
type BlogPostFormat implements BlogNode & BlogTermNode & BlogUniformResourceIdentifiable {
    "The number of objects connected to the object"
    count: Int @deprecated(reason : "")
    "Identifies the primary key from the database."
    databaseId: Int! @deprecated(reason : "")
    "The description of the object"
    description: String @deprecated(reason : "")
    "The globally unique ID for the object"
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "The link to the term"
    link: String @deprecated(reason : "")
    "The human friendly name of the object."
    name: String @deprecated(reason : "")
    "The id field matches the WP_Post-&gt;ID field."
    postFormatId: Int @deprecated(reason : "Deprecated in favor of databaseId")
    "Connection between the postFormat type and the post type"
    posts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogPostFormatToPostConnectionWhereArgs
    ): BlogPostFormatToPostConnection @deprecated(reason : "")
    "An alphanumeric identifier for the object unique to its type."
    slug: String @deprecated(reason : "")
    "Connection between the postFormat type and the Taxonomy type"
    taxonomy: BlogPostFormatToTaxonomyConnection @deprecated(reason : "")
    "The ID of the term group that this term object belongs to"
    termGroupId: Int @deprecated(reason : "")
    "The taxonomy ID that the object is associated with"
    termTaxonomyId: Int @deprecated(reason : "")
    "The unique resource identifier path"
    uri: String! @deprecated(reason : "")
}

"Connection between the postFormat type and the post type"
type BlogPostFormatToPostConnection {
    "Edges for the PostFormatToPostConnection connection"
    edges: [BlogPostFormatToPostConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPost] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogPostFormatToPostConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPost @deprecated(reason : "")
}

"Connection between the postFormat type and the Taxonomy type"
type BlogPostFormatToTaxonomyConnection {
    "The nodes of the connection, without the edges"
    node: BlogTaxonomy @deprecated(reason : "")
}

"Connection between the post type and the category type"
type BlogPostToCategoryConnection {
    "Edges for the PostToCategoryConnection connection"
    edges: [BlogPostToCategoryConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogCategory] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogPostToCategoryConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogCategory @deprecated(reason : "")
}

"Connection between the post type and the Comment type"
type BlogPostToCommentConnection {
    "Edges for the PostToCommentConnection connection"
    edges: [BlogPostToCommentConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogComment] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogPostToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogComment @deprecated(reason : "")
}

"Connection between the post type and the ContentType type"
type BlogPostToContentTypeConnection {
    "The nodes of the connection, without the edges"
    node: BlogContentType @deprecated(reason : "")
}

"Connection between the post type and the postFormat type"
type BlogPostToPostFormatConnection {
    "Edges for the PostToPostFormatConnection connection"
    edges: [BlogPostToPostFormatConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPostFormat] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogPostToPostFormatConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPostFormat @deprecated(reason : "")
}

"Connection between the post type and the post type"
type BlogPostToRevisionConnection {
    "Edges for the postToRevisionConnection connection"
    edges: [BlogPostToRevisionConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPost] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogPostToRevisionConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPost @deprecated(reason : "")
}

"Connection between the post type and the tag type"
type BlogPostToTagConnection {
    "Edges for the PostToTagConnection connection"
    edges: [BlogPostToTagConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogTag] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogPostToTagConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogTag @deprecated(reason : "")
}

"Details for labels of the PostType"
type BlogPostTypeLabelDetails {
    "Default is ‘Add New’ for both hierarchical and non-hierarchical types."
    addNew: String @deprecated(reason : "")
    "Label for adding a new singular item."
    addNewItem: String @deprecated(reason : "")
    "Label to signify all items in a submenu link."
    allItems: String @deprecated(reason : "")
    "Label for archives in nav menus"
    archives: String @deprecated(reason : "")
    "Label for the attributes meta box."
    attributes: String @deprecated(reason : "")
    "Label for editing a singular item."
    editItem: String @deprecated(reason : "")
    "Label for the Featured Image meta box title."
    featuredImage: String @deprecated(reason : "")
    "Label for the table views hidden heading."
    filterItemsList: String @deprecated(reason : "")
    "Label for the media frame button."
    insertIntoItem: String @deprecated(reason : "")
    "Label for the table hidden heading."
    itemsList: String @deprecated(reason : "")
    "Label for the table pagination hidden heading."
    itemsListNavigation: String @deprecated(reason : "")
    "Label for the menu name."
    menuName: String @deprecated(reason : "")
    "General name for the post type, usually plural."
    name: String @deprecated(reason : "")
    "Label for the new item page title."
    newItem: String @deprecated(reason : "")
    "Label used when no items are found."
    notFound: String @deprecated(reason : "")
    "Label used when no items are in the trash."
    notFoundInTrash: String @deprecated(reason : "")
    "Label used to prefix parents of hierarchical items."
    parentItemColon: String @deprecated(reason : "")
    "Label for removing the featured image."
    removeFeaturedImage: String @deprecated(reason : "")
    "Label for searching plural items."
    searchItems: String @deprecated(reason : "")
    "Label for setting the featured image."
    setFeaturedImage: String @deprecated(reason : "")
    "Name for one object of this post type."
    singularName: String @deprecated(reason : "")
    "Label for the media frame filter."
    uploadedToThisItem: String @deprecated(reason : "")
    "Label in the media frame for using a featured image."
    useFeaturedImage: String @deprecated(reason : "")
    "Label for viewing a singular item."
    viewItem: String @deprecated(reason : "")
    "Label for viewing post type archives."
    viewItems: String @deprecated(reason : "")
}

"Field Group"
type BlogPost_Authoroverride {
    fieldGroupName: String @deprecated(reason : "")
    title: String @deprecated(reason : "")
    username: String @deprecated(reason : "")
}

"Field Group"
type BlogPost_Marketing {
    "Who does this post most target?"
    audience: String @deprecated(reason : "")
    fieldGroupName: String @deprecated(reason : "")
}

"The reading setting type"
type BlogReadingSettings {
    "Blog pages show at most."
    postsPerPage: Int @deprecated(reason : "")
}

"The payload for the registerUser mutation"
type BlogRegisterUserPayload {
    clientMutationId: String! @deprecated(reason : "")
    user: BlogUser @deprecated(reason : "")
}

"The payload for the resetUserPassword mutation"
type BlogResetUserPasswordPayload {
    clientMutationId: String! @deprecated(reason : "")
    user: BlogUser @deprecated(reason : "")
}

"The payload for the restoreComment mutation"
type BlogRestoreCommentPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The restored comment object"
    comment: BlogComment @deprecated(reason : "")
    "The ID of the restored comment"
    restoredId: ID @deprecated(reason : "")
}

type BlogRootMutation {
    "The payload for the createComment mutation"
    createComment(
        "Input for the createComment mutation"
        input: BlogCreateCommentInput!
    ): BlogCreateCommentPayload @deprecated(reason : "")
}

type BlogRootQuery {
    "An object of the post Type. "
    post(id: ID!, idType: BlogPostIdType): BlogPost @deprecated(reason : "")
    "Connection between the RootQuery type and the post type"
    posts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogRootQueryToPostConnectionWhereArgs
    ): BlogRootQueryToPostConnection @deprecated(reason : "")
}

"Connection between the RootQuery type and the category type"
type BlogRootQueryToCategoryConnection {
    "Edges for the RootQueryToCategoryConnection connection"
    edges: [BlogRootQueryToCategoryConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogCategory] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToCategoryConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogCategory @deprecated(reason : "")
}

"Connection between the RootQuery type and the Comment type"
type BlogRootQueryToCommentConnection {
    "Edges for the RootQueryToCommentConnection connection"
    edges: [BlogRootQueryToCommentConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogComment] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogComment @deprecated(reason : "")
}

"Connection between the RootQuery type and the ContentNode type"
type BlogRootQueryToContentNodeConnection {
    "Edges for the RootQueryToContentNodeConnection connection"
    edges: [BlogRootQueryToContentNodeConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogContentNode] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToContentNodeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogContentNode @deprecated(reason : "")
}

"Connection between the RootQuery type and the ContentRevisionUnion type"
type BlogRootQueryToContentRevisionUnionConnection {
    "Edges for the RootQueryToContentRevisionUnionConnection connection"
    edges: [BlogRootQueryToContentRevisionUnionConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogContentRevisionUnion] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToContentRevisionUnionConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogContentRevisionUnion @deprecated(reason : "")
}

"Connection between the RootQuery type and the ContentType type"
type BlogRootQueryToContentTypeConnection {
    "Edges for the RootQueryToContentTypeConnection connection"
    edges: [BlogRootQueryToContentTypeConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogContentType] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToContentTypeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogContentType @deprecated(reason : "")
}

"Connection between the RootQuery type and the mediaItem type"
type BlogRootQueryToMediaItemConnection {
    "Edges for the RootQueryToMediaItemConnection connection"
    edges: [BlogRootQueryToMediaItemConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogMediaItem] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToMediaItemConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogMediaItem @deprecated(reason : "")
}

"Connection between the RootQuery type and the Menu type"
type BlogRootQueryToMenuConnection {
    "Edges for the RootQueryToMenuConnection connection"
    edges: [BlogRootQueryToMenuConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogMenu] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToMenuConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogMenu @deprecated(reason : "")
}

"Connection between the RootQuery type and the MenuItem type"
type BlogRootQueryToMenuItemConnection {
    "Edges for the RootQueryToMenuItemConnection connection"
    edges: [BlogRootQueryToMenuItemConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogMenuItem] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToMenuItemConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogMenuItem @deprecated(reason : "")
}

"Connection between the RootQuery type and the page type"
type BlogRootQueryToPageConnection {
    "Edges for the RootQueryToPageConnection connection"
    edges: [BlogRootQueryToPageConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPage] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToPageConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPage @deprecated(reason : "")
}

"Connection between the RootQuery type and the Plugin type"
type BlogRootQueryToPluginConnection {
    "Edges for the RootQueryToPluginConnection connection"
    edges: [BlogRootQueryToPluginConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPlugin] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToPluginConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPlugin @deprecated(reason : "")
}

"Connection between the RootQuery type and the post type"
type BlogRootQueryToPostConnection {
    "Edges for the RootQueryToPostConnection connection"
    edges: [BlogRootQueryToPostConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPost] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToPostConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPost @deprecated(reason : "")
}

"Connection between the RootQuery type and the postFormat type"
type BlogRootQueryToPostFormatConnection {
    "Edges for the RootQueryToPostFormatConnection connection"
    edges: [BlogRootQueryToPostFormatConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPostFormat] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToPostFormatConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPostFormat @deprecated(reason : "")
}

"Connection between the RootQuery type and the tag type"
type BlogRootQueryToTagConnection {
    "Edges for the RootQueryToTagConnection connection"
    edges: [BlogRootQueryToTagConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogTag] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToTagConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogTag @deprecated(reason : "")
}

"Connection between the RootQuery type and the Taxonomy type"
type BlogRootQueryToTaxonomyConnection {
    "Edges for the RootQueryToTaxonomyConnection connection"
    edges: [BlogRootQueryToTaxonomyConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogTaxonomy] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToTaxonomyConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogTaxonomy @deprecated(reason : "")
}

"Connection between the RootQuery type and the TermNode type"
type BlogRootQueryToTermNodeConnection {
    "Edges for the RootQueryToTermNodeConnection connection"
    edges: [BlogRootQueryToTermNodeConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogTermNode] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToTermNodeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogTermNode @deprecated(reason : "")
}

"Connection between the RootQuery type and the Theme type"
type BlogRootQueryToThemeConnection {
    "Edges for the RootQueryToThemeConnection connection"
    edges: [BlogRootQueryToThemeConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogTheme] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToThemeConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogTheme @deprecated(reason : "")
}

"Connection between the RootQuery type and the User type"
type BlogRootQueryToUserConnection {
    "Edges for the RootQueryToUserConnection connection"
    edges: [BlogRootQueryToUserConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogUser] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToUserConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogUser @deprecated(reason : "")
}

"Connection between the RootQuery type and the UserRole type"
type BlogRootQueryToUserRoleConnection {
    "Edges for the RootQueryToUserRoleConnection connection"
    edges: [BlogRootQueryToUserRoleConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogUserRole] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogRootQueryToUserRoleConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogUserRole @deprecated(reason : "")
}

"The payload for the sendPasswordResetEmail mutation"
type BlogSendPasswordResetEmailPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The user that the password reset email was sent to"
    user: BlogUser @deprecated(reason : "")
}

"All of the registered settings"
type BlogSettings {
    "Allow people to submit comments on new posts."
    discussionSettingsDefaultCommentStatus: String @deprecated(reason : "")
    "Allow link notifications from other blogs (pingbacks and trackbacks) on new articles."
    discussionSettingsDefaultPingStatus: String @deprecated(reason : "")
    "A date format for all date strings."
    generalSettingsDateFormat: String @deprecated(reason : "")
    "Site tagline."
    generalSettingsDescription: String @deprecated(reason : "")
    "This address is used for admin purposes, like new user notification."
    generalSettingsEmail: String @deprecated(reason : "")
    "WordPress locale code."
    generalSettingsLanguage: String @deprecated(reason : "")
    "A day number of the week that the week should start on."
    generalSettingsStartOfWeek: Int @deprecated(reason : "")
    "A time format for all time strings."
    generalSettingsTimeFormat: String @deprecated(reason : "")
    "A city in the same timezone as you."
    generalSettingsTimezone: String @deprecated(reason : "")
    "Site title."
    generalSettingsTitle: String @deprecated(reason : "")
    "Site URL."
    generalSettingsUrl: String @deprecated(reason : "")
    "Blog pages show at most."
    readingSettingsPostsPerPage: Int @deprecated(reason : "")
    "Default post category."
    writingSettingsDefaultCategory: Int @deprecated(reason : "")
    "Default post format."
    writingSettingsDefaultPostFormat: String @deprecated(reason : "")
    "Convert emoticons like :-) and :-P to graphics on display."
    writingSettingsUseSmilies: Boolean @deprecated(reason : "")
}

"The tag type"
type BlogTag implements BlogNode & BlogTermNode & BlogUniformResourceIdentifiable {
    "The number of objects connected to the object"
    count: Int @deprecated(reason : "")
    "Identifies the primary key from the database."
    databaseId: Int! @deprecated(reason : "")
    "The description of the object"
    description: String @deprecated(reason : "")
    "The globally unique ID for the object"
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "The link to the term"
    link: String @deprecated(reason : "")
    "The human friendly name of the object."
    name: String @deprecated(reason : "")
    "Connection between the tag type and the post type"
    posts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogTagToPostConnectionWhereArgs
    ): BlogTagToPostConnection @deprecated(reason : "")
    "An alphanumeric identifier for the object unique to its type."
    slug: String @deprecated(reason : "")
    "The id field matches the WP_Post-&gt;ID field."
    tagId: Int @deprecated(reason : "Deprecated in favor of databaseId")
    "Connection between the tag type and the Taxonomy type"
    taxonomy: BlogTagToTaxonomyConnection @deprecated(reason : "")
    "The ID of the term group that this term object belongs to"
    termGroupId: Int @deprecated(reason : "")
    "The taxonomy ID that the object is associated with"
    termTaxonomyId: Int @deprecated(reason : "")
    "The unique resource identifier path"
    uri: String! @deprecated(reason : "")
}

"Connection between the tag type and the post type"
type BlogTagToPostConnection {
    "Edges for the TagToPostConnection connection"
    edges: [BlogTagToPostConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPost] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogTagToPostConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPost @deprecated(reason : "")
}

"Connection between the tag type and the Taxonomy type"
type BlogTagToTaxonomyConnection {
    "The nodes of the connection, without the edges"
    node: BlogTaxonomy @deprecated(reason : "")
}

"A taxonomy object"
type BlogTaxonomy implements BlogNode {
    "A list of Post Types associated with the taxonomy"
    connectedPostTypeNames(
        "Select which post types to limit the results to"
        types: [BlogContentTypeEnum]
    ): [String] @deprecated(reason : "")
    "List of Post Types connected to the Taxonomy"
    connectedPostTypes(
        "Select which post types to limit the results to"
        types: [BlogContentTypeEnum]
    ): [BlogContentType] @deprecated(reason : "")
    "Description of the taxonomy. This field is equivalent to WP_Taxonomy-&gt;description"
    description: String @deprecated(reason : "")
    "The plural name of the post type within the GraphQL Schema."
    graphqlPluralName: String @deprecated(reason : "")
    "The singular name of the post type within the GraphQL Schema."
    graphqlSingleName: String @deprecated(reason : "")
    "Whether the taxonomy is hierarchical"
    hierarchical: Boolean @deprecated(reason : "")
    "The globally unique identifier of the taxonomy object."
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "Name of the taxonomy shown in the menu. Usually plural."
    label: String @deprecated(reason : "")
    "The display name of the taxonomy. This field is equivalent to WP_Taxonomy-&gt;label"
    name: String @deprecated(reason : "")
    "Whether the taxonomy is publicly queryable"
    public: Boolean @deprecated(reason : "")
    "Name of content type to diplay in REST API &quot;wp/v2&quot; namespace."
    restBase: String @deprecated(reason : "")
    "The REST Controller class assigned to handling this content type."
    restControllerClass: String @deprecated(reason : "")
    "Whether to show the taxonomy as part of a tag cloud widget. This field is equivalent to WP_Taxonomy-&gt;show_tagcloud"
    showCloud: Boolean @deprecated(reason : "")
    "Whether to display a column for the taxonomy on its post type listing screens."
    showInAdminColumn: Boolean @deprecated(reason : "")
    "Whether to add the post type to the GraphQL Schema."
    showInGraphql: Boolean @deprecated(reason : "")
    "Whether to show the taxonomy in the admin menu"
    showInMenu: Boolean @deprecated(reason : "")
    "Whether the taxonomy is available for selection in navigation menus."
    showInNavMenus: Boolean @deprecated(reason : "")
    "Whether to show the taxonomy in the quick/bulk edit panel."
    showInQuickEdit: Boolean @deprecated(reason : "")
    "Whether to add the post type route in the REST API &quot;wp/v2&quot; namespace."
    showInRest: Boolean @deprecated(reason : "")
    "Whether to generate and allow a UI for managing terms in this taxonomy in the admin"
    showUi: Boolean @deprecated(reason : "")
}

"A theme object"
type BlogTheme implements BlogNode {
    "Name of the theme author(s), could also be a company name. This field is equivalent to WP_Theme-&gt;get( &quot;Author&quot; )."
    author: String @deprecated(reason : "")
    "URI for the author/company website. This field is equivalent to WP_Theme-&gt;get( &quot;AuthorURI&quot; )."
    authorUri: String @deprecated(reason : "")
    "The description of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Description&quot; )."
    description: String @deprecated(reason : "")
    "The globally unique identifier of the theme object."
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "Display name of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Name&quot; )."
    name: String @deprecated(reason : "")
    "The URL of the screenshot for the theme. The screenshot is intended to give an overview of what the theme looks like. This field is equivalent to WP_Theme-&gt;get_screenshot()."
    screenshot: String @deprecated(reason : "")
    "The theme slug is used to internally match themes. Theme slugs can have subdirectories like: my-theme/sub-theme. This field is equivalent to WP_Theme-&gt;get_stylesheet()."
    slug: String @deprecated(reason : "")
    "URI for the author/company website. This field is equivalent to WP_Theme-&gt;get( &quot;Tags&quot; )."
    tags: [String] @deprecated(reason : "")
    "A URI if the theme has a website associated with it. The Theme URI is handy for directing users to a theme site for support etc. This field is equivalent to WP_Theme-&gt;get( &quot;ThemeURI&quot; )."
    themeUri: String @deprecated(reason : "")
    "The current version of the theme. This field is equivalent to WP_Theme-&gt;get( &quot;Version&quot; )."
    version: Float @deprecated(reason : "")
}

"The payload for the UpdateCategory mutation"
type BlogUpdateCategoryPayload {
    "The created category"
    category: BlogCategory @deprecated(reason : "")
    clientMutationId: String! @deprecated(reason : "")
}

"The payload for the updateComment mutation"
type BlogUpdateCommentPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The comment that was created"
    comment: BlogComment @deprecated(reason : "")
    "Whether the mutation succeeded. If the comment is not approved, the server will not return the comment to a non authenticated user, but a success message can be returned if the create succeeded, and the client can optimistically add the comment to the client cache"
    success: Boolean @deprecated(reason : "")
}

"The payload for the updateMediaItem mutation"
type BlogUpdateMediaItemPayload {
    clientMutationId: String! @deprecated(reason : "")
    mediaItem: BlogMediaItem @deprecated(reason : "")
}

"The payload for the updatePage mutation"
type BlogUpdatePagePayload {
    clientMutationId: String! @deprecated(reason : "")
    page: BlogPage @deprecated(reason : "")
}

"The payload for the UpdatePostFormat mutation"
type BlogUpdatePostFormatPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The created post_format"
    postFormat: BlogPostFormat @deprecated(reason : "")
}

"The payload for the updatePost mutation"
type BlogUpdatePostPayload {
    clientMutationId: String! @deprecated(reason : "")
    post: BlogPost @deprecated(reason : "")
}

"The payload for the updateSettings mutation"
type BlogUpdateSettingsPayload {
    allSettings: BlogSettings @deprecated(reason : "")
    clientMutationId: String! @deprecated(reason : "")
    discussionSettings: BlogDiscussionSettings @deprecated(reason : "")
    generalSettings: BlogGeneralSettings @deprecated(reason : "")
    readingSettings: BlogReadingSettings @deprecated(reason : "")
    writingSettings: BlogWritingSettings @deprecated(reason : "")
}

"The payload for the UpdateTag mutation"
type BlogUpdateTagPayload {
    clientMutationId: String! @deprecated(reason : "")
    "The created post_tag"
    tag: BlogTag @deprecated(reason : "")
}

"The payload for the updateUser mutation"
type BlogUpdateUserPayload {
    clientMutationId: String! @deprecated(reason : "")
    user: BlogUser @deprecated(reason : "")
}

"A User object"
type BlogUser implements BlogNode & BlogUniformResourceIdentifiable {
    "Avatar object for user. The avatar object can be retrieved in different sizes by specifying the size argument."
    avatar(
        "Whether to always show the default image, never the Gravatar. Default false"
        forceDefault: Boolean,
        rating: BlogAvatarRatingEnum,
        "The size attribute of the avatar field can be used to fetch avatars of different sizes. The value corresponds to the dimension in pixels to fetch. The default is 96 pixels."
        size: Int = 96
    ): BlogAvatar @deprecated(reason : "")
    "User metadata option name. Usually it will be &quot;wp_capabilities&quot;."
    capKey: String @deprecated(reason : "")
    "A list of capabilities (permissions) granted to the user"
    capabilities: [String] @deprecated(reason : "")
    "Connection between the User type and the Comment type"
    comments(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogUserToCommentConnectionWhereArgs
    ): BlogUserToCommentConnection @deprecated(reason : "")
    "Identifies the primary key from the database."
    databaseId: Int! @deprecated(reason : "")
    "Description of the user."
    description: String @deprecated(reason : "")
    "Email address of the user. This is equivalent to the WP_User-&gt;user_email property."
    email: String @deprecated(reason : "")
    "A complete list of capabilities including capabilities inherited from a role. This is equivalent to the array keys of WP_User-&gt;allcaps."
    extraCapabilities: [String] @deprecated(reason : "")
    "First name of the user. This is equivalent to the WP_User-&gt;user_first_name property."
    firstName: String @deprecated(reason : "")
    "The globally unique identifier for the user object."
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "Last name of the user. This is equivalent to the WP_User-&gt;user_last_name property."
    lastName: String @deprecated(reason : "")
    "The preferred language locale set for the user. Value derived from get_user_locale()."
    locale: String @deprecated(reason : "")
    "Connection between the User type and the mediaItem type"
    mediaItems(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogUserToMediaItemConnectionWhereArgs
    ): BlogUserToMediaItemConnection @deprecated(reason : "")
    "Display name of the user. This is equivalent to the WP_User-&gt;dispaly_name property."
    name: String @deprecated(reason : "")
    "The nicename for the user. This field is equivalent to WP_User-&gt;user_nicename"
    nicename: String @deprecated(reason : "")
    "Nickname of the user."
    nickname: String @deprecated(reason : "")
    "Connection between the User type and the page type"
    pages(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogUserToPageConnectionWhereArgs
    ): BlogUserToPageConnection @deprecated(reason : "")
    "Connection between the User type and the post type"
    posts(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogUserToPostConnectionWhereArgs
    ): BlogUserToPostConnection @deprecated(reason : "")
    "The date the user registered or was created. The field follows a full ISO8601 date string format."
    registeredDate: String @deprecated(reason : "")
    "Connection between the User and Revisions authored by the user"
    revisions(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int,
        "Arguments for filtering the connection"
        where: BlogUserToContentRevisionUnionConnectionWhereArgs
    ): BlogUserToContentRevisionUnionConnection @deprecated(reason : "")
    "Connection between the User type and the UserRole type"
    roles(
        "Cursor used along with the \"first\" argument to reference where in the dataset to get data"
        after: String,
        "Cursor used along with the \"last\" argument to reference where in the dataset to get data"
        before: String,
        "The number of items to return after the referenced \"after\" cursor"
        first: Int,
        last: Int
    ): BlogUserToUserRoleConnection @deprecated(reason : "")
    "The slug for the user. This field is equivalent to WP_User-&gt;user_nicename"
    slug: String @deprecated(reason : "")
    "The unique resource identifier path"
    uri: String! @deprecated(reason : "")
    "A website url that is associated with the user."
    url: String @deprecated(reason : "")
    "The Id of the user. Equivalent to WP_User-&gt;ID"
    userId: Int @deprecated(reason : "")
    "Username for the user. This field is equivalent to WP_User-&gt;user_login."
    username: String @deprecated(reason : "")
}

"A user role object"
type BlogUserRole implements BlogNode {
    "The capabilities that belong to this role"
    capabilities: [String] @deprecated(reason : "")
    "The display name of the role"
    displayName: String @deprecated(reason : "")
    "The globally unique identifier for the user role object."
    id: ID! @deprecated(reason : "")
    "Whether the object is restricted from the current viewer"
    isRestricted: Boolean @deprecated(reason : "")
    "The registered name of the role"
    name: String @deprecated(reason : "")
}

"Connection between the User type and the Comment type"
type BlogUserToCommentConnection {
    "Edges for the UserToCommentConnection connection"
    edges: [BlogUserToCommentConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogComment] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogUserToCommentConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogComment @deprecated(reason : "")
}

"Connection between the User type and the ContentRevisionUnion type"
type BlogUserToContentRevisionUnionConnection {
    "Edges for the UserToContentRevisionUnionConnection connection"
    edges: [BlogUserToContentRevisionUnionConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogContentRevisionUnion] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogUserToContentRevisionUnionConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogContentRevisionUnion @deprecated(reason : "")
}

"Connection between the User type and the mediaItem type"
type BlogUserToMediaItemConnection {
    "Edges for the UserToMediaItemConnection connection"
    edges: [BlogUserToMediaItemConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogMediaItem] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogUserToMediaItemConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogMediaItem @deprecated(reason : "")
}

"Connection between the User type and the page type"
type BlogUserToPageConnection {
    "Edges for the UserToPageConnection connection"
    edges: [BlogUserToPageConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPage] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogUserToPageConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPage @deprecated(reason : "")
}

"Connection between the User type and the post type"
type BlogUserToPostConnection {
    "Edges for the UserToPostConnection connection"
    edges: [BlogUserToPostConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogPost] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogUserToPostConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogPost @deprecated(reason : "")
}

"Connection between the User type and the UserRole type"
type BlogUserToUserRoleConnection {
    "Edges for the UserToUserRoleConnection connection"
    edges: [BlogUserToUserRoleConnectionEdge] @deprecated(reason : "")
    "The nodes of the connection, without the edges"
    nodes: [BlogUserRole] @deprecated(reason : "")
    "Information about pagination in a connection."
    pageInfo: BlogWPPageInfo @deprecated(reason : "")
}

"An edge in a connection"
type BlogUserToUserRoleConnectionEdge {
    "A cursor for use in pagination"
    cursor: String @deprecated(reason : "")
    "The item at the end of the edge"
    node: BlogUserRole @deprecated(reason : "")
}

"Information about pagination in a connection."
type BlogWPPageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String @deprecated(reason : "")
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean! @deprecated(reason : "")
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean! @deprecated(reason : "")
    "When paginating backwards, the cursor to continue."
    startCursor: String @deprecated(reason : "")
}

"The writing setting type"
type BlogWritingSettings {
    "Default post category."
    defaultCategory: Int @deprecated(reason : "")
    "Default post format."
    defaultPostFormat: String @deprecated(reason : "")
    "Convert emoticons like :-) and :-P to graphics on display."
    useSmilies: Boolean @deprecated(reason : "")
}

type CalendarCalendarEvent {
    calendarId: String!
    calendarName: String!
    description: String!
    end: CalendarDateTime!
    id: ID!
    location: String!
    metadata: CalendarJSONObject!
    start: CalendarDateTime!
    subscriberCount: Float!
    title: String!
}

type CalendarMutation {
    subscribe(calendarId: String!, destination: String!, eventId: String!): Boolean!
}

type CalendarQuery {
    event(calendars: [String!], format: CalendarFormat = HTML, id: ID!): CalendarCalendarEvent
    events(after: CalendarDateTime!, before: CalendarDateTime!, calendars: [String!], exceptCalendars: [String!], format: CalendarFormat = HTML, order: CalendarOrder = ASC, skip: Float = 0.0, take: Float = 100.0): [CalendarCalendarEvent!]!
}

type ClearAffectedRowsOutput {
    count: Int!
}

type ClearAggregateEvent {
    _avg: ClearEventAvgAggregate
    _count: ClearEventCountAggregate
    _max: ClearEventMaxAggregate
    _min: ClearEventMinAggregate
    _sum: ClearEventSumAggregate
}

type ClearAggregateEventGroup {
    _avg: ClearEventGroupAvgAggregate
    _count: ClearEventGroupCountAggregate
    _max: ClearEventGroupMaxAggregate
    _min: ClearEventGroupMinAggregate
    _sum: ClearEventGroupSumAggregate
}

type ClearAggregatePayment {
    _avg: ClearPaymentAvgAggregate
    _count: ClearPaymentCountAggregate
    _max: ClearPaymentMaxAggregate
    _min: ClearPaymentMinAggregate
    _sum: ClearPaymentSumAggregate
}

type ClearAggregatePerson {
    _avg: ClearPersonAvgAggregate
    _count: ClearPersonCountAggregate
    _max: ClearPersonMaxAggregate
    _min: ClearPersonMinAggregate
    _sum: ClearPersonSumAggregate
}

type ClearAggregateScheduleItem {
    _count: ClearScheduleItemCountAggregate
    _max: ClearScheduleItemMaxAggregate
    _min: ClearScheduleItemMinAggregate
}

type ClearAggregateSponsor {
    _avg: ClearSponsorAvgAggregate
    _count: ClearSponsorCountAggregate
    _max: ClearSponsorMaxAggregate
    _min: ClearSponsorMinAggregate
    _sum: ClearSponsorSumAggregate
}

type ClearAggregateTicket {
    _avg: ClearTicketAvgAggregate
    _count: ClearTicketCountAggregate
    _max: ClearTicketMaxAggregate
    _min: ClearTicketMinAggregate
    _sum: ClearTicketSumAggregate
}

type ClearAggregateVenue {
    _avg: ClearVenueAvgAggregate
    _count: ClearVenueCountAggregate
    _max: ClearVenueMaxAggregate
    _min: ClearVenueMinAggregate
    _sum: ClearVenueSumAggregate
}

type ClearEvent {
    _count: ClearEventCount
    contentfulWebname: String
    createdAt: ClearDateTime!
    displayDate: String!
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroup!
    eventGroupId: String!
    getMetadata(key: String!): String
    id: String!
    managers: [String!]!
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean!
    schedule(cursor: ClearScheduleItemWhereUniqueInput, distinct: [ClearScheduleItemScalarFieldEnum!], orderBy: [ClearScheduleItemOrderByWithRelationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): [ClearScheduleItem!]!
    sponsors(cursor: ClearSponsorWhereUniqueInput, distinct: [ClearSponsorScalarFieldEnum!], orderBy: [ClearSponsorOrderByWithRelationInput!], skip: Int, take: Int, where: ClearSponsorWhereInput): [ClearSponsor!]!
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicket!]!
    updatedAt: ClearDateTime!
    venue: ClearVenue
    venueId: String
}

type ClearEventAvgAggregate {
    earlyBirdPrice: Float
    ticketPrice: Float
}

type ClearEventCount {
    schedule: Int!
    sponsors: Int!
    tickets: Int!
}

type ClearEventCountAggregate {
    _all: Int!
    contentfulWebname: Int!
    createdAt: Int!
    earlyBirdCutoff: Int!
    earlyBirdPrice: Int!
    endDate: Int!
    eventGroupId: Int!
    id: Int!
    managers: Int!
    metadata: Int!
    name: Int!
    registrationCutoff: Int!
    registrationsOpen: Int!
    startDate: Int!
    ticketPrice: Int!
    updatedAt: Int!
    venueId: Int!
}

type ClearEventGroup {
    _count: ClearEventGroupCount
    createdAt: ClearDateTime!
    displayDate: String!
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    events(cursor: ClearEventWhereUniqueInput, distinct: [ClearEventScalarFieldEnum!], orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): [ClearEvent!]!
    getMetadata(key: String!): String
    id: String!
    name: String!
    registrationCutoff: ClearDateTime!
    schedule(cursor: ClearScheduleItemWhereUniqueInput, distinct: [ClearScheduleItemScalarFieldEnum!], orderBy: [ClearScheduleItemOrderByWithRelationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): [ClearScheduleItem!]!
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime!
}

type ClearEventGroupAvgAggregate {
    earlyBirdPrice: Float
    ticketPrice: Float
}

type ClearEventGroupBy {
    _avg: ClearEventAvgAggregate
    _count: ClearEventCountAggregate
    _max: ClearEventMaxAggregate
    _min: ClearEventMinAggregate
    _sum: ClearEventSumAggregate
    contentfulWebname: String
    createdAt: ClearDateTime!
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroupId: String!
    id: String!
    managers: [String!]
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean!
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime!
    venueId: String
}

type ClearEventGroupCount {
    events: Int!
    schedule: Int!
}

type ClearEventGroupCountAggregate {
    _all: Int!
    createdAt: Int!
    earlyBirdCutoff: Int!
    earlyBirdPrice: Int!
    endDate: Int!
    id: Int!
    metadata: Int!
    name: Int!
    registrationCutoff: Int!
    startDate: Int!
    ticketPrice: Int!
    updatedAt: Int!
}

type ClearEventGroupGroupBy {
    _avg: ClearEventGroupAvgAggregate
    _count: ClearEventGroupCountAggregate
    _max: ClearEventGroupMaxAggregate
    _min: ClearEventGroupMinAggregate
    _sum: ClearEventGroupSumAggregate
    createdAt: ClearDateTime!
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    id: String!
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime!
}

type ClearEventGroupMaxAggregate {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime
    earlyBirdPrice: Float
    endDate: ClearDateTime
    id: String
    name: String
    registrationCutoff: ClearDateTime
    startDate: ClearDateTime
    ticketPrice: Float
    updatedAt: ClearDateTime
}

type ClearEventGroupMinAggregate {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime
    earlyBirdPrice: Float
    endDate: ClearDateTime
    id: String
    name: String
    registrationCutoff: ClearDateTime
    startDate: ClearDateTime
    ticketPrice: Float
    updatedAt: ClearDateTime
}

type ClearEventGroupSumAggregate {
    earlyBirdPrice: Float
    ticketPrice: Float
}

type ClearEventMaxAggregate {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime
    earlyBirdPrice: Float
    endDate: ClearDateTime
    eventGroupId: String
    id: String
    name: String
    registrationCutoff: ClearDateTime
    registrationsOpen: Boolean
    startDate: ClearDateTime
    ticketPrice: Float
    updatedAt: ClearDateTime
    venueId: String
}

type ClearEventMinAggregate {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime
    earlyBirdPrice: Float
    endDate: ClearDateTime
    eventGroupId: String
    id: String
    name: String
    registrationCutoff: ClearDateTime
    registrationsOpen: Boolean
    startDate: ClearDateTime
    ticketPrice: Float
    updatedAt: ClearDateTime
    venueId: String
}

type ClearEventSumAggregate {
    earlyBirdPrice: Float
    ticketPrice: Float
}

type ClearMutation {
    createEvent(data: ClearEventCreateInput!): ClearEvent!
    createEventGroup(data: ClearEventGroupCreateInput!): ClearEventGroup!
    createManyEvent(data: [ClearEventCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyEventGroup(data: [ClearEventGroupCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyPayment(data: [ClearPaymentCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyPerson(data: [ClearPersonCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyScheduleItem(data: [ClearScheduleItemCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManySponsor(data: [ClearSponsorCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyTicket(data: [ClearTicketCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createManyVenue(data: [ClearVenueCreateManyInput!]!, skipDuplicates: Boolean): ClearAffectedRowsOutput!
    createPayment(data: ClearPaymentCreateInput!): ClearPayment!
    createPerson(data: ClearPersonCreateInput!): ClearPerson!
    createScheduleItem(data: ClearScheduleItemCreateInput!): ClearScheduleItem!
    createSponsor(data: ClearSponsorCreateInput!): ClearSponsor!
    createTicket(data: ClearTicketCreateInput!): ClearTicket!
    createVenue(data: ClearVenueCreateInput!): ClearVenue!
    deleteEvent(where: ClearEventWhereUniqueInput!): ClearEvent
    deleteEventGroup(where: ClearEventGroupWhereUniqueInput!): ClearEventGroup
    deleteManyEvent(where: ClearEventWhereInput): ClearAffectedRowsOutput!
    deleteManyEventGroup(where: ClearEventGroupWhereInput): ClearAffectedRowsOutput!
    deleteManyPayment(where: ClearPaymentWhereInput): ClearAffectedRowsOutput!
    deleteManyPerson(where: ClearPersonWhereInput): ClearAffectedRowsOutput!
    deleteManyScheduleItem(where: ClearScheduleItemWhereInput): ClearAffectedRowsOutput!
    deleteManySponsor(where: ClearSponsorWhereInput): ClearAffectedRowsOutput!
    deleteManyTicket(where: ClearTicketWhereInput): ClearAffectedRowsOutput!
    deleteManyVenue(where: ClearVenueWhereInput): ClearAffectedRowsOutput!
    deletePayment(where: ClearPaymentWhereUniqueInput!): ClearPayment
    deletePerson(where: ClearPersonWhereUniqueInput!): ClearPerson
    deleteScheduleItem(where: ClearScheduleItemWhereUniqueInput!): ClearScheduleItem
    deleteSponsor(where: ClearSponsorWhereUniqueInput!): ClearSponsor
    deleteTicket(where: ClearTicketWhereUniqueInput!): ClearTicket
    deleteVenue(where: ClearVenueWhereUniqueInput!): ClearVenue
    setEventGroupMetadata(key: String!, value: String!, where: ClearEventGroupWhereUniqueInput!): ClearEventGroup
    setEventMetadata(key: String!, value: String!, where: ClearEventWhereUniqueInput!): ClearEvent
    setPaymentMetadata(key: String!, value: String!, where: ClearPaymentWhereUniqueInput!): ClearPayment
    setPersonMetadata(key: String!, value: String!, where: ClearPersonWhereUniqueInput!): ClearPerson
    setScheduleItemMetadata(key: String!, value: String!, where: ClearScheduleItemWhereUniqueInput!): ClearScheduleItem
    setSponsorMetadata(key: String!, value: String!, where: ClearSponsorWhereUniqueInput!): ClearSponsor
    setTicketMetadata(key: String!, value: String!, where: ClearTicketWhereUniqueInput!): ClearTicket
    setVenueMetadata(key: String!, value: String!, where: ClearVenueWhereUniqueInput!): ClearVenue
    updateEvent(data: ClearEventUpdateInput!, where: ClearEventWhereUniqueInput!): ClearEvent
    updateEventGroup(data: ClearEventGroupUpdateInput!, where: ClearEventGroupWhereUniqueInput!): ClearEventGroup
    updateManyEvent(data: ClearEventUpdateManyMutationInput!, where: ClearEventWhereInput): ClearAffectedRowsOutput!
    updateManyEventGroup(data: ClearEventGroupUpdateManyMutationInput!, where: ClearEventGroupWhereInput): ClearAffectedRowsOutput!
    updateManyPayment(data: ClearPaymentUpdateManyMutationInput!, where: ClearPaymentWhereInput): ClearAffectedRowsOutput!
    updateManyPerson(data: ClearPersonUpdateManyMutationInput!, where: ClearPersonWhereInput): ClearAffectedRowsOutput!
    updateManyScheduleItem(data: ClearScheduleItemUpdateManyMutationInput!, where: ClearScheduleItemWhereInput): ClearAffectedRowsOutput!
    updateManySponsor(data: ClearSponsorUpdateManyMutationInput!, where: ClearSponsorWhereInput): ClearAffectedRowsOutput!
    updateManyTicket(data: ClearTicketUpdateManyMutationInput!, where: ClearTicketWhereInput): ClearAffectedRowsOutput!
    updateManyVenue(data: ClearVenueUpdateManyMutationInput!, where: ClearVenueWhereInput): ClearAffectedRowsOutput!
    updatePayment(data: ClearPaymentUpdateInput!, where: ClearPaymentWhereUniqueInput!): ClearPayment
    updatePerson(data: ClearPersonUpdateInput!, where: ClearPersonWhereUniqueInput!): ClearPerson
    updateScheduleItem(data: ClearScheduleItemUpdateInput!, where: ClearScheduleItemWhereUniqueInput!): ClearScheduleItem
    updateSponsor(data: ClearSponsorUpdateInput!, where: ClearSponsorWhereUniqueInput!): ClearSponsor
    updateTicket(data: ClearTicketUpdateInput!, where: ClearTicketWhereUniqueInput!): ClearTicket
    updateVenue(data: ClearVenueUpdateInput!, where: ClearVenueWhereUniqueInput!): ClearVenue
    upsertEvent(create: ClearEventCreateInput!, update: ClearEventUpdateInput!, where: ClearEventWhereUniqueInput!): ClearEvent!
    upsertEventGroup(create: ClearEventGroupCreateInput!, update: ClearEventGroupUpdateInput!, where: ClearEventGroupWhereUniqueInput!): ClearEventGroup!
    upsertPayment(create: ClearPaymentCreateInput!, update: ClearPaymentUpdateInput!, where: ClearPaymentWhereUniqueInput!): ClearPayment!
    upsertPerson(create: ClearPersonCreateInput!, update: ClearPersonUpdateInput!, where: ClearPersonWhereUniqueInput!): ClearPerson!
    upsertScheduleItem(create: ClearScheduleItemCreateInput!, update: ClearScheduleItemUpdateInput!, where: ClearScheduleItemWhereUniqueInput!): ClearScheduleItem!
    upsertSponsor(create: ClearSponsorCreateInput!, update: ClearSponsorUpdateInput!, where: ClearSponsorWhereUniqueInput!): ClearSponsor!
    upsertTicket(create: ClearTicketCreateInput!, update: ClearTicketUpdateInput!, where: ClearTicketWhereUniqueInput!): ClearTicket!
    upsertVenue(create: ClearVenueCreateInput!, update: ClearVenueUpdateInput!, where: ClearVenueWhereUniqueInput!): ClearVenue!
}

type ClearPayment {
    Ticket(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicket!]!
    _count: ClearPaymentCount
    createdAt: ClearDateTime!
    getMetadata(key: String!): String
    id: String!
    total: Float!
    updatedAt: ClearDateTime!
}

type ClearPaymentAvgAggregate {
    total: Float
}

type ClearPaymentCount {
    Ticket: Int!
}

type ClearPaymentCountAggregate {
    _all: Int!
    createdAt: Int!
    id: Int!
    metadata: Int!
    total: Int!
    updatedAt: Int!
}

type ClearPaymentGroupBy {
    _avg: ClearPaymentAvgAggregate
    _count: ClearPaymentCountAggregate
    _max: ClearPaymentMaxAggregate
    _min: ClearPaymentMinAggregate
    _sum: ClearPaymentSumAggregate
    createdAt: ClearDateTime!
    id: String!
    metadata: ClearJSON
    total: Float!
    updatedAt: ClearDateTime!
}

type ClearPaymentMaxAggregate {
    createdAt: ClearDateTime
    id: String
    total: Float
    updatedAt: ClearDateTime
}

type ClearPaymentMinAggregate {
    createdAt: ClearDateTime
    id: String
    total: Float
    updatedAt: ClearDateTime
}

type ClearPaymentSumAggregate {
    total: Float
}

type ClearPerson {
    Ticket(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicket!]!
    _count: ClearPersonCount
    age: Int
    createdAt: ClearDateTime!
    email: String
    firstName: String!
    getMetadata(key: String!): String
    id: String!
    lastName: String!
    phone: String
    pronouns: String
    updatedAt: ClearDateTime!
    username: String
}

type ClearPersonAvgAggregate {
    age: Float
}

type ClearPersonCount {
    Ticket: Int!
}

type ClearPersonCountAggregate {
    _all: Int!
    age: Int!
    createdAt: Int!
    email: Int!
    firstName: Int!
    id: Int!
    lastName: Int!
    metadata: Int!
    phone: Int!
    pronouns: Int!
    updatedAt: Int!
    username: Int!
}

type ClearPersonGroupBy {
    _avg: ClearPersonAvgAggregate
    _count: ClearPersonCountAggregate
    _max: ClearPersonMaxAggregate
    _min: ClearPersonMinAggregate
    _sum: ClearPersonSumAggregate
    age: Int
    createdAt: ClearDateTime!
    email: String
    firstName: String!
    id: String!
    lastName: String!
    metadata: ClearJSON
    phone: String
    pronouns: String
    updatedAt: ClearDateTime!
    username: String
}

type ClearPersonMaxAggregate {
    age: Int
    createdAt: ClearDateTime
    email: String
    firstName: String
    id: String
    lastName: String
    phone: String
    pronouns: String
    updatedAt: ClearDateTime
    username: String
}

type ClearPersonMinAggregate {
    age: Int
    createdAt: ClearDateTime
    email: String
    firstName: String
    id: String
    lastName: String
    phone: String
    pronouns: String
    updatedAt: ClearDateTime
    username: String
}

type ClearPersonSumAggregate {
    age: Int
}

type ClearQuery {
    aggregateEvent(cursor: ClearEventWhereUniqueInput, orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): ClearAggregateEvent!
    aggregateEventGroup(cursor: ClearEventGroupWhereUniqueInput, orderBy: [ClearEventGroupOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventGroupWhereInput): ClearAggregateEventGroup!
    aggregatePayment(cursor: ClearPaymentWhereUniqueInput, orderBy: [ClearPaymentOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPaymentWhereInput): ClearAggregatePayment!
    aggregatePerson(cursor: ClearPersonWhereUniqueInput, orderBy: [ClearPersonOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPersonWhereInput): ClearAggregatePerson!
    aggregateScheduleItem(cursor: ClearScheduleItemWhereUniqueInput, orderBy: [ClearScheduleItemOrderByWithRelationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): ClearAggregateScheduleItem!
    aggregateSponsor(cursor: ClearSponsorWhereUniqueInput, orderBy: [ClearSponsorOrderByWithRelationInput!], skip: Int, take: Int, where: ClearSponsorWhereInput): ClearAggregateSponsor!
    aggregateTicket(cursor: ClearTicketWhereUniqueInput, orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): ClearAggregateTicket!
    aggregateVenue(cursor: ClearVenueWhereUniqueInput, orderBy: [ClearVenueOrderByWithRelationInput!], skip: Int, take: Int, where: ClearVenueWhereInput): ClearAggregateVenue!
    event(where: ClearEventWhereUniqueInput!): ClearEvent
    eventGroup(where: ClearEventGroupWhereUniqueInput!): ClearEventGroup
    eventGroups(cursor: ClearEventGroupWhereUniqueInput, distinct: [ClearEventGroupScalarFieldEnum!], orderBy: [ClearEventGroupOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventGroupWhereInput): [ClearEventGroup!]!
    events(cursor: ClearEventWhereUniqueInput, distinct: [ClearEventScalarFieldEnum!], orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): [ClearEvent!]!
    findFirstEvent(cursor: ClearEventWhereUniqueInput, distinct: [ClearEventScalarFieldEnum!], orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): ClearEvent
    findFirstEventGroup(cursor: ClearEventGroupWhereUniqueInput, distinct: [ClearEventGroupScalarFieldEnum!], orderBy: [ClearEventGroupOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventGroupWhereInput): ClearEventGroup
    findFirstPayment(cursor: ClearPaymentWhereUniqueInput, distinct: [ClearPaymentScalarFieldEnum!], orderBy: [ClearPaymentOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPaymentWhereInput): ClearPayment
    findFirstPerson(cursor: ClearPersonWhereUniqueInput, distinct: [ClearPersonScalarFieldEnum!], orderBy: [ClearPersonOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPersonWhereInput): ClearPerson
    findFirstScheduleItem(cursor: ClearScheduleItemWhereUniqueInput, distinct: [ClearScheduleItemScalarFieldEnum!], orderBy: [ClearScheduleItemOrderByWithRelationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): ClearScheduleItem
    findFirstSponsor(cursor: ClearSponsorWhereUniqueInput, distinct: [ClearSponsorScalarFieldEnum!], orderBy: [ClearSponsorOrderByWithRelationInput!], skip: Int, take: Int, where: ClearSponsorWhereInput): ClearSponsor
    findFirstTicket(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): ClearTicket
    findFirstVenue(cursor: ClearVenueWhereUniqueInput, distinct: [ClearVenueScalarFieldEnum!], orderBy: [ClearVenueOrderByWithRelationInput!], skip: Int, take: Int, where: ClearVenueWhereInput): ClearVenue
    groupByEvent(by: [ClearEventScalarFieldEnum!]!, having: ClearEventScalarWhereWithAggregatesInput, orderBy: [ClearEventOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearEventWhereInput): [ClearEventGroupBy!]!
    groupByEventGroup(by: [ClearEventGroupScalarFieldEnum!]!, having: ClearEventGroupScalarWhereWithAggregatesInput, orderBy: [ClearEventGroupOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearEventGroupWhereInput): [ClearEventGroupGroupBy!]!
    groupByPayment(by: [ClearPaymentScalarFieldEnum!]!, having: ClearPaymentScalarWhereWithAggregatesInput, orderBy: [ClearPaymentOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearPaymentWhereInput): [ClearPaymentGroupBy!]!
    groupByPerson(by: [ClearPersonScalarFieldEnum!]!, having: ClearPersonScalarWhereWithAggregatesInput, orderBy: [ClearPersonOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearPersonWhereInput): [ClearPersonGroupBy!]!
    groupByScheduleItem(by: [ClearScheduleItemScalarFieldEnum!]!, having: ClearScheduleItemScalarWhereWithAggregatesInput, orderBy: [ClearScheduleItemOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): [ClearScheduleItemGroupBy!]!
    groupBySponsor(by: [ClearSponsorScalarFieldEnum!]!, having: ClearSponsorScalarWhereWithAggregatesInput, orderBy: [ClearSponsorOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearSponsorWhereInput): [ClearSponsorGroupBy!]!
    groupByTicket(by: [ClearTicketScalarFieldEnum!]!, having: ClearTicketScalarWhereWithAggregatesInput, orderBy: [ClearTicketOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicketGroupBy!]!
    groupByVenue(by: [ClearVenueScalarFieldEnum!]!, having: ClearVenueScalarWhereWithAggregatesInput, orderBy: [ClearVenueOrderByWithAggregationInput!], skip: Int, take: Int, where: ClearVenueWhereInput): [ClearVenueGroupBy!]!
    myEvents: [ClearEvent!]!
    payment(where: ClearPaymentWhereUniqueInput!): ClearPayment
    payments(cursor: ClearPaymentWhereUniqueInput, distinct: [ClearPaymentScalarFieldEnum!], orderBy: [ClearPaymentOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPaymentWhereInput): [ClearPayment!]!
    people(cursor: ClearPersonWhereUniqueInput, distinct: [ClearPersonScalarFieldEnum!], orderBy: [ClearPersonOrderByWithRelationInput!], skip: Int, take: Int, where: ClearPersonWhereInput): [ClearPerson!]!
    person(where: ClearPersonWhereUniqueInput!): ClearPerson
    scheduleItem(where: ClearScheduleItemWhereUniqueInput!): ClearScheduleItem
    scheduleItems(cursor: ClearScheduleItemWhereUniqueInput, distinct: [ClearScheduleItemScalarFieldEnum!], orderBy: [ClearScheduleItemOrderByWithRelationInput!], skip: Int, take: Int, where: ClearScheduleItemWhereInput): [ClearScheduleItem!]!
    sponsor(where: ClearSponsorWhereUniqueInput!): ClearSponsor
    sponsors(cursor: ClearSponsorWhereUniqueInput, distinct: [ClearSponsorScalarFieldEnum!], orderBy: [ClearSponsorOrderByWithRelationInput!], skip: Int, take: Int, where: ClearSponsorWhereInput): [ClearSponsor!]!
    ticket(where: ClearTicketWhereUniqueInput!): ClearTicket
    tickets(cursor: ClearTicketWhereUniqueInput, distinct: [ClearTicketScalarFieldEnum!], orderBy: [ClearTicketOrderByWithRelationInput!], skip: Int, take: Int, where: ClearTicketWhereInput): [ClearTicket!]!
    venue(where: ClearVenueWhereUniqueInput!): ClearVenue
    venues(cursor: ClearVenueWhereUniqueInput, distinct: [ClearVenueScalarFieldEnum!], orderBy: [ClearVenueOrderByWithRelationInput!], skip: Int, take: Int, where: ClearVenueWhereInput): [ClearVenue!]!
}

type ClearScheduleItem {
    createdAt: ClearDateTime!
    description: String
    displayTime: String!
    displayTimeWithDate: String!
    end: ClearDateTime
    event: ClearEvent
    eventGroup: ClearEventGroup
    eventGroupId: String
    eventId: String
    finalized: Boolean!
    getMetadata(key: String!): String
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String!
    internal: Boolean!
    link: String
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime!
}

type ClearScheduleItemCountAggregate {
    _all: Int!
    createdAt: Int!
    description: Int!
    end: Int!
    eventGroupId: Int!
    eventId: Int!
    finalized: Int!
    hostEmail: Int!
    hostName: Int!
    hostPronoun: Int!
    id: Int!
    internal: Int!
    link: Int!
    metadata: Int!
    name: Int!
    organizerEmail: Int!
    organizerName: Int!
    organizerPhone: Int!
    start: Int!
    type: Int!
    updatedAt: Int!
}

type ClearScheduleItemGroupBy {
    _count: ClearScheduleItemCountAggregate
    _max: ClearScheduleItemMaxAggregate
    _min: ClearScheduleItemMinAggregate
    createdAt: ClearDateTime!
    description: String
    end: ClearDateTime
    eventGroupId: String
    eventId: String
    finalized: Boolean!
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String!
    internal: Boolean!
    link: String
    metadata: ClearJSON
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime!
}

type ClearScheduleItemMaxAggregate {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventGroupId: String
    eventId: String
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime
}

type ClearScheduleItemMinAggregate {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventGroupId: String
    eventId: String
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime
}

type ClearSponsor {
    amount: Int!
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime!
    description: String
    event: ClearEvent
    eventId: String
    getMetadata(key: String!): String
    id: String!
    logoImageUri: String
    name: String!
    perks: String
    updatedAt: ClearDateTime!
}

type ClearSponsorAvgAggregate {
    amount: Float
}

type ClearSponsorCountAggregate {
    _all: Int!
    amount: Int!
    contactEmail: Int!
    contactName: Int!
    contactPhone: Int!
    createdAt: Int!
    description: Int!
    eventId: Int!
    id: Int!
    logoImageUri: Int!
    metadata: Int!
    name: Int!
    perks: Int!
    updatedAt: Int!
}

type ClearSponsorGroupBy {
    _avg: ClearSponsorAvgAggregate
    _count: ClearSponsorCountAggregate
    _max: ClearSponsorMaxAggregate
    _min: ClearSponsorMinAggregate
    _sum: ClearSponsorSumAggregate
    amount: Int!
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime!
    description: String
    eventId: String
    id: String!
    logoImageUri: String
    metadata: ClearJSON
    name: String!
    perks: String
    updatedAt: ClearDateTime!
}

type ClearSponsorMaxAggregate {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    description: String
    eventId: String
    id: String
    logoImageUri: String
    name: String
    perks: String
    updatedAt: ClearDateTime
}

type ClearSponsorMinAggregate {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    description: String
    eventId: String
    id: String
    logoImageUri: String
    name: String
    perks: String
    updatedAt: ClearDateTime
}

type ClearSponsorSumAggregate {
    amount: Int
}

type ClearTicket {
    age: Int
    couponCode: String
    createdAt: ClearDateTime!
    email: String
    event: ClearEvent!
    eventId: String!
    firstName: String!
    getMetadata(key: String!): String
    guardian: ClearPerson
    id: String!
    lastName: String!
    needsGuardian: Boolean!
    payment: ClearPayment
    paymentId: String
    personId: String
    phone: String
    type: ClearTicketType!
    updatedAt: ClearDateTime!
    waiverSigned: Boolean!
}

type ClearTicketAvgAggregate {
    age: Float
}

type ClearTicketCountAggregate {
    _all: Int!
    age: Int!
    couponCode: Int!
    createdAt: Int!
    email: Int!
    eventId: Int!
    firstName: Int!
    id: Int!
    lastName: Int!
    metadata: Int!
    paymentId: Int!
    personId: Int!
    phone: Int!
    type: Int!
    updatedAt: Int!
    waiverSigned: Int!
}

type ClearTicketGroupBy {
    _avg: ClearTicketAvgAggregate
    _count: ClearTicketCountAggregate
    _max: ClearTicketMaxAggregate
    _min: ClearTicketMinAggregate
    _sum: ClearTicketSumAggregate
    age: Int
    couponCode: String
    createdAt: ClearDateTime!
    email: String
    eventId: String!
    firstName: String!
    id: String!
    lastName: String!
    metadata: ClearJSON
    paymentId: String
    personId: String
    phone: String
    type: ClearTicketType!
    updatedAt: ClearDateTime!
    waiverSigned: Boolean!
}

type ClearTicketMaxAggregate {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    eventId: String
    firstName: String
    id: String
    lastName: String
    paymentId: String
    personId: String
    phone: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

type ClearTicketMinAggregate {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    eventId: String
    firstName: String
    id: String
    lastName: String
    paymentId: String
    personId: String
    phone: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

type ClearTicketSumAggregate {
    age: Int
}

type ClearVenue {
    _count: ClearVenueCount
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime!
    events(cursor: ClearEventWhereUniqueInput, distinct: [ClearEventScalarFieldEnum!], orderBy: [ClearEventOrderByWithRelationInput!], skip: Int, take: Int, where: ClearEventWhereInput): [ClearEvent!]!
    getMetadata(key: String!): String
    id: String!
    mapLink: String
    name: String
    updatedAt: ClearDateTime!
}

type ClearVenueAvgAggregate {
    capacity: Float
}

type ClearVenueCount {
    events: Int!
}

type ClearVenueCountAggregate {
    _all: Int!
    address: Int!
    capacity: Int!
    contactEmail: Int!
    contactName: Int!
    contactPhone: Int!
    createdAt: Int!
    id: Int!
    mapLink: Int!
    metadata: Int!
    name: Int!
    updatedAt: Int!
}

type ClearVenueGroupBy {
    _avg: ClearVenueAvgAggregate
    _count: ClearVenueCountAggregate
    _max: ClearVenueMaxAggregate
    _min: ClearVenueMinAggregate
    _sum: ClearVenueSumAggregate
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime!
    id: String!
    mapLink: String
    metadata: ClearJSON
    name: String
    updatedAt: ClearDateTime!
}

type ClearVenueMaxAggregate {
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    id: String
    mapLink: String
    name: String
    updatedAt: ClearDateTime
}

type ClearVenueMinAggregate {
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    id: String
    mapLink: String
    name: String
    updatedAt: ClearDateTime
}

type ClearVenueSumAggregate {
    capacity: Int
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/announcement)"
type CmsAnnouncement implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    displayAt(locale: String): CmsDateTime
    endAt(locale: String): CmsDateTime
    link(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsAnnouncementLinkingCollections
    oneline(locale: String): String
    programs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAnnouncementProgramCollection
    sys: CmsSys!
    title(locale: String): String
    type(locale: String): String
    visibility(locale: String): String
}

type CmsAnnouncementCollection {
    items: [CmsAnnouncement]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsAnnouncementLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsAnnouncementProgramCollection {
    items: [CmsProgram]!
    limit: Int!
    skip: Int!
    total: Int!
}

"Represents a binary file in a space. An asset can be any file type."
type CmsAsset {
    contentType: String
    contentfulBaseUrl(transform: CmsImageTransformOptions): String
    contentfulMetadata: CmsContentfulMetadata!
    description: String
    fileName: String
    height: Int
    linkedFrom(allowedLocales: [String]): CmsAssetLinkingCollections
    size: Int
    sys: CmsSys!
    title: String
    url(transform: CmsImageTransformOptions): String
    width: Int
}

type CmsAssetCollection {
    items: [CmsAsset]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsAssetLinkingCollections {
    awards(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAwardCollection
    badges(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsBadgeCollection
    communityPartners(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsCommunityPartnerCollection
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    events(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEventCollection
    forms(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsFormCollection
    globalSponsors(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsGlobalSponsorCollection
    hiringCompanies(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsHiringCompanyCollection
    legalDocuments(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsLegalDocumentCollection
    newsCoverages(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsNewsCoverageCollection
    pressPhotos(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsPressPhotoCollection
    programs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsProgramCollection
    regions(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsRegionCollection
    stockMusics(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsStockMusicCollection
    testimonials(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsTestimonialCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/award)"
type CmsAward implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): String
    icon(locale: String, preview: Boolean): CmsAsset
    id(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsAwardLinkingCollections
    name(locale: String): String
    programs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAwardProgramsCollection
    ranking(locale: String): Int
    sys: CmsSys!
}

type CmsAwardCollection {
    items: [CmsAward]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsAwardLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsAwardProgramsCollection {
    items: [CmsProgram]!
    limit: Int!
    skip: Int!
    total: Int!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/badge)"
type CmsBadge implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): String
    earnCriteria(locale: String): String
    earnMessage(locale: String): String
    emoji(locale: String): String
    grantPermissionOverrideIDs(locale: String): CmsJSON
    id(locale: String): String
    image(locale: String, preview: Boolean): CmsAsset
    linkedFrom(allowedLocales: [String]): CmsBadgeLinkingCollections
    name(locale: String): String
    sys: CmsSys!
}

type CmsBadgeCollection {
    items: [CmsBadge]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsBadgeLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/bumper)"
type CmsBumper implements CmsEntry {
    ambient(locale: String): Boolean
    contentfulMetadata: CmsContentfulMetadata!
    linkedFrom(allowedLocales: [String]): CmsBumperLinkingCollections
    purpose(locale: String): [String]
    sys: CmsSys!
    title(locale: String): String
    video(locale: String): CmsJSON
}

type CmsBumperCollection {
    items: [CmsBumper]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsBumperLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/communityPartner)"
type CmsCommunityPartner implements CmsEntry {
    audience(locale: String): [String]
    blurb(locale: String): String
    contentfulMetadata: CmsContentfulMetadata!
    cost(locale: String): Int
    details(locale: String): String
    displayUrl(locale: String): String
    eligibility(locale: String): String
    expires(locale: String): CmsDateTime
    linkedFrom(allowedLocales: [String]): CmsCommunityPartnerLinkingCollections
    logo(locale: String, preview: Boolean): CmsAsset
    name(locale: String): String
    regions(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsCommunityPartnerRegionCollection
    sys: CmsSys!
    url(locale: String): String
}

type CmsCommunityPartnerCollection {
    items: [CmsCommunityPartner]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsCommunityPartnerLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsCommunityPartnerRegionCollection {
    items: [CmsRegion]!
    limit: Int!
    skip: Int!
    total: Int!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/string)"
type CmsContentTypeString implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    json(locale: String): CmsJSON
    key(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsContentTypeStringLinkingCollections
    richValue(locale: String): CmsContentTypeStringRichValue
    subvalues(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsContentTypeStringSubvalueCollection
    sys: CmsSys!
    value(locale: String): String
}

type CmsContentTypeStringCollection {
    items: [CmsContentTypeString]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsContentTypeStringLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    strings(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsContentTypeStringCollection
}

type CmsContentTypeStringRichValue {
    json: CmsJSON!
    links: CmsContentTypeStringRichValueLinks!
}

type CmsContentTypeStringRichValueAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsContentTypeStringRichValueEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsContentTypeStringRichValueLinks {
    assets: CmsContentTypeStringRichValueAssets!
    entries: CmsContentTypeStringRichValueEntries!
}

type CmsContentTypeStringSubvalueCollection {
    items: [CmsContentTypeString]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsContentfulMetadata {
    tags: [CmsContentfulTag]!
}

"""

Represents a tag entity for finding and organizing content easily.
Find out more here: https://www.contentful.com/developers/docs/references/content-delivery-api/#/reference/content-tags
"""
type CmsContentfulTag {
    id: String
    name: String
}

type CmsEntryCollection {
    items: [CmsEntry]!
    limit: Int!
    skip: Int!
    total: Int!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/event)"
type CmsEvent implements CmsEntry {
    awardsAt(locale: String): CmsDateTime
    calendarReleaseDate(locale: String): CmsDateTime
    contentfulMetadata: CmsContentfulMetadata!
    endsAt(locale: String): CmsDateTime
    id(locale: String): String
    kickoffVideo(locale: String, preview: Boolean): CmsAsset
    kickoffVideoCaptions(locale: String, preview: Boolean): CmsAsset
    linkedFrom(allowedLocales: [String]): CmsEventLinkingCollections
    notice(locale: String): CmsEventNotice
    participantRoleId(locale: String): String
    posters(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    program(locale: String, preview: Boolean): CmsProgram
    registrationsCloseAt(locale: String): CmsDateTime
    registrationsOpenAt(locale: String): CmsDateTime
    startsAt(locale: String): CmsDateTime
    statEventCount(locale: String): Int
    statLowInterestContinuedCount(locale: String): Int
    statLowInterestCount(locale: String): Int
    statStudentCount(locale: String): Int
    subEventIds(locale: String): CmsJSON
    sys: CmsSys!
    theme(locale: String): String
    themeBackgrounds(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    themeLogoBackgrounds(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    title(locale: String): String
}

type CmsEventCollection {
    items: [CmsEvent]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsEventLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    pressPhotos(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsPressPhotoCollection
}

type CmsEventNotice {
    json: CmsJSON!
    links: CmsEventNoticeLinks!
}

type CmsEventNoticeAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsEventNoticeEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsEventNoticeLinks {
    assets: CmsEventNoticeAssets!
    entries: CmsEventNoticeEntries!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/faq)"
type CmsFaq implements CmsEntry {
    answer(locale: String): CmsFaqAnswer
    audience(locale: String): [String]
    contentfulMetadata: CmsContentfulMetadata!
    featured(locale: String): Boolean
    linkedFrom(allowedLocales: [String]): CmsFaqLinkingCollections
    program(locale: String, preview: Boolean): CmsProgram
    relatedAnswers(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsFaqRelatedAnswersCollection
    sys: CmsSys!
    tags(locale: String): [String]
    title(locale: String): String
}

type CmsFaqAnswer {
    json: CmsJSON!
    links: CmsFaqAnswerLinks!
}

type CmsFaqAnswerAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsFaqAnswerEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsFaqAnswerLinks {
    assets: CmsFaqAnswerAssets!
    entries: CmsFaqAnswerEntries!
}

type CmsFaqCollection {
    items: [CmsFaq]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsFaqLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    faqs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsFaqCollection
}

type CmsFaqRelatedAnswersCollection {
    items: [CmsFaq]!
    limit: Int!
    skip: Int!
    total: Int!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/form)"
type CmsForm implements CmsEntry {
    cognitoForm(locale: String): Int
    contentfulMetadata: CmsContentfulMetadata!
    details(locale: String): CmsFormDetails
    image(locale: String, preview: Boolean): CmsAsset
    linkedFrom(allowedLocales: [String]): CmsFormLinkingCollections
    prefill(locale: String): CmsJSON
    sidebar(locale: String): CmsFormSidebar
    slug(locale: String): String
    sys: CmsSys!
    title(locale: String): String
}

type CmsFormCollection {
    items: [CmsForm]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsFormDetails {
    json: CmsJSON!
    links: CmsFormDetailsLinks!
}

type CmsFormDetailsAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsFormDetailsEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsFormDetailsLinks {
    assets: CmsFormDetailsAssets!
    entries: CmsFormDetailsEntries!
}

type CmsFormLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsFormSidebar {
    json: CmsJSON!
    links: CmsFormSidebarLinks!
}

type CmsFormSidebarAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsFormSidebarEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsFormSidebarLinks {
    assets: CmsFormSidebarAssets!
    entries: CmsFormSidebarEntries!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/globalSponsor)"
type CmsGlobalSponsor implements CmsEntry {
    audio(locale: String, preview: Boolean): CmsAsset
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): String
    instagramUsername(locale: String): String
    link(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsGlobalSponsorLinkingCollections
    logo(locale: String, preview: Boolean): CmsAsset
    name(locale: String): String
    perks(locale: String): String
    shortDescription(locale: String): String
    sys: CmsSys!
    twitterUsername(locale: String): String
    type(locale: String): String
}

type CmsGlobalSponsorCollection {
    items: [CmsGlobalSponsor]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsGlobalSponsorLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    hiringCompanies(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsHiringCompanyCollection
    programs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsProgramCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/hiringCompany)"
type CmsHiringCompany implements CmsEntry {
    alumniReferralAccounts: [AccountUser]
    alumniReferrals(locale: String): [String]
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): CmsHiringCompanyDescription
    featured(locale: String): Boolean
    linkedFrom(allowedLocales: [String]): CmsHiringCompanyLinkingCollections
    logo(locale: String, preview: Boolean): CmsAsset
    name(locale: String): String
    relatedSponsor(locale: String, preview: Boolean): CmsGlobalSponsor
    sys: CmsSys!
    url(locale: String): String
}

type CmsHiringCompanyCollection {
    items: [CmsHiringCompany]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsHiringCompanyDescription {
    json: CmsJSON!
    links: CmsHiringCompanyDescriptionLinks!
}

type CmsHiringCompanyDescriptionAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsHiringCompanyDescriptionEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsHiringCompanyDescriptionLinks {
    assets: CmsHiringCompanyDescriptionAssets!
    entries: CmsHiringCompanyDescriptionEntries!
}

type CmsHiringCompanyLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    hiringPosts(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsHiringPostCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/hiringPost)"
type CmsHiringPost implements CmsEntry {
    company(locale: String, preview: Boolean): CmsHiringCompany
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): CmsHiringPostDescription
    linkedFrom(allowedLocales: [String]): CmsHiringPostLinkingCollections
    paid(locale: String): Boolean
    regions(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsHiringPostRegionsCollection
    sys: CmsSys!
    title(locale: String): String
    type(locale: String): String
    url(locale: String): String
}

type CmsHiringPostCollection {
    items: [CmsHiringPost]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsHiringPostDescription {
    json: CmsJSON!
    links: CmsHiringPostDescriptionLinks!
}

type CmsHiringPostDescriptionAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsHiringPostDescriptionEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsHiringPostDescriptionLinks {
    assets: CmsHiringPostDescriptionAssets!
    entries: CmsHiringPostDescriptionEntries!
}

type CmsHiringPostLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsHiringPostRegionsCollection {
    items: [CmsRegion]!
    limit: Int!
    skip: Int!
    total: Int!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/legalDocument)"
type CmsLegalDocument implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    date(locale: String): CmsDateTime
    file(locale: String, preview: Boolean): CmsAsset
    id(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsLegalDocumentLinkingCollections
    sys: CmsSys!
    title(locale: String): String
    type(locale: String): String
}

type CmsLegalDocumentCollection {
    items: [CmsLegalDocument]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsLegalDocumentLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsLocation {
    lat: Float
    lon: Float
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/newsCoverage)"
type CmsNewsCoverage implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    date(locale: String): CmsDateTime
    featured(locale: String): Boolean
    linkedFrom(allowedLocales: [String]): CmsNewsCoverageLinkingCollections
    publicationLogo(locale: String, preview: Boolean): CmsAsset
    publicationName(locale: String): String
    sys: CmsSys!
    title(locale: String): String
    url(locale: String): String
}

type CmsNewsCoverageCollection {
    items: [CmsNewsCoverage]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsNewsCoverageLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/pressPhoto)"
type CmsPressPhoto implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    event(locale: String, preview: Boolean): CmsEvent
    linkedFrom(allowedLocales: [String]): CmsPressPhotoLinkingCollections
    photo(locale: String, preview: Boolean): CmsAsset
    region(locale: String, preview: Boolean): CmsRegion
    subProgram(locale: String, preview: Boolean): CmsProgram
    sys: CmsSys!
    tags(locale: String): [String]
}

type CmsPressPhotoCollection {
    items: [CmsPressPhoto]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsPressPhotoLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/program)"
type CmsProgram implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    description(locale: String): String
    educationDetails(locale: String): CmsProgramEducationDetails
    eligibility(locale: String): CmsProgramEligibility
    linkedFrom(allowedLocales: [String]): CmsProgramLinkingCollections
    logo(locale: String, preview: Boolean): CmsAsset
    logoWhite(locale: String, preview: Boolean): CmsAsset
    name(locale: String): String
    posters(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    presentingSponsors(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsProgramPresentingSponsorsCollection
    shortDescription(locale: String): String
    sponsorPerks(locale: String): CmsJSON
    sys: CmsSys!
    type(locale: String): String
    url(locale: String): String
    virtual(locale: String): Boolean
    volunteerBlurb(locale: String): CmsProgramVolunteerBlurb
    volunteerDetails(locale: String): CmsProgramVolunteerDetails
    volunteerPositions(locale: String): [String]
    volunteerRecruitingResources(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    volunteerUrl(locale: String): String
    webname(locale: String): String
}

type CmsProgramCollection {
    items: [CmsProgram]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsProgramEducationDetails {
    json: CmsJSON!
    links: CmsProgramEducationDetailsLinks!
}

type CmsProgramEducationDetailsAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsProgramEducationDetailsEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsProgramEducationDetailsLinks {
    assets: CmsProgramEducationDetailsAssets!
    entries: CmsProgramEducationDetailsEntries!
}

type CmsProgramEligibility {
    json: CmsJSON!
    links: CmsProgramEligibilityLinks!
}

type CmsProgramEligibilityAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsProgramEligibilityEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsProgramEligibilityLinks {
    assets: CmsProgramEligibilityAssets!
    entries: CmsProgramEligibilityEntries!
}

type CmsProgramLinkingCollections {
    announcements(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAnnouncementCollection
    awards(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAwardCollection
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    events(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEventCollection
    faqs(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsFaqCollection
    pressPhotos(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsPressPhotoCollection
    testimonials(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsTestimonialCollection
}

type CmsProgramPresentingSponsorsCollection {
    items: [CmsGlobalSponsor]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsProgramVolunteerBlurb {
    json: CmsJSON!
    links: CmsProgramVolunteerBlurbLinks!
}

type CmsProgramVolunteerBlurbAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsProgramVolunteerBlurbEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsProgramVolunteerBlurbLinks {
    assets: CmsProgramVolunteerBlurbAssets!
    entries: CmsProgramVolunteerBlurbEntries!
}

type CmsProgramVolunteerDetails {
    json: CmsJSON!
    links: CmsProgramVolunteerDetailsLinks!
}

type CmsProgramVolunteerDetailsAssets {
    block: [CmsAsset]!
    hyperlink: [CmsAsset]!
}

type CmsProgramVolunteerDetailsEntries {
    block: [CmsEntry]!
    hyperlink: [CmsEntry]!
    inline: [CmsEntry]!
}

type CmsProgramVolunteerDetailsLinks {
    assets: CmsProgramVolunteerDetailsAssets!
    entries: CmsProgramVolunteerDetailsEntries!
}

type CmsQuery {
    announcement(id: String!, locale: String, preview: Boolean): CmsAnnouncement
    announcements(limit: Int = 100, locale: String, order: [CmsAnnouncementOrder], preview: Boolean, skip: Int = 0, where: CmsAnnouncementFilter): CmsAnnouncementCollection
    asset(id: String!, locale: String, preview: Boolean): CmsAsset
    assets(limit: Int = 100, locale: String, order: [CmsAssetOrder], preview: Boolean, skip: Int = 0, where: CmsAssetFilter): CmsAssetCollection
    award(id: String!, locale: String, preview: Boolean): CmsAward
    awards(limit: Int = 100, locale: String, order: [CmsAwardOrder], preview: Boolean, skip: Int = 0, where: CmsAwardFilter): CmsAwardCollection
    badge(id: String!, locale: String, preview: Boolean): CmsBadge
    badges(limit: Int = 100, locale: String, order: [CmsBadgeOrder], preview: Boolean, skip: Int = 0, where: CmsBadgeFilter): CmsBadgeCollection
    bumper(id: String!, locale: String, preview: Boolean): CmsBumper
    bumpers(limit: Int = 100, locale: String, order: [CmsBumperOrder], preview: Boolean, skip: Int = 0, where: CmsBumperFilter): CmsBumperCollection
    communityPartner(id: String!, locale: String, preview: Boolean): CmsCommunityPartner
    communityPartners(limit: Int = 100, locale: String, order: [CmsCommunityPartnerOrder], preview: Boolean, skip: Int = 0, where: CmsCommunityPartnerFilter): CmsCommunityPartnerCollection
    entries(limit: Int = 100, locale: String, order: [CmsEntryOrder], preview: Boolean, skip: Int = 0, where: CmsEntryFilter): CmsEntryCollection
    event(id: String!, locale: String, preview: Boolean): CmsEvent
    events(limit: Int = 100, locale: String, order: [CmsEventOrder], preview: Boolean, skip: Int = 0, where: CmsEventFilter): CmsEventCollection
    faq(id: String!, locale: String, preview: Boolean): CmsFaq
    faqs(limit: Int = 100, locale: String, order: [CmsFaqOrder], preview: Boolean, skip: Int = 0, where: CmsFaqFilter): CmsFaqCollection
    form(id: String!, locale: String, preview: Boolean): CmsForm
    forms(limit: Int = 100, locale: String, order: [CmsFormOrder], preview: Boolean, skip: Int = 0, where: CmsFormFilter): CmsFormCollection
    globalSponsor(id: String!, locale: String, preview: Boolean): CmsGlobalSponsor
    globalSponsors(limit: Int = 100, locale: String, order: [CmsGlobalSponsorOrder], preview: Boolean, skip: Int = 0, where: CmsGlobalSponsorFilter): CmsGlobalSponsorCollection
    hiringCompanies(limit: Int = 100, locale: String, order: [CmsHiringCompanyOrder], preview: Boolean, skip: Int = 0, where: CmsHiringCompanyFilter): CmsHiringCompanyCollection
    hiringCompany(id: String!, locale: String, preview: Boolean): CmsHiringCompany
    hiringPost(id: String!, locale: String, preview: Boolean): CmsHiringPost
    hiringPosts(limit: Int = 100, locale: String, order: [CmsHiringPostOrder], preview: Boolean, skip: Int = 0, where: CmsHiringPostFilter): CmsHiringPostCollection
    legalDocument(id: String!, locale: String, preview: Boolean): CmsLegalDocument
    legalDocuments(limit: Int = 100, locale: String, order: [CmsLegalDocumentOrder], preview: Boolean, skip: Int = 0, where: CmsLegalDocumentFilter): CmsLegalDocumentCollection
    newsCoverage(id: String!, locale: String, preview: Boolean): CmsNewsCoverage
    newsCoverages(limit: Int = 100, locale: String, order: [CmsNewsCoverageOrder], preview: Boolean, skip: Int = 0, where: CmsNewsCoverageFilter): CmsNewsCoverageCollection
    pressPhoto(id: String!, locale: String, preview: Boolean): CmsPressPhoto
    pressPhotos(limit: Int = 100, locale: String, order: [CmsPressPhotoOrder], preview: Boolean, skip: Int = 0, where: CmsPressPhotoFilter): CmsPressPhotoCollection
    program(id: String!, locale: String, preview: Boolean): CmsProgram
    programs(limit: Int = 100, locale: String, order: [CmsProgramOrder], preview: Boolean, skip: Int = 0, where: CmsProgramFilter): CmsProgramCollection
    region(id: String!, locale: String, preview: Boolean): CmsRegion
    regions(limit: Int = 100, locale: String, order: [CmsRegionOrder], preview: Boolean, skip: Int = 0, where: CmsRegionFilter): CmsRegionCollection
    site(id: String!, locale: String, preview: Boolean): CmsSite
    sites(limit: Int = 100, locale: String, order: [CmsSiteOrder], preview: Boolean, skip: Int = 0, where: CmsSiteFilter): CmsSiteCollection
    stockMusic(id: String!, locale: String, preview: Boolean): CmsStockMusic
    stockMusics(limit: Int = 100, locale: String, order: [CmsStockMusicOrder], preview: Boolean, skip: Int = 0, where: CmsStockMusicFilter): CmsStockMusicCollection
    string(id: String!, locale: String, preview: Boolean): CmsContentTypeString
    strings(limit: Int = 100, locale: String, order: [CmsContentTypeStringOrder], preview: Boolean, skip: Int = 0, where: CmsContentTypeStringFilter): CmsContentTypeStringCollection
    testimonial(id: String!, locale: String, preview: Boolean): CmsTestimonial
    testimonials(limit: Int = 100, locale: String, order: [CmsTestimonialOrder], preview: Boolean, skip: Int = 0, where: CmsTestimonialFilter): CmsTestimonialCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/region)"
type CmsRegion implements CmsEntry {
    abbr(locale: String): String
    accountingName(locale: String): String
    aliases(locale: String): [String]
    complication(locale: String, preview: Boolean): CmsAsset
    contentfulMetadata: CmsContentfulMetadata!
    linkedFrom(allowedLocales: [String]): CmsRegionLinkingCollections
    location(locale: String): CmsLocation
    motto(locale: String): String
    name(locale: String): String
    primaryColor(locale: String): String
    regionPhotos(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsAssetCollection
    skylinePhoto(locale: String, preview: Boolean): CmsAsset
    stickerLarge(locale: String, preview: Boolean): CmsAsset
    stickerSmall(locale: String, preview: Boolean): CmsAsset
    sys: CmsSys!
    timezone(locale: String): String
    webname(locale: String): String
}

type CmsRegionCollection {
    items: [CmsRegion]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsRegionLinkingCollections {
    communityPartners(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsCommunityPartnerCollection
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
    hiringPosts(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsHiringPostCollection
    pressPhotos(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsPressPhotoCollection
    testimonials(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsTestimonialCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/site)"
type CmsSite implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    display(locale: String): [String]
    link(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsSiteLinkingCollections
    sys: CmsSys!
    title(locale: String): String
    type(locale: String): String
}

type CmsSiteCollection {
    items: [CmsSite]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsSiteLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/stockMusic)"
type CmsStockMusic implements CmsEntry {
    contentfulMetadata: CmsContentfulMetadata!
    linkedFrom(allowedLocales: [String]): CmsStockMusicLinkingCollections
    music(locale: String, preview: Boolean): CmsAsset
    sys: CmsSys!
    title(locale: String): String
}

type CmsStockMusicCollection {
    items: [CmsStockMusic]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsStockMusicLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type CmsSys {
    environmentId: String!
    firstPublishedAt: CmsDateTime
    id: String!
    publishedAt: CmsDateTime
    publishedVersion: Int
    spaceId: String!
}

"[See type definition](https://app.contentful.com/spaces/d5pti1xheuyu/content_types/testimonial)"
type CmsTestimonial implements CmsEntry {
    company(locale: String): String
    contentfulMetadata: CmsContentfulMetadata!
    experience(locale: String): String
    featured(locale: String): Boolean
    firstName(locale: String): String
    groupName(locale: String): String
    image(locale: String, preview: Boolean): CmsAsset
    lastName(locale: String): String
    linkedFrom(allowedLocales: [String]): CmsTestimonialLinkingCollections
    program(locale: String, preview: Boolean): CmsProgram
    quote(locale: String): String
    region(locale: String, preview: Boolean): CmsRegion
    sys: CmsSys!
    title(locale: String): String
    type(locale: String): String
    video(locale: String, preview: Boolean): CmsAsset
}

type CmsTestimonialCollection {
    items: [CmsTestimonial]!
    limit: Int!
    skip: Int!
    total: Int!
}

type CmsTestimonialLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): CmsEntryCollection
}

type LabsMatch {
    project: LabsProject!
    score: Float!
}

type LabsMentor {
    account: AccountUser
    createdAt: LabsDateTime!
    email: String!
    givenName: String!
    id: String!
    manager: AccountUser
    managerUsername: String
    maxWeeks: Int!
    name: String!
    profile: LabsJSON!
    profileField(key: String!): LabsJSON
    projects: [LabsProject!]!
    status: LabsMentorStatus!
    surname: String!
    updatedAt: LabsDateTime!
    username: String
}

type LabsMutation {
    acceptStudentOffer: LabsStudent!
    addProjectMentor(mentor: LabsIdOrUsernameInput!, project: String!): LabsProject!
    addProjectStudent(project: String!, student: LabsIdOrUsernameInput!): LabsProject!
    applyMentor(data: LabsMentorApplyInput!): LabsMentor!
    applyStudent(data: LabsStudentApplyInput!): LabsStudent!
    cancelStudentApplication: LabsStudent!
    createMentor(data: LabsMentorCreateInput!): LabsMentor!
    createProject(data: LabsProjectCreateInput!, mentor: LabsIdOrUsernameInput): LabsProject!
    createStudent(data: LabsStudentCreateInput!): LabsStudent!
    createTag(data: LabsTagCreateInput!): LabsTag!
    deleteMentor(where: LabsIdOrUsernameInput!): Boolean!
    deleteProject(project: String!): Boolean!
    deleteStudent(where: LabsIdOrUsernameInput!): Boolean!
    deleteTag(tag: String!): Boolean!
    editMentor(data: LabsMentorEditInput!, where: LabsIdOrUsernameInput): LabsMentor!
    editProject(data: LabsProjectEditInput!, project: String!): LabsProject!
    editStudent(data: LabsStudentEditInput!, where: LabsIdOrUsernameInput): LabsStudent!
    editTag(data: LabsTagEditInput!, tag: String!): LabsTag!
    expressProjectPreferences(projects: [String!]!): [LabsPreference!]
    offerStudentAdmission(where: LabsIdOrUsernameInput!): LabsStudent!
    rejectStudent(reason: LabsRejectionReason, where: LabsIdOrUsernameInput!): LabsStudent!
    removeProjectMentor(mentor: LabsIdOrUsernameInput!, project: String!): LabsProject!
    removeProjectStudent(project: String!, student: LabsIdOrUsernameInput!): LabsProject!
    resetStudentAdmissionOffer(where: LabsIdOrUsernameInput!): LabsStudent!
    sendMentorEmail(body: String!, dryRun: Boolean = false, subject: String!, where: LabsMentorFilterInput): Float!
    sendStudentEmail(body: String!, dryRun: Boolean = false, subject: String!, where: LabsStudentFilterInput): Float!
    submitStudentRating(rating: Int!, track: LabsTrack!, where: LabsIdOrUsernameInput!): Boolean!
    submitTraining(tag: String!, url: String!): Boolean!
}

type LabsPreference {
    project: LabsProject!
    ranking: Float!
}

type LabsProject {
    createdAt: LabsDateTime!
    deliverables: String
    description: String
    id: String!
    maxStudents: Int!
    mentors: [LabsMentor!]!
    status: LabsProjectStatus!
    studentCount: Float!
    students: [LabsStudent!]!
    tags: [LabsTag!]!
    track: LabsTrack!
    updatedAt: LabsDateTime!
}

type LabsQuery {
    mentor(where: LabsIdOrUsernameInput): LabsMentor
    mentors(skip: Float, take: Float, where: LabsMentorFilterInput): [LabsMentor!]!
    nextStudentNeedingRating(track: LabsTrack): LabsStudent
    projectMatches(tags: [String!]!): [LabsMatch!]
    projectPreferences: [LabsPreference!]
    statAdmissionsStatus(track: LabsTrack): [LabsStat!]!
    student(where: LabsIdOrUsernameInput): LabsStudent
    students(skip: Float, take: Float, where: LabsStudentFilterInput): [LabsStudent!]!
    studentsTopRated(includeRejected: Boolean, skip: Float, take: Float, track: LabsTrack): [LabsStudent!]!
    tags(type: LabsTagType): [LabsTag!]!
}

type LabsStat {
    key: String!
    value: Float!
}

type LabsStudent {
    account: AccountUser
    admissionRatingAverage: Float
    admissionRatingCount: Float
    createdAt: LabsDateTime!
    email: String!
    givenName: String!
    hasValidAdmissionOffer: Boolean!
    id: String!
    minHours: Int!
    name: String!
    offerDate: LabsDateTime
    partnerCode: String
    profile: LabsJSON!
    projectCount: Float!
    projectPreferences: [LabsPreference!]!
    projects: [LabsProject!]!
    rejectionReason: LabsRejectionReason
    requiredTagTraining: [LabsTag!]!
    status: LabsStudentStatus!
    surname: String!
    tagTrainingSubmissions: [LabsTagTrainingSubmission!]!
    tags: [LabsTag!]!
    track: LabsTrack!
    trackRecommendation: [LabsTrackRecommendation!]
    updatedAt: LabsDateTime!
    username: String!
    weeks: Int!
}

type LabsTag {
    createdAt: LabsDateTime!
    id: String!
    mentorDisplayName: String!
    studentDisplayName: String!
    trainingLink: String
    type: LabsTagType!
    updatedAt: LabsDateTime!
}

type LabsTagTrainingSubmission {
    createdAt: LabsDateTime!
    id: String!
    student: LabsStudent!
    tag: LabsTag!
    updatedAt: LabsDateTime!
    url: String!
}

type LabsTrackRecommendation {
    track: LabsTrack!
    weight: Float!
}

"Represents a binary file in a space. An asset can be any file type."
type LearnAsset {
    contentType: String
    contentfulBaseUrl(transform: LearnImageTransformOptions): String
    contentfulMetadata: LearnContentfulMetadata!
    description: String
    fileName: String
    height: Int
    linkedFrom(allowedLocales: [String]): LearnAssetLinkingCollections
    size: Int
    sys: LearnSys!
    title: String
    url(transform: LearnImageTransformOptions): String
    width: Int
}

type LearnAssetCollection {
    items: [LearnAsset]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnAssetLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
    technologies(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTechnologyCollection
}

"Display an inline code block inside of rich content for lessons. [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/codeBlock)"
type LearnCodeBlock implements LearnEntry {
    code(locale: String): String
    contentfulMetadata: LearnContentfulMetadata!
    language(locale: String): String
    linkedFrom(allowedLocales: [String]): LearnCodeBlockLinkingCollections
    sys: LearnSys!
}

type LearnCodeBlockCollection {
    items: [LearnCodeBlock]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnCodeBlockLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
}

type LearnContentfulMetadata {
    tags: [LearnContentfulTag]!
}

"""

Represents a tag entity for finding and organizing content easily.
Find out more here: https://www.contentful.com/developers/docs/references/content-delivery-api/#/reference/content-tags
"""
type LearnContentfulTag {
    id: String
    name: String
}

"Determines the hardness of a particular lesson. [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/difficulty)"
type LearnDifficulty implements LearnEntry {
    contentfulMetadata: LearnContentfulMetadata!
    hexCodeColor(locale: String): String
    linkedFrom(allowedLocales: [String]): LearnDifficultyLinkingCollections
    name(locale: String): String
    shortDescription(locale: String): String
    sys: LearnSys!
}

type LearnDifficultyCollection {
    items: [LearnDifficulty]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnDifficultyLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
    tracks(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTrackCollection
}

type LearnEntryCollection {
    items: [LearnEntry]!
    limit: Int!
    skip: Int!
    total: Int!
}

"A specific topic within a track, a lesson can also be thought of as a page [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/lesson)"
type LearnLesson implements LearnEntry {
    content(locale: String): LearnLessonContent
    contentfulMetadata: LearnContentfulMetadata!
    hasNextPage(locale: String): Boolean
    id(locale: String): String
    linkedFrom(allowedLocales: [String]): LearnLessonLinkingCollections
    nameHeader(locale: String): String
    pageNumber(locale: String): Int
    points(locale: String): Int
    sys: LearnSys!
    tags(locale: String): [String]
    track(locale: String, preview: Boolean): LearnTrack
}

type LearnLessonCollection {
    items: [LearnLesson]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnLessonContent {
    json: LearnJSON!
    links: LearnLessonContentLinks!
}

type LearnLessonContentAssets {
    block: [LearnAsset]!
    hyperlink: [LearnAsset]!
}

type LearnLessonContentEntries {
    block: [LearnEntry]!
    hyperlink: [LearnEntry]!
    inline: [LearnEntry]!
}

type LearnLessonContentLinks {
    assets: LearnLessonContentAssets!
    entries: LearnLessonContentEntries!
}

type LearnLessonLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
    tracks(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTrackCollection
}

type LearnQuery {
    asset(id: String!, locale: String, preview: Boolean): LearnAsset
    assets(limit: Int = 100, locale: String, order: [LearnAssetOrder], preview: Boolean, skip: Int = 0, where: LearnAssetFilter): LearnAssetCollection
    codeBlock(id: String!, locale: String, preview: Boolean): LearnCodeBlock
    codeBlocks(limit: Int = 100, locale: String, order: [LearnCodeBlockOrder], preview: Boolean, skip: Int = 0, where: LearnCodeBlockFilter): LearnCodeBlockCollection
    difficulties(limit: Int = 100, locale: String, order: [LearnDifficultyOrder], preview: Boolean, skip: Int = 0, where: LearnDifficultyFilter): LearnDifficultyCollection
    difficulty(id: String!, locale: String, preview: Boolean): LearnDifficulty
    entries(limit: Int = 100, locale: String, order: [LearnEntryOrder], preview: Boolean, skip: Int = 0, where: LearnEntryFilter): LearnEntryCollection
    lesson(id: String!, locale: String, preview: Boolean): LearnLesson
    lessons(limit: Int = 100, locale: String, order: [LearnLessonOrder], preview: Boolean, skip: Int = 0, where: LearnLessonFilter): LearnLessonCollection
    reward(id: String!, locale: String, preview: Boolean): LearnReward
    rewards(limit: Int = 100, locale: String, order: [LearnRewardOrder], preview: Boolean, skip: Int = 0, where: LearnRewardFilter): LearnRewardCollection
    technologies(limit: Int = 100, locale: String, order: [LearnTechnologyOrder], preview: Boolean, skip: Int = 0, where: LearnTechnologyFilter): LearnTechnologyCollection
    technology(id: String!, locale: String, preview: Boolean): LearnTechnology
    track(id: String!, locale: String, preview: Boolean): LearnTrack
    tracks(limit: Int = 100, locale: String, order: [LearnTrackOrder], preview: Boolean, skip: Int = 0, where: LearnTrackFilter): LearnTrackCollection
}

"A toast which gives out rewards based on how well a user is doing. [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/reward)"
type LearnReward implements LearnEntry {
    contentfulMetadata: LearnContentfulMetadata!
    linkedFrom(allowedLocales: [String]): LearnRewardLinkingCollections
    name(locale: String): String
    shortDescription(locale: String): String
    sys: LearnSys!
}

type LearnRewardCollection {
    items: [LearnReward]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnRewardLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
}

type LearnSys {
    environmentId: String!
    firstPublishedAt: LearnDateTime
    id: String!
    publishedAt: LearnDateTime
    publishedVersion: Int
    spaceId: String!
}

"Describes a specific type of technology such as a programming language, framework, libraries, etc... [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/technology)"
type LearnTechnology implements LearnEntry {
    contentfulMetadata: LearnContentfulMetadata!
    description(locale: String): String
    image(locale: String, preview: Boolean): LearnAsset
    linkedFrom(allowedLocales: [String]): LearnTechnologyLinkingCollections
    name(locale: String): String
    sys: LearnSys!
}

type LearnTechnologyCollection {
    items: [LearnTechnology]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnTechnologyLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
    tracks(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTrackCollection
}

"A path that a user can take to start learning a particular topic [See type definition](https://app.contentful.com/spaces/muw2pziidpat/content_types/track)"
type LearnTrack implements LearnEntry {
    contentfulMetadata: LearnContentfulMetadata!
    description(locale: String): String
    difficulty(locale: String, preview: Boolean): LearnDifficulty
    id(locale: String): String
    lessons(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTrackLessonsCollection
    linkedFrom(allowedLocales: [String]): LearnTrackLinkingCollections
    name(locale: String): String
    previewProjectIds(locale: String): [String]
    previewProjects: [ShowcaseProject!]!
    spotlighted(locale: String): Boolean
    sys: LearnSys!
    technologies(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnTrackTechnologiesCollection
}

type LearnTrackCollection {
    items: [LearnTrack]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnTrackLessonsCollection {
    items: [LearnLesson]!
    limit: Int!
    skip: Int!
    total: Int!
}

type LearnTrackLinkingCollections {
    entries(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnEntryCollection
    lessons(limit: Int = 100, locale: String, preview: Boolean, skip: Int = 0): LearnLessonCollection
}

type LearnTrackTechnologiesCollection {
    items: [LearnTechnology]!
    limit: Int!
    skip: Int!
    total: Int!
}

type Mutation {
    account: AccountMutation
    advisors: AdvisorsMutation
    blog: BlogRootMutation
    calendar: CalendarMutation
    clear: ClearMutation
    labs: LabsMutation
    showcase: ShowcaseMutation
}

type Query {
    account: AccountQuery
    advisors: AdvisorsQuery
    blog: BlogRootQuery
    calendar: CalendarQuery
    clear: ClearQuery
    cms: CmsQuery
    labs: LabsQuery
    learn: LearnQuery
    showYourWork: ShowYourWorkQuery
    showcase: ShowcaseQuery
    twitch: TwitchQuery
}

type ShowYourWorkDiscordMessage {
    author: AccountUser
    createdAt: ShowYourWorkDateTime!
    id: String!
    imageUrl(fillBlur: Boolean, height: Float, strategy: ShowYourWorkResizeStrategy, width: Float): String!
    text: String!
    userId: String!
    videoUrl: String
}

type ShowYourWorkQuery {
    messages(skip: Float, take: Float): [ShowYourWorkDiscordMessage!]!
}

type ShowcaseAward {
    createdAt: ShowcaseDateTime!
    id: String!
    info: CmsAward
    modifier: String
    project: ShowcaseProject!
    type: String!
    updatedAt: ShowcaseDateTime!
}

type ShowcaseJudgement {
    createdAt: ShowcaseDateTime!
    id: String!
    judgingCriteria: ShowcaseJudgingCriteria!
    judgingPool: ShowcaseJudgingPool!
    updatedAt: ShowcaseDateTime!
    username: String!
    value: Float!
}

type ShowcaseJudgingCriteria {
    createdAt: ShowcaseDateTime!
    id: String!
    judgingPool: ShowcaseJudgingPool!
    name: String!
    updatedAt: ShowcaseDateTime!
    weight: Float!
}

type ShowcaseJudgingPool {
    createdAt: ShowcaseDateTime!
    eventGroupId: String
    eventId: String
    id: String!
    judgingCriteria: [ShowcaseJudgingCriteria!]!
    name: String!
    programId: String
    projects(needsJudging: Boolean = false, take: Float = 25.0): [ShowcaseProject!]!
    regionId: String
    results: [ShowcaseJudgingResult!]!
    updatedAt: ShowcaseDateTime!
}

type ShowcaseJudgingResult {
    count: Float!
    project: ShowcaseProject!
    subScores: [ShowcaseJudgingResultSubValue!]!
    value: Float!
}

type ShowcaseJudgingResultSubValue {
    count: Float!
    judgingCriteria: ShowcaseJudgingCriteria!
    value: Float!
}

type ShowcaseMedia {
    createdAt: ShowcaseDateTime!
    download: String
    id: String!
    image(fillBlur: Boolean, height: Float, strategy: ShowcaseResizeStrategy, width: Float): String!
    project: ShowcaseProject!
    stream: String
    topic: ShowcaseMediaTopic!
    type: ShowcaseMediaType!
    updatedAt: ShowcaseDateTime!
}

type ShowcaseMember {
    account: AccountUser
    createdAt: ShowcaseDateTime!
    project: ShowcaseProject!
    updatedAt: ShowcaseDateTime!
    username: String!
}

type ShowcaseMetadata {
    createdAt: ShowcaseDateTime!
    key: String!
    project: ShowcaseProject!
    updatedAt: ShowcaseDateTime!
    value: String!
    visibility: ShowcaseMetadataVisibility!
}

type ShowcaseMetricAggregate {
    project: ShowcaseProject!
    value: Float
}

type ShowcaseMetricTimeSeries {
    time: ShowcaseDateTime!
    value: Float!
}

type ShowcaseMutation {
    addAward(modifier: String, project: String!, type: String!): ShowcaseAward!
    addMember(project: String!, username: String!): ShowcaseMember!
    addReactions(id: String!, reactions: [ShowcaseAddReactionsInput!]!): Boolean!
    createJudgingPool(judgingPool: ShowcaseCreateJudgingPoolInput!): ShowcaseJudgingPool!
    createProject(project: ShowcaseCreateProjectInput!): ShowcaseProject!
    deleteMedia(id: String!): Boolean!
    deleteProject(id: String!): Boolean!
    editProject(id: String!, project: ShowcaseEditProjectInput!): ShowcaseProject!
    featureProject(id: String!, isFeatured: Boolean): Boolean!
    judgeProject(judgingCriteria: String!, project: String!, value: Float!): Boolean!
    recordMetric(member: String!, name: String!, project: String!, value: Float!): Boolean!
    removeAward(id: String!): Boolean!
    removeJudgingPool(judgingPool: String!): Boolean!
    removeMember(project: String!, username: String!): Boolean!
    setMetadata(key: String!, project: String!, value: String!, visibility: ShowcaseMetadataVisibility!): Boolean!
    unsetMetadata(key: String!, project: String!): Boolean!
    uploadMedia(project: String!, topic: ShowcaseMediaTopic!, type: ShowcaseMediaType!, upload: Upload!): ShowcaseMedia!
}

type ShowcaseProject {
    awards: [ShowcaseAward!]
    canAdmin: Boolean!
    canEdit: Boolean!
    challengesEncountered: String
    codeLink: String
    createdAt: ShowcaseDateTime!
    description: String
    eventGroup: CmsEvent
    eventGroupId: String
    eventId: String!
    featured: Boolean!
    id: String!
    media(take: Float = 100.0, topics: [ShowcaseMediaTopic!], type: ShowcaseMediaType): [ShowcaseMedia!]
    members: [ShowcaseMember!]
    metadata: [ShowcaseMetadata!]
    metadataValue(key: String!): String
    name: String!
    priorExperience: String
    program: CmsProgram
    programId: String!
    reactionCounts: [ShowcaseReactionCount!]!
    regionId: String
    slug: String
    type: ShowcaseProjectType!
    updatedAt: ShowcaseDateTime!
    userJudgement: [ShowcaseJudgement!]
    viewLink: String
}

type ShowcaseQuery {
    averageMemberRecentResponses(name: String!, projectWhere: ShowcaseProjectsWhere): [ShowcaseMetricAggregate!]!
    judgingPools: [ShowcaseJudgingPool!]!
    membersOverTime(where: ShowcaseProjectsWhere!): [ShowcaseMetricTimeSeries!]!
    myJudgingPool: ShowcaseJudgingPool!
    presentationReadyPercent(where: ShowcaseProjectsWhere!): Float!
    project(id: String, slug: String): ShowcaseProject!
    projects(orderBy: ShowcaseProjectOrderByArg, skip: Float, take: Float, where: ShowcaseProjectsWhere): [ShowcaseProject!]!
    projectsOverTime(where: ShowcaseProjectsWhere!): [ShowcaseMetricTimeSeries!]!
}

type ShowcaseReactionCount {
    count: Float!
    type: ShowcaseReactionType!
}

type Subscription {
    memberAdded(where: ShowcaseProjectsWhere): ShowcaseMember!
    memberRemoved(where: ShowcaseProjectsWhere): ShowcaseMember!
    projectCreated(where: ShowcaseProjectsWhere): ShowcaseProject!
    projectDeleted(where: ShowcaseProjectsWhere): ShowcaseProject!
    projectEdited(where: ShowcaseProjectsWhere): ShowcaseProject!
    userBadgeUpdate: AccountSubscriptionBadge
    userCultSelection: AccountSubscriptionUser
    userDisplayedBadgesUpdate: AccountSubscriptionUser
    userProfilePictureUpdate: AccountSubscriptionUser
    userRoleUpdate: AccountSubscriptionUser
    userUnlinkDiscord: String
    userUpdate: AccountSubscriptionUser
}

type TwitchLiveStatus {
    startedAt: String!
    thumbnail(height: Int!, width: Int!): String!
    title: String!
    url: String!
    username: String!
    viewerCount: Int!
}

type TwitchQuery {
    live: TwitchLiveStatus
}

enum AccountPizzaOrTurtle {
    PIZZA
    TURTLE
}

enum AccountUserPictureFit {
    CLAMP
    CLIP
    CROP
    FACEAREA
    FILL
    FILLMAX
    MAX
    MIN
    SCALE
}

enum AdvisorsAdvisorType {
    HR
    TECHNICAL
}

enum AdvisorsRequestType {
    INTERVIEW
    RESUME
}

"What rating to display avatars up to. Accepts 'G', 'PG', 'R', 'X', and are judged in that order. Default is the value of the 'avatar_rating' option"
enum BlogAvatarRatingEnum {
    G
    PG
    R
    X
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogCategoryIdType {
    "The Database ID for the node"
    DATABASE_ID
    "The hashed Global ID"
    ID
    "The name of the node"
    NAME
    "Url friendly name of the node"
    SLUG
    "The URI for the node"
    URI
}

"Options for ordering the connection"
enum BlogCommentsConnectionOrderbyEnum {
    COMMENT_AGENT
    COMMENT_APPROVED
    COMMENT_AUTHOR
    COMMENT_AUTHOR_EMAIL
    COMMENT_AUTHOR_IP
    COMMENT_AUTHOR_URL
    COMMENT_CONTENT
    COMMENT_DATE
    COMMENT_DATE_GMT
    COMMENT_ID
    COMMENT_IN
    COMMENT_KARMA
    COMMENT_PARENT
    COMMENT_POST_ID
    COMMENT_TYPE
    USER_ID
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogContentNodeIdTypeEnum {
    "Identify a resource by the Database ID."
    DATABASE_ID
    "Identify a resource by the (hashed) Global ID."
    ID
    "Identify a resource by the URI."
    URI
}

"Allowed Content Types"
enum BlogContentTypeEnum {
    "The Type of Content object"
    ATTACHMENT
    "The Type of Content object"
    PAGE
    "The Type of Content object"
    POST
}

"The Type of Identifier used to fetch a single Content Type node. To be used along with the \"id\" field. Default is \"ID\"."
enum BlogContentTypeIdTypeEnum {
    "The globally unique ID"
    ID
    "The name of the content type."
    NAME
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogMediaItemIdType {
    "Identify a resource by the Database ID."
    DATABASE_ID
    "Identify a resource by the (hashed) Global ID."
    ID
    "Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier."
    SLUG
    "Identify a media item by its source url"
    SOURCE_URL
    "Identify a resource by the URI."
    URI
}

"The size of the media item object."
enum BlogMediaItemSizeEnum {
    "MediaItem with the large size"
    LARGE
    "MediaItem with the medium size"
    MEDIUM
    "MediaItem with the medium_large size"
    MEDIUM_LARGE
    "MediaItem with the thumbnail size"
    THUMBNAIL
    "MediaItem with the 1536x1536 size"
    _1536X1536
    "MediaItem with the 2048x2048 size"
    _2048X2048
}

"The status of the media item object."
enum BlogMediaItemStatusEnum {
    "Objects with the auto-draft status"
    AUTO_DRAFT
    "Objects with the inherit status"
    INHERIT
    "Objects with the private status"
    PRIVATE
    "Objects with the trash status"
    TRASH
}

"Registered menu locations"
enum BlogMenuLocationEnum {
    EMPTY
}

"The MimeType of the object"
enum BlogMimeTypeEnum {
    APPLICATION_JAVA
    APPLICATION_MSWORD
    APPLICATION_OCTET_STREAM
    APPLICATION_ONENOTE
    APPLICATION_OXPS
    APPLICATION_PDF
    APPLICATION_RAR
    APPLICATION_RTF
    APPLICATION_TTAF_XML
    APPLICATION_VND_APPLE_KEYNOTE
    APPLICATION_VND_APPLE_NUMBERS
    APPLICATION_VND_APPLE_PAGES
    APPLICATION_VND_MS_ACCESS
    APPLICATION_VND_MS_EXCEL
    APPLICATION_VND_MS_EXCEL_ADDIN_MACROENABLED_12
    APPLICATION_VND_MS_EXCEL_SHEET_BINARY_MACROENABLED_12
    APPLICATION_VND_MS_EXCEL_SHEET_MACROENABLED_12
    APPLICATION_VND_MS_EXCEL_TEMPLATE_MACROENABLED_12
    APPLICATION_VND_MS_POWERPOINT
    APPLICATION_VND_MS_POWERPOINT_ADDIN_MACROENABLED_12
    APPLICATION_VND_MS_POWERPOINT_PRESENTATION_MACROENABLED_12
    APPLICATION_VND_MS_POWERPOINT_SLIDESHOW_MACROENABLED_12
    APPLICATION_VND_MS_POWERPOINT_SLIDE_MACROENABLED_12
    APPLICATION_VND_MS_POWERPOINT_TEMPLATE_MACROENABLED_12
    APPLICATION_VND_MS_PROJECT
    APPLICATION_VND_MS_WORD_DOCUMENT_MACROENABLED_12
    APPLICATION_VND_MS_WORD_TEMPLATE_MACROENABLED_12
    APPLICATION_VND_MS_WRITE
    APPLICATION_VND_MS_XPSDOCUMENT
    APPLICATION_VND_OASIS_OPENDOCUMENT_CHART
    APPLICATION_VND_OASIS_OPENDOCUMENT_DATABASE
    APPLICATION_VND_OASIS_OPENDOCUMENT_FORMULA
    APPLICATION_VND_OASIS_OPENDOCUMENT_GRAPHICS
    APPLICATION_VND_OASIS_OPENDOCUMENT_PRESENTATION
    APPLICATION_VND_OASIS_OPENDOCUMENT_SPREADSHEET
    APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_PRESENTATION
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDE
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDESHOW
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_TEMPLATE
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_SHEET
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_TEMPLATE
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_DOCUMENT
    APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_TEMPLATE
    APPLICATION_WORDPERFECT
    APPLICATION_X_7Z_COMPRESSED
    APPLICATION_X_GZIP
    APPLICATION_X_TAR
    APPLICATION_ZIP
    AUDIO_AAC
    AUDIO_FLAC
    AUDIO_MIDI
    AUDIO_MPEG
    AUDIO_OGG
    AUDIO_WAV
    AUDIO_X_MATROSKA
    AUDIO_X_MS_WAX
    AUDIO_X_MS_WMA
    AUDIO_X_REALAUDIO
    IMAGE_BMP
    IMAGE_GIF
    IMAGE_JPEG
    IMAGE_PNG
    IMAGE_TIFF
    IMAGE_X_ICON
    TEXT_CALENDAR
    TEXT_CSS
    TEXT_CSV
    TEXT_PLAIN
    TEXT_RICHTEXT
    TEXT_TAB_SEPARATED_VALUES
    TEXT_VTT
    VIDEO_3GPP
    VIDEO_3GPP2
    VIDEO_AVI
    VIDEO_DIVX
    VIDEO_MP4
    VIDEO_MPEG
    VIDEO_OGG
    VIDEO_QUICKTIME
    VIDEO_WEBM
    VIDEO_X_FLV
    VIDEO_X_MATROSKA
    VIDEO_X_MS_ASF
    VIDEO_X_MS_WM
    VIDEO_X_MS_WMV
    VIDEO_X_MS_WMX
}

"The cardinality of the connection order"
enum BlogOrderEnum {
    ASC
    DESC
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogPageIdType {
    "Identify a resource by the Database ID."
    DATABASE_ID
    "Identify a resource by the (hashed) Global ID."
    ID
    "Identify a resource by the URI."
    URI
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogPostFormatIdType {
    "The Database ID for the node"
    DATABASE_ID
    "The hashed Global ID"
    ID
    "The name of the node"
    NAME
    "Url friendly name of the node"
    SLUG
    "The URI for the node"
    URI
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogPostIdType {
    "Identify a resource by the Database ID."
    DATABASE_ID
    "Identify a resource by the (hashed) Global ID."
    ID
    "Identify a resource by the slug. Available to non-hierarchcial Types where the slug is a unique identifier."
    SLUG
    "Identify a resource by the URI."
    URI
}

"The format of post field data."
enum BlogPostObjectFieldFormatEnum {
    "Provide the field value directly from database"
    RAW
    "Apply the default WordPress rendering"
    RENDERED
}

"The column to use when filtering by date"
enum BlogPostObjectsConnectionDateColumnEnum {
    DATE
    MODIFIED
}

"Field to order the connection by"
enum BlogPostObjectsConnectionOrderbyEnum {
    "Order by author"
    AUTHOR
    "Order by publish date"
    DATE
    "Preserve the ID order given in the IN array"
    IN
    "Order by the menu order value"
    MENU_ORDER
    "Order by last modified date"
    MODIFIED
    "Preserve slug order given in the NAME_IN array"
    NAME_IN
    "Order by parent ID"
    PARENT
    "Order by slug"
    SLUG
    "Order by title"
    TITLE
}

"The status of the object."
enum BlogPostStatusEnum {
    "Objects with the acf-disabled status"
    ACF_DISABLED
    "Objects with the auto-draft status"
    AUTO_DRAFT
    "Objects with the draft status"
    DRAFT
    "Objects with the future status"
    FUTURE
    "Objects with the inherit status"
    INHERIT
    "Objects with the pending status"
    PENDING
    "Objects with the private status"
    PRIVATE
    "Objects with the publish status"
    PUBLISH
    "Objects with the request-completed status"
    REQUEST_COMPLETED
    "Objects with the request-confirmed status"
    REQUEST_CONFIRMED
    "Objects with the request-failed status"
    REQUEST_FAILED
    "Objects with the request-pending status"
    REQUEST_PENDING
    "Objects with the trash status"
    TRASH
}

"The logical relation between each item in the array when there are more than one."
enum BlogRelationEnum {
    AND
    OR
}

"The Type of Identifier used to fetch a single resource. Default is ID."
enum BlogTagIdType {
    "The Database ID for the node"
    DATABASE_ID
    "The hashed Global ID"
    ID
    "The name of the node"
    NAME
    "Url friendly name of the node"
    SLUG
    "The URI for the node"
    URI
}

"Allowed taxonomies"
enum BlogTaxonomyEnum {
    CATEGORY
    POSTFORMAT
    TAG
}

"The Type of Identifier used to fetch a single Taxonomy node. To be used along with the \"id\" field. Default is \"ID\"."
enum BlogTaxonomyIdTypeEnum {
    "The globally unique ID"
    ID
    "The name of the taxonomy"
    NAME
}

"The Type of Identifier used to fetch a single resource. Default is \"ID\". To be used along with the \"id\" field."
enum BlogTermNodeIdTypeEnum {
    "The Database ID for the node"
    DATABASE_ID
    "The hashed Global ID"
    ID
    "The name of the node"
    NAME
    "Url friendly name of the node"
    SLUG
    "The URI for the node"
    URI
}

"Options for ordering the connection by"
enum BlogTermObjectsConnectionOrderbyEnum {
    COUNT
    DESCRIPTION
    NAME
    SLUG
    TERM_GROUP
    TERM_ID
    TERM_ORDER
}

"The Type of Identifier used to fetch a single User node. To be used along with the \"id\" field. Default is \"ID\"."
enum BlogUserNodeIdTypeEnum {
    "The Database ID for the node"
    DATABASE_ID
    "The Email of the User"
    EMAIL
    "The hashed Global ID"
    ID
    "The slug of the User"
    SLUG
    "The URI for the node"
    URI
    "The username the User uses to login with"
    USERNAME
}

"Names of available user roles"
enum BlogUserRoleEnum {
    ADMINISTRATOR
    AUTHOR
    CONTRIBUTOR
    EDITOR
    SUBSCRIBER
}

"Field to order the connection by"
enum BlogUsersConnectionOrderbyEnum {
    "Order by display name"
    DISPLAY_NAME
    "Order by email address"
    EMAIL
    "Order by login"
    LOGIN
    "Preserve the login order given in the LOGIN_IN array"
    LOGIN_IN
    "Order by nice name"
    NICE_NAME
    "Preserve the nice name order given in the NICE_NAME_IN array"
    NICE_NAME_IN
    "Order by registration date"
    REGISTERED
    "Order by URL"
    URL
}

enum CalendarFormat {
    DISCORD
    HTML
    MARKDOWN
}

enum CalendarOrder {
    ASC
    DESC
}

enum ClearEventGroupScalarFieldEnum {
    createdAt
    earlyBirdCutoff
    earlyBirdPrice
    endDate
    id
    metadata
    name
    registrationCutoff
    startDate
    ticketPrice
    updatedAt
}

enum ClearEventScalarFieldEnum {
    contentfulWebname
    createdAt
    earlyBirdCutoff
    earlyBirdPrice
    endDate
    eventGroupId
    id
    managers
    metadata
    name
    registrationCutoff
    registrationsOpen
    startDate
    ticketPrice
    updatedAt
    venueId
}

enum ClearPaymentScalarFieldEnum {
    createdAt
    id
    metadata
    total
    updatedAt
}

enum ClearPersonScalarFieldEnum {
    age
    createdAt
    email
    firstName
    id
    lastName
    metadata
    phone
    pronouns
    updatedAt
    username
}

enum ClearQueryMode {
    default
    insensitive
}

enum ClearScheduleItemScalarFieldEnum {
    createdAt
    description
    end
    eventGroupId
    eventId
    finalized
    hostEmail
    hostName
    hostPronoun
    id
    internal
    link
    metadata
    name
    organizerEmail
    organizerName
    organizerPhone
    start
    type
    updatedAt
}

enum ClearSortOrder {
    asc
    desc
}

enum ClearSponsorScalarFieldEnum {
    amount
    contactEmail
    contactName
    contactPhone
    createdAt
    description
    eventId
    id
    logoImageUri
    metadata
    name
    perks
    updatedAt
}

enum ClearTicketScalarFieldEnum {
    age
    couponCode
    createdAt
    email
    eventId
    firstName
    id
    lastName
    metadata
    paymentId
    personId
    phone
    type
    updatedAt
    waiverSigned
}

enum ClearTicketType {
    JUDGE
    MENTOR
    STAFF
    STUDENT
    TEACHER
    VIP
}

enum ClearVenueScalarFieldEnum {
    address
    capacity
    contactEmail
    contactName
    contactPhone
    createdAt
    id
    mapLink
    metadata
    name
    updatedAt
}

enum CmsAnnouncementOrder {
    displayAt_ASC
    displayAt_DESC
    endAt_ASC
    endAt_DESC
    link_ASC
    link_DESC
    oneline_ASC
    oneline_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    type_ASC
    type_DESC
    visibility_ASC
    visibility_DESC
}

enum CmsAssetOrder {
    contentType_ASC
    contentType_DESC
    fileName_ASC
    fileName_DESC
    height_ASC
    height_DESC
    size_ASC
    size_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    url_ASC
    url_DESC
    width_ASC
    width_DESC
}

enum CmsAwardOrder {
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    ranking_ASC
    ranking_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum CmsBadgeOrder {
    description_ASC
    description_DESC
    earnCriteria_ASC
    earnCriteria_DESC
    emoji_ASC
    emoji_DESC
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum CmsBumperOrder {
    ambient_ASC
    ambient_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
}

enum CmsCommunityPartnerOrder {
    blurb_ASC
    blurb_DESC
    cost_ASC
    cost_DESC
    displayUrl_ASC
    displayUrl_DESC
    eligibility_ASC
    eligibility_DESC
    expires_ASC
    expires_DESC
    name_ASC
    name_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    url_ASC
    url_DESC
}

enum CmsContentTypeStringOrder {
    key_ASC
    key_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum CmsEntryOrder {
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum CmsEventOrder {
    awardsAt_ASC
    awardsAt_DESC
    calendarReleaseDate_ASC
    calendarReleaseDate_DESC
    endsAt_ASC
    endsAt_DESC
    id_ASC
    id_DESC
    participantRoleId_ASC
    participantRoleId_DESC
    registrationsCloseAt_ASC
    registrationsCloseAt_DESC
    registrationsOpenAt_ASC
    registrationsOpenAt_DESC
    startsAt_ASC
    startsAt_DESC
    statEventCount_ASC
    statEventCount_DESC
    statLowInterestContinuedCount_ASC
    statLowInterestContinuedCount_DESC
    statLowInterestCount_ASC
    statLowInterestCount_DESC
    statStudentCount_ASC
    statStudentCount_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    theme_ASC
    theme_DESC
    title_ASC
    title_DESC
}

enum CmsFaqOrder {
    featured_ASC
    featured_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
}

enum CmsFormOrder {
    cognitoForm_ASC
    cognitoForm_DESC
    slug_ASC
    slug_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
}

enum CmsGlobalSponsorOrder {
    instagramUsername_ASC
    instagramUsername_DESC
    link_ASC
    link_DESC
    name_ASC
    name_DESC
    shortDescription_ASC
    shortDescription_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    twitterUsername_ASC
    twitterUsername_DESC
    type_ASC
    type_DESC
}

enum CmsHiringCompanyOrder {
    featured_ASC
    featured_DESC
    name_ASC
    name_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    url_ASC
    url_DESC
}

enum CmsHiringPostOrder {
    paid_ASC
    paid_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    type_ASC
    type_DESC
    url_ASC
    url_DESC
}

enum CmsImageFormat {
    "JPG image format."
    JPG
    """

    Progressive JPG format stores multiple passes of an image in progressively higher detail.
    When a progressive image is loading, the viewer will first see a lower quality pixelated version which
    will gradually improve in detail, until the image is fully downloaded. This is to display an image as
    early as possible to make the layout look as designed.
    """
    JPG_PROGRESSIVE
    "PNG image format"
    PNG
    """

    8-bit PNG images support up to 256 colors and weigh less than the standard 24-bit PNG equivalent.
    The 8-bit PNG format is mostly used for simple images, such as icons or logos.
    """
    PNG8
    "WebP image format."
    WEBP
}

enum CmsImageResizeFocus {
    "Focus the resizing on the bottom."
    BOTTOM
    "Focus the resizing on the bottom left."
    BOTTOM_LEFT
    "Focus the resizing on the bottom right."
    BOTTOM_RIGHT
    "Focus the resizing on the center."
    CENTER
    "Focus the resizing on the largest face."
    FACE
    "Focus the resizing on the area containing all the faces."
    FACES
    "Focus the resizing on the left."
    LEFT
    "Focus the resizing on the right."
    RIGHT
    "Focus the resizing on the top."
    TOP
    "Focus the resizing on the top left."
    TOP_LEFT
    "Focus the resizing on the top right."
    TOP_RIGHT
}

enum CmsImageResizeStrategy {
    "Crops a part of the original image to fit into the specified dimensions."
    CROP
    "Resizes the image to the specified dimensions, cropping the image if needed."
    FILL
    "Resizes the image to fit into the specified dimensions."
    FIT
    """

    Resizes the image to the specified dimensions, padding the image if needed.
    Uses desired background color as padding color.
    """
    PAD
    "Resizes the image to the specified dimensions, changing the original aspect ratio if needed."
    SCALE
    "Creates a thumbnail from the image."
    THUMB
}

enum CmsLegalDocumentOrder {
    date_ASC
    date_DESC
    id_ASC
    id_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    type_ASC
    type_DESC
}

enum CmsNewsCoverageOrder {
    date_ASC
    date_DESC
    featured_ASC
    featured_DESC
    publicationName_ASC
    publicationName_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    url_ASC
    url_DESC
}

enum CmsPressPhotoOrder {
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum CmsProgramOrder {
    name_ASC
    name_DESC
    shortDescription_ASC
    shortDescription_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    type_ASC
    type_DESC
    url_ASC
    url_DESC
    virtual_ASC
    virtual_DESC
    volunteerUrl_ASC
    volunteerUrl_DESC
    webname_ASC
    webname_DESC
}

enum CmsRegionOrder {
    abbr_ASC
    abbr_DESC
    accountingName_ASC
    accountingName_DESC
    motto_ASC
    motto_DESC
    name_ASC
    name_DESC
    primaryColor_ASC
    primaryColor_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    timezone_ASC
    timezone_DESC
    webname_ASC
    webname_DESC
}

enum CmsSiteOrder {
    link_ASC
    link_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    type_ASC
    type_DESC
}

enum CmsStockMusicOrder {
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
}

enum CmsTestimonialOrder {
    company_ASC
    company_DESC
    experience_ASC
    experience_DESC
    featured_ASC
    featured_DESC
    firstName_ASC
    firstName_DESC
    groupName_ASC
    groupName_DESC
    lastName_ASC
    lastName_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    title_ASC
    title_DESC
    type_ASC
    type_DESC
}

enum LabsMentorStatus {
    ACCEPTED
    APPLIED
    CANCELED
    REJECTED
    SCHEDULED
}

enum LabsProjectStatus {
    ACCEPTED
    DRAFT
    MATCHED
    PROPOSED
}

enum LabsRejectionReason {
    EXPERIENCE_HIGH
    EXPERIENCE_LOW
    OTHER
}

enum LabsStudentStatus {
    ACCEPTED
    APPLIED
    CANCELED
    OFFERED
    REJECTED
    TRACK_CHALLENGE
    TRACK_INTERVIEW
}

enum LabsTagType {
    INTEREST
    TECHNOLOGY
}

enum LabsTrack {
    ADVANCED
    BEGINNER
    INTERMEDIATE
}

enum LearnAssetOrder {
    contentType_ASC
    contentType_DESC
    fileName_ASC
    fileName_DESC
    height_ASC
    height_DESC
    size_ASC
    size_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
    url_ASC
    url_DESC
    width_ASC
    width_DESC
}

enum LearnCodeBlockOrder {
    language_ASC
    language_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnDifficultyOrder {
    hexCodeColor_ASC
    hexCodeColor_DESC
    name_ASC
    name_DESC
    shortDescription_ASC
    shortDescription_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnEntryOrder {
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnImageFormat {
    "JPG image format."
    JPG
    """

    Progressive JPG format stores multiple passes of an image in progressively higher detail.
    When a progressive image is loading, the viewer will first see a lower quality pixelated version which
    will gradually improve in detail, until the image is fully downloaded. This is to display an image as
    early as possible to make the layout look as designed.
    """
    JPG_PROGRESSIVE
    "PNG image format"
    PNG
    """

    8-bit PNG images support up to 256 colors and weigh less than the standard 24-bit PNG equivalent.
    The 8-bit PNG format is mostly used for simple images, such as icons or logos.
    """
    PNG8
    "WebP image format."
    WEBP
}

enum LearnImageResizeFocus {
    "Focus the resizing on the bottom."
    BOTTOM
    "Focus the resizing on the bottom left."
    BOTTOM_LEFT
    "Focus the resizing on the bottom right."
    BOTTOM_RIGHT
    "Focus the resizing on the center."
    CENTER
    "Focus the resizing on the largest face."
    FACE
    "Focus the resizing on the area containing all the faces."
    FACES
    "Focus the resizing on the left."
    LEFT
    "Focus the resizing on the right."
    RIGHT
    "Focus the resizing on the top."
    TOP
    "Focus the resizing on the top left."
    TOP_LEFT
    "Focus the resizing on the top right."
    TOP_RIGHT
}

enum LearnImageResizeStrategy {
    "Crops a part of the original image to fit into the specified dimensions."
    CROP
    "Resizes the image to the specified dimensions, cropping the image if needed."
    FILL
    "Resizes the image to fit into the specified dimensions."
    FIT
    """

    Resizes the image to the specified dimensions, padding the image if needed.
    Uses desired background color as padding color.
    """
    PAD
    "Resizes the image to the specified dimensions, changing the original aspect ratio if needed."
    SCALE
    "Creates a thumbnail from the image."
    THUMB
}

enum LearnLessonOrder {
    hasNextPage_ASC
    hasNextPage_DESC
    id_ASC
    id_DESC
    nameHeader_ASC
    nameHeader_DESC
    pageNumber_ASC
    pageNumber_DESC
    points_ASC
    points_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnRewardOrder {
    name_ASC
    name_DESC
    shortDescription_ASC
    shortDescription_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnTechnologyOrder {
    name_ASC
    name_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum LearnTrackOrder {
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    spotlighted_ASC
    spotlighted_DESC
    sys_firstPublishedAt_ASC
    sys_firstPublishedAt_DESC
    sys_id_ASC
    sys_id_DESC
    sys_publishedAt_ASC
    sys_publishedAt_DESC
    sys_publishedVersion_ASC
    sys_publishedVersion_DESC
}

enum ShowYourWorkResizeStrategy {
    CLAMP
    CLIP
    CROP
    FACEAREA
    FILL
    FILLMAX
    MAX
    MIN
    SCALE
}

enum ShowcaseMediaFilterType {
    ANY
    AUDIOS
    BOTH
    IMAGES
    VIDEOS
}

enum ShowcaseMediaTopic {
    DEMO
    JUDGES
    PRESENTATION
    TEAM
}

enum ShowcaseMediaType {
    AUDIO
    IMAGE
    VIDEO
}

enum ShowcaseMetadataVisibility {
    ADMIN
    PRIVATE
    PUBLIC
}

enum ShowcaseProjectOrderByArg {
    NEWEST
    OLDEST
}

enum ShowcaseProjectType {
    APP
    BOT
    GAME
    HARDWARE
    LIBRARY
    OTHER
    VR
    WEBSITE
}

enum ShowcaseReactionType {
    CLAP
    GRIN
    HEART
    UPVOTE
}

enum ShowcaseResizeStrategy {
    CLAMP
    CLIP
    CROP
    FACEAREA
    FILL
    FILLMAX
    MAX
    MIN
    SCALE
}

input AccountDisplayedUserBadgeInput {
    id: ID!
    order: Int!
}

input AccountUpdateUserInput {
    acceptTos: Boolean
    bio: String
    blocked: Boolean
    displayNameFormat: String
    email: String
    familyName: String
    givenName: String
    phoneNumber: String
    pronoun: String
    title: String
    username: String
}

input AccountUserBadgeInput {
    displayed: Boolean
    expiresUtc: String
    id: ID!
    order: Int
}

input AccountUserPictureTransformInput {
    fit: AccountUserPictureFit
    height: Int
    width: Int
}

input AccountUserSearch {
    familyName: String
    givenName: String
    name: String
    username: String
}

input AccountUserSingleInput {
    discordId: String
    email: String
    id: ID
    username: String
}

input AdvisorsAdvisorCreateInput {
    email: String!
    familyName: String!
    givenName: String!
    limits: AdvisorsAdvisorLimitInput!
    type: AdvisorsAdvisorType!
    username: String
}

input AdvisorsAdvisorLimitInput {
    interviewsPerWeek: Float!
    resumesPerWeek: Float!
}

input AdvisorsAdvisorWhereInput {
    email: String
    id: String
    username: String
}

"Arguments for filtering the CategoryToCategoryConnection connection"
input BlogCategoryToCategoryConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Default false. If true, only the items connected to the source item will be returned. If false, all items will be returned regardless of connection to the source"
    shouldOnlyIncludeConnectedItems: Boolean
    "Default false. If true, the connection will be output in a flat list instead of the hierarchical list. So child terms will be output in the same level as the parent terms"
    shouldOutputInFlatList: Boolean
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the CategoryToPostConnection connection"
input BlogCategoryToPostConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Arguments for filtering the CommentToCommentConnection connection"
input BlogCommentToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    """

    Array of IDs of users whose unapproved comments will be returned by the
    query regardless of status.
    """
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    """

    Limit results to those affiliated with a given content object
    ID.
    """
    contentId: ID
    """

    Array of content object IDs to include affiliated comments
    for.
    """
    contentIdIn: [ID]
    """

    Array of content object IDs to exclude affiliated comments
    for.
    """
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    """

    Array of parent IDs of comments *not* to retrieve children
    for.
    """
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Input for the createCategory mutation"
input BlogCreateCategoryInput {
    "The slug that the category will be an alias of"
    aliasOf: String
    clientMutationId: String!
    "The description of the category object"
    description: String
    "The name of the category object to mutate"
    name: String!
    "The ID of the category that should be set as the parent"
    parentId: ID
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the createComment mutation"
input BlogCreateCommentInput {
    "User agent used to post the comment."
    agent: String
    "The approval status of the comment."
    approved: String
    "The name of the comment's author."
    author: String
    "The email of the comment's author."
    authorEmail: String
    "IP address for the comment's author."
    authorIp: String
    "The url of the comment's author."
    authorUrl: String
    clientMutationId: String!
    "The ID of the post object the comment belongs to."
    commentOn: Int
    "Content of the comment."
    content: String
    "The date of the object. Preferable to enter as year/month/day ( e.g. 01/31/2017 ) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "Parent comment of current comment."
    parent: ID
    "Type of comment."
    type: String
    "The userID of the comment's author."
    userId: Int
}

"Input for the createMediaItem mutation"
input BlogCreateMediaItemInput {
    "Alternative text to display when mediaItem is not displayed"
    altText: String
    "The userId to assign as the author of the mediaItem"
    authorId: ID
    "The caption for the mediaItem"
    caption: String
    clientMutationId: String!
    "The comment status for the mediaItem"
    commentStatus: String
    "The date of the mediaItem"
    date: String
    "The date (in GMT zone) of the mediaItem"
    dateGmt: String
    "Description of the mediaItem"
    description: String
    "The file name of the mediaItem"
    filePath: String
    "The file type of the mediaItem"
    fileType: BlogMimeTypeEnum
    "The WordPress post ID or the graphQL postId of the parent object"
    parentId: ID
    "The ping status for the mediaItem"
    pingStatus: String
    "The slug of the mediaItem"
    slug: String
    "The status of the mediaItem"
    status: BlogMediaItemStatusEnum
    "The title of the mediaItem"
    title: String
}

"Input for the createPage mutation"
input BlogCreatePageInput {
    "The userId to assign as the author of the object"
    authorId: ID
    clientMutationId: String!
    "The comment status for the object"
    commentStatus: String
    "The content of the object"
    content: String
    "The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int
    "The ID of the parent object"
    parentId: ID
    "The password used to protect the content of the object"
    password: String
    "The slug of the object"
    slug: String
    "The title of the object"
    title: String
}

"Input for the createPostFormat mutation"
input BlogCreatePostFormatInput {
    "The slug that the post_format will be an alias of"
    aliasOf: String
    clientMutationId: String!
    "The description of the post_format object"
    description: String
    "The name of the post_format object to mutate"
    name: String!
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the createPost mutation"
input BlogCreatePostInput {
    "The userId to assign as the author of the object"
    authorId: ID
    "Set connections between the post and categories"
    categories: BlogPostCategoriesInput
    clientMutationId: String!
    "The comment status for the object"
    commentStatus: String
    "The content of the object"
    content: String
    "The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "The excerpt of the object"
    excerpt: String
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int
    "The password used to protect the content of the object"
    password: String
    "The ping status for the object"
    pingStatus: String
    "URLs that have been pinged."
    pinged: [String]
    "Set connections between the post and postFormats"
    postFormats: BlogPostPostFormatsInput
    "The slug of the object"
    slug: String
    "Set connections between the post and tags"
    tags: BlogPostTagsInput
    "The title of the object"
    title: String
    "URLs queued to be pinged."
    toPing: [String]
}

"Input for the createTag mutation"
input BlogCreateTagInput {
    "The slug that the post_tag will be an alias of"
    aliasOf: String
    clientMutationId: String!
    "The description of the post_tag object"
    description: String
    "The name of the post_tag object to mutate"
    name: String!
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the createUser mutation"
input BlogCreateUserInput {
    "User's AOL IM account."
    aim: String
    clientMutationId: String!
    "A string containing content about the user."
    description: String
    "A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user)."
    displayName: String
    "A string containing the user's email address."
    email: String
    "\tThe user's first name."
    firstName: String
    "User's Jabber account."
    jabber: String
    "The user's last name."
    lastName: String
    "User's locale."
    locale: String
    "A string that contains a URL-friendly name for the user. The default is the user's username."
    nicename: String
    "The user's nickname, defaults to the user's username."
    nickname: String
    "A string that contains the plain text password for the user."
    password: String
    "The date the user registered. Format is Y-m-d H:i:s."
    registered: String
    "A string for whether to enable the rich editor or not. False if not empty."
    richEditing: String
    "An array of roles to be assigned to the user."
    roles: [String]
    "A string that contains the user's username for logging in."
    username: String!
    "A string containing the user's URL for the user's web site."
    websiteUrl: String
    "User's Yahoo IM account."
    yim: String
}

"Date values"
input BlogDateInput {
    "Day of the month (from 1 to 31)"
    day: Int
    "Month number (from 1 to 12)"
    month: Int
    "4 digit year (e.g. 2017)"
    year: Int
}

"Filter the connection based on input"
input BlogDateQueryInput {
    "Nodes should be returned after this date"
    after: BlogDateInput
    "Nodes should be returned before this date"
    before: BlogDateInput
    "Column to query against"
    column: BlogPostObjectsConnectionDateColumnEnum
    "For after/before, whether exact value should be matched or not"
    compare: String
    "Day of the month (from 1 to 31)"
    day: Int
    "Hour (from 0 to 23)"
    hour: Int
    "For after/before, whether exact value should be matched or not"
    inclusive: Boolean
    "Minute (from 0 to 59)"
    minute: Int
    "Month number (from 1 to 12)"
    month: Int
    "OR or AND, how the sub-arrays should be compared"
    relation: BlogRelationEnum
    "Second (0 to 59)"
    second: Int
    "Week of the year (from 0 to 53)"
    week: Int
    "4 digit year (e.g. 2017)"
    year: Int
}

"Input for the deleteCategory mutation"
input BlogDeleteCategoryInput {
    clientMutationId: String!
    "The ID of the category to delete"
    id: ID!
}

"Input for the deleteComment mutation"
input BlogDeleteCommentInput {
    clientMutationId: String!
    "Whether the comment should be force deleted instead of being moved to the trash"
    forceDelete: Boolean
    "The deleted comment ID"
    id: ID!
}

"Input for the deleteMediaItem mutation"
input BlogDeleteMediaItemInput {
    clientMutationId: String!
    "Whether the mediaItem should be force deleted instead of being moved to the trash"
    forceDelete: Boolean
    "The ID of the mediaItem to delete"
    id: ID!
}

"Input for the deletePage mutation"
input BlogDeletePageInput {
    clientMutationId: String!
    "Whether the object should be force deleted instead of being moved to the trash"
    forceDelete: Boolean
    "The ID of the page to delete"
    id: ID!
}

"Input for the deletePostFormat mutation"
input BlogDeletePostFormatInput {
    clientMutationId: String!
    "The ID of the postFormat to delete"
    id: ID!
}

"Input for the deletePost mutation"
input BlogDeletePostInput {
    clientMutationId: String!
    "Whether the object should be force deleted instead of being moved to the trash"
    forceDelete: Boolean
    "The ID of the post to delete"
    id: ID!
}

"Input for the deleteTag mutation"
input BlogDeleteTagInput {
    clientMutationId: String!
    "The ID of the tag to delete"
    id: ID!
}

"Input for the deleteUser mutation"
input BlogDeleteUserInput {
    clientMutationId: String!
    "The ID of the user you want to delete"
    id: ID!
    "Reassign posts and links to new User ID."
    reassignId: ID
}

"Arguments for filtering the MediaItemToCommentConnection connection"
input BlogMediaItemToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    """

    Array of IDs of users whose unapproved comments will be returned by the
    query regardless of status.
    """
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    """

    Limit results to those affiliated with a given content object
    ID.
    """
    contentId: ID
    """

    Array of content object IDs to include affiliated comments
    for.
    """
    contentIdIn: [ID]
    """

    Array of content object IDs to exclude affiliated comments
    for.
    """
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    """

    Array of parent IDs of comments *not* to retrieve children
    for.
    """
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the MenuItemToMenuItemConnection connection"
input BlogMenuItemToMenuItemConnectionWhereArgs {
    "The ID of the object"
    id: Int
    "The menu location for the menu being queried"
    location: BlogMenuLocationEnum
}

"Arguments for filtering the MenuToMenuItemConnection connection"
input BlogMenuToMenuItemConnectionWhereArgs {
    "The ID of the object"
    id: Int
    "The menu location for the menu being queried"
    location: BlogMenuLocationEnum
}

"Arguments for filtering the PageToCommentConnection connection"
input BlogPageToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    """

    Array of IDs of users whose unapproved comments will be returned by the
    query regardless of status.
    """
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    """

    Limit results to those affiliated with a given content object
    ID.
    """
    contentId: ID
    """

    Array of content object IDs to include affiliated comments
    for.
    """
    contentIdIn: [ID]
    """

    Array of content object IDs to exclude affiliated comments
    for.
    """
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    """

    Array of parent IDs of comments *not* to retrieve children
    for.
    """
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the PageToPageConnection connection"
input BlogPageToPageConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the pageToRevisionConnection connection"
input BlogPageToRevisionConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Set relationships between the post to categories"
input BlogPostCategoriesInput {
    "If true, this will append the category to existing related categories. If false, this will replace existing relationships. Default true."
    append: Boolean
    nodes: [BlogPostCategoriesNodeInput]
}

"List of categories to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists."
input BlogPostCategoriesNodeInput {
    "The description of the category. This field is used to set a description of the category if a new one is created during the mutation."
    description: String
    "The ID of the category. If present, this will be used to connect to the post. If no existing category exists with this ID, no connection will be made."
    id: ID
    "The name of the category. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field."
    name: String
    "The slug of the category. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation."
    slug: String
}

"Arguments for filtering the PostFormatToPostConnection connection"
input BlogPostFormatToPostConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Options for ordering the connection"
input BlogPostObjectsConnectionOrderbyInput {
    "The field to order the connection by"
    field: BlogPostObjectsConnectionOrderbyEnum!
    "Possible directions in which to order a list of items"
    order: BlogOrderEnum!
}

"Set relationships between the post to postFormats"
input BlogPostPostFormatsInput {
    "If true, this will append the postFormat to existing related postFormats. If false, this will replace existing relationships. Default true."
    append: Boolean
    nodes: [BlogPostPostFormatsNodeInput]
}

"List of postFormats to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists."
input BlogPostPostFormatsNodeInput {
    "The description of the postFormat. This field is used to set a description of the postFormat if a new one is created during the mutation."
    description: String
    "The ID of the postFormat. If present, this will be used to connect to the post. If no existing postFormat exists with this ID, no connection will be made."
    id: ID
    "The name of the postFormat. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field."
    name: String
    "The slug of the postFormat. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation."
    slug: String
}

"Set relationships between the post to tags"
input BlogPostTagsInput {
    "If true, this will append the tag to existing related tags. If false, this will replace existing relationships. Default true."
    append: Boolean
    nodes: [BlogPostTagsNodeInput]
}

"List of tags to connect the post to. If an ID is set, it will be used to create the connection. If not, it will look for a slug. If neither are valid existing terms, and the site is configured to allow terms to be created during post mutations, a term will be created using the Name if it exists in the input, then fallback to the slug if it exists."
input BlogPostTagsNodeInput {
    "The description of the tag. This field is used to set a description of the tag if a new one is created during the mutation."
    description: String
    "The ID of the tag. If present, this will be used to connect to the post. If no existing tag exists with this ID, no connection will be made."
    id: ID
    "The name of the tag. This field is used to create a new term, if term creation is enabled in nested mutations, and if one does not already exist with the provided slug or ID or if a slug or ID is not provided. If no name is included and a term is created, the creation will fallback to the slug field."
    name: String
    "The slug of the tag. If no ID is present, this field will be used to make a connection. If no existing term exists with this slug, this field will be used as a fallback to the Name field when creating a new term to connect to, if term creation is enabled as a nested mutation."
    slug: String
}

"Arguments for filtering the PostToCategoryConnection connection"
input BlogPostToCategoryConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Default false. If true, only the items connected to the source item will be returned. If false, all items will be returned regardless of connection to the source"
    shouldOnlyIncludeConnectedItems: Boolean
    "Default false. If true, the connection will be output in a flat list instead of the hierarchical list. So child terms will be output in the same level as the parent terms"
    shouldOutputInFlatList: Boolean
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the PostToCommentConnection connection"
input BlogPostToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    """

    Array of IDs of users whose unapproved comments will be returned by the
    query regardless of status.
    """
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    """

    Limit results to those affiliated with a given content object
    ID.
    """
    contentId: ID
    """

    Array of content object IDs to include affiliated comments
    for.
    """
    contentIdIn: [ID]
    """

    Array of content object IDs to exclude affiliated comments
    for.
    """
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    """

    Array of parent IDs of comments *not* to retrieve children
    for.
    """
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the PostToPostFormatConnection connection"
input BlogPostToPostFormatConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Default false. If true, only the items connected to the source item will be returned. If false, all items will be returned regardless of connection to the source"
    shouldOnlyIncludeConnectedItems: Boolean
    "Default false. If true, the connection will be output in a flat list instead of the hierarchical list. So child terms will be output in the same level as the parent terms"
    shouldOutputInFlatList: Boolean
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the postToRevisionConnection connection"
input BlogPostToRevisionConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Arguments for filtering the PostToTagConnection connection"
input BlogPostToTagConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Default false. If true, only the items connected to the source item will be returned. If false, all items will be returned regardless of connection to the source"
    shouldOnlyIncludeConnectedItems: Boolean
    "Default false. If true, the connection will be output in a flat list instead of the hierarchical list. So child terms will be output in the same level as the parent terms"
    shouldOutputInFlatList: Boolean
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Input for the registerUser mutation"
input BlogRegisterUserInput {
    "User's AOL IM account."
    aim: String
    clientMutationId: String!
    "A string containing content about the user."
    description: String
    "A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user)."
    displayName: String
    "A string containing the user's email address."
    email: String
    "\tThe user's first name."
    firstName: String
    "User's Jabber account."
    jabber: String
    "The user's last name."
    lastName: String
    "User's locale."
    locale: String
    "A string that contains a URL-friendly name for the user. The default is the user's username."
    nicename: String
    "The user's nickname, defaults to the user's username."
    nickname: String
    "A string that contains the plain text password for the user."
    password: String
    "The date the user registered. Format is Y-m-d H:i:s."
    registered: String
    "A string for whether to enable the rich editor or not. False if not empty."
    richEditing: String
    "A string that contains the user's username."
    username: String!
    "A string containing the user's URL for the user's web site."
    websiteUrl: String
    "User's Yahoo IM account."
    yim: String
}

"Input for the resetUserPassword mutation"
input BlogResetUserPasswordInput {
    clientMutationId: String!
    "Password reset key"
    key: String
    "The user's login (username)."
    login: String
    "The new password."
    password: String
}

"Input for the restoreComment mutation"
input BlogRestoreCommentInput {
    clientMutationId: String!
    "The ID of the comment to be restored"
    id: ID!
}

"Arguments for filtering the RootQueryToCategoryConnection connection"
input BlogRootQueryToCategoryConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Default false. If true, only the items connected to the source item will be returned. If false, all items will be returned regardless of connection to the source"
    shouldOnlyIncludeConnectedItems: Boolean
    "Default false. If true, the connection will be output in a flat list instead of the hierarchical list. So child terms will be output in the same level as the parent terms"
    shouldOutputInFlatList: Boolean
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the RootQueryToCommentConnection connection"
input BlogRootQueryToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    """

    Array of IDs of users whose unapproved comments will be returned by the
    query regardless of status.
    """
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    """

    Limit results to those affiliated with a given content object
    ID.
    """
    contentId: ID
    """

    Array of content object IDs to include affiliated comments
    for.
    """
    contentIdIn: [ID]
    """

    Array of content object IDs to exclude affiliated comments
    for.
    """
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    """

    Array of parent IDs of comments *not* to retrieve children
    for.
    """
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the RootQueryToContentNodeConnection connection"
input BlogRootQueryToContentNodeConnectionWhereArgs {
    "The Types of content to filter"
    contentTypes: [BlogContentTypeEnum]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the RootQueryToContentRevisionUnionConnection connection"
input BlogRootQueryToContentRevisionUnionConnectionWhereArgs {
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the RootQueryToMediaItemConnection connection"
input BlogRootQueryToMediaItemConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the RootQueryToMenuConnection connection"
input BlogRootQueryToMenuConnectionWhereArgs {
    "The ID of the object"
    id: Int
    "The menu location for the menu being queried"
    location: BlogMenuLocationEnum
    "The slug of the menu to query items for"
    slug: String
}

"Arguments for filtering the RootQueryToMenuItemConnection connection"
input BlogRootQueryToMenuItemConnectionWhereArgs {
    "The ID of the object"
    id: Int
    "The menu location for the menu being queried"
    location: BlogMenuLocationEnum
}

"Arguments for filtering the RootQueryToPageConnection connection"
input BlogRootQueryToPageConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the RootQueryToPostConnection connection"
input BlogRootQueryToPostConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Arguments for filtering the RootQueryToPostFormatConnection connection"
input BlogRootQueryToPostFormatConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Default false. If true, only the items connected to the source item will be returned. If false, all items will be returned regardless of connection to the source"
    shouldOnlyIncludeConnectedItems: Boolean
    "Default false. If true, the connection will be output in a flat list instead of the hierarchical list. So child terms will be output in the same level as the parent terms"
    shouldOutputInFlatList: Boolean
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the RootQueryToTagConnection connection"
input BlogRootQueryToTagConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Default false. If true, only the items connected to the source item will be returned. If false, all items will be returned regardless of connection to the source"
    shouldOnlyIncludeConnectedItems: Boolean
    "Default false. If true, the connection will be output in a flat list instead of the hierarchical list. So child terms will be output in the same level as the parent terms"
    shouldOutputInFlatList: Boolean
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the RootQueryToTermNodeConnection connection"
input BlogRootQueryToTermNodeConnectionWhereArgs {
    "Unique cache key to be produced when this query is stored in an object cache. Default is 'core'."
    cacheDomain: String
    "Term ID to retrieve child terms of. If multiple taxonomies are passed, $child_of is ignored. Default 0."
    childOf: Int
    "True to limit results to terms that have no children. This parameter has no effect on non-hierarchical taxonomies. Default false."
    childless: Boolean
    "Retrieve terms where the description is LIKE the input value. Default empty."
    descriptionLike: String
    "Array of term ids to exclude. If $include is non-empty, $exclude is ignored. Default empty array."
    exclude: [ID]
    "Array of term ids to exclude along with all of their descendant terms. If $include is non-empty, $exclude_tree is ignored. Default empty array."
    excludeTree: [ID]
    "Whether to hide terms not assigned to any posts. Accepts true or false. Default false"
    hideEmpty: Boolean
    "Whether to include terms that have non-empty descendants (even if $hide_empty is set to true). Default true."
    hierarchical: Boolean
    "Array of term ids to include. Default empty array."
    include: [ID]
    "Array of names to return term(s) for. Default empty."
    name: [String]
    "Retrieve terms where the name is LIKE the input value. Default empty."
    nameLike: String
    "Array of object IDs. Results will be limited to terms associated with these objects."
    objectIds: [ID]
    "Field(s) to order terms by. Defaults to 'name'."
    orderby: BlogTermObjectsConnectionOrderbyEnum
    "Whether to pad the quantity of a term's children in the quantity of each term's \"count\" object variable. Default false."
    padCounts: Boolean
    "Parent term ID to retrieve direct-child terms of. Default empty."
    parent: Int
    "Search criteria to match terms. Will be SQL-formatted with wildcards before and after. Default empty."
    search: String
    "Default false. If true, only the items connected to the source item will be returned. If false, all items will be returned regardless of connection to the source"
    shouldOnlyIncludeConnectedItems: Boolean
    "Default false. If true, the connection will be output in a flat list instead of the hierarchical list. So child terms will be output in the same level as the parent terms"
    shouldOutputInFlatList: Boolean
    "Array of slugs to return term(s) for. Default empty."
    slug: [String]
    "The Taxonomy to filter terms by"
    taxonomies: [BlogTaxonomyEnum]
    "Array of term taxonomy IDs, to match when querying terms."
    termTaxonomId: [ID]
    "Whether to prime meta caches for matched terms. Default true."
    updateTermMetaCache: Boolean
}

"Arguments for filtering the RootQueryToUserConnection connection"
input BlogRootQueryToUserConnectionWhereArgs {
    "Array of userIds to exclude."
    exclude: [Int]
    "Pass an array of post types to filter results to users who have published posts in those post types."
    hasPublishedPosts: [BlogContentTypeEnum]
    "Array of userIds to include."
    include: [Int]
    "The user login."
    login: String
    "An array of logins to include. Users matching one of these logins will be included in results."
    loginIn: Int
    "An array of logins to exclude. Users matching one of these logins will not be included in results."
    loginNotIn: Int
    "The user nicename."
    nicename: String
    "An array of nicenames to include. Users matching one of these nicenames will be included in results."
    nicenameIn: [String]
    "An array of nicenames to exclude. Users matching one of these nicenames will not be included in results."
    nicenameNotIn: [String]
    "What paramater to use to order the objects by."
    orderby: [BlogUsersConnectionOrderbyInput]
    "An array of role names that users must match to be included in results. Note that this is an inclusive list: users must match *each* role."
    role: BlogUserRoleEnum
    "An array of role names. Matched users must have at least one of these roles."
    roleIn: [BlogUserRoleEnum]
    "An array of role names to exclude. Users matching one or more of these roles will not be included in results."
    roleNotIn: [BlogUserRoleEnum]
    "Search keyword. Searches for possible string matches on columns. When \"searchColumns\" is left empty, it tries to determine which column to search in based on search string."
    search: String
    "Array of column names to be searched. Accepts 'ID', 'login', 'nicename', 'email', 'url'."
    searchColumns: [String]
}

"Input for the sendPasswordResetEmail mutation"
input BlogSendPasswordResetEmailInput {
    clientMutationId: String!
    "A string that contains the user's username or email address."
    username: String!
}

"Arguments for filtering the TagToPostConnection connection"
input BlogTagToPostConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Input for the UpdateCategory mutation"
input BlogUpdateCategoryInput {
    "The slug that the category will be an alias of"
    aliasOf: String
    clientMutationId: String!
    "The description of the category object"
    description: String
    "The ID of the category object to update"
    id: ID!
    "The name of the category object to mutate"
    name: String
    "The ID of the category that should be set as the parent"
    parentId: ID
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the updateComment mutation"
input BlogUpdateCommentInput {
    "User agent used to post the comment."
    agent: String
    "The approval status of the comment."
    approved: String
    "The name of the comment's author."
    author: String
    "The email of the comment's author."
    authorEmail: String
    "IP address for the comment's author."
    authorIp: String
    "The url of the comment's author."
    authorUrl: String
    clientMutationId: String!
    "The ID of the post object the comment belongs to."
    commentOn: Int
    "Content of the comment."
    content: String
    "The date of the object. Preferable to enter as year/month/day ( e.g. 01/31/2017 ) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "The ID of the comment being updated."
    id: ID!
    "Parent comment of current comment."
    parent: ID
    "Type of comment."
    type: String
    "The userID of the comment's author."
    userId: Int
}

"Input for the updateMediaItem mutation"
input BlogUpdateMediaItemInput {
    "Alternative text to display when mediaItem is not displayed"
    altText: String
    "The userId to assign as the author of the mediaItem"
    authorId: ID
    "The caption for the mediaItem"
    caption: String
    clientMutationId: String!
    "The comment status for the mediaItem"
    commentStatus: String
    "The date of the mediaItem"
    date: String
    "The date (in GMT zone) of the mediaItem"
    dateGmt: String
    "Description of the mediaItem"
    description: String
    "The file name of the mediaItem"
    filePath: String
    "The file type of the mediaItem"
    fileType: BlogMimeTypeEnum
    "The ID of the mediaItem object"
    id: ID!
    "The WordPress post ID or the graphQL postId of the parent object"
    parentId: ID
    "The ping status for the mediaItem"
    pingStatus: String
    "The slug of the mediaItem"
    slug: String
    "The status of the mediaItem"
    status: BlogMediaItemStatusEnum
    "The title of the mediaItem"
    title: String
}

"Input for the updatePage mutation"
input BlogUpdatePageInput {
    "The userId to assign as the author of the object"
    authorId: ID
    clientMutationId: String!
    "The comment status for the object"
    commentStatus: String
    "The content of the object"
    content: String
    "The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "The ID of the page object"
    id: ID!
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int
    "The ID of the parent object"
    parentId: ID
    "The password used to protect the content of the object"
    password: String
    "The slug of the object"
    slug: String
    "The title of the object"
    title: String
}

"Input for the UpdatePostFormat mutation"
input BlogUpdatePostFormatInput {
    "The slug that the post_format will be an alias of"
    aliasOf: String
    clientMutationId: String!
    "The description of the post_format object"
    description: String
    "The ID of the postFormat object to update"
    id: ID!
    "The name of the post_format object to mutate"
    name: String
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the updatePost mutation"
input BlogUpdatePostInput {
    "The userId to assign as the author of the object"
    authorId: ID
    "Set connections between the post and categories"
    categories: BlogPostCategoriesInput
    clientMutationId: String!
    "The comment status for the object"
    commentStatus: String
    "The content of the object"
    content: String
    "The date of the object. Preferable to enter as year/month/day (e.g. 01/31/2017) as it will rearrange date as fit if it is not specified. Incomplete dates may have unintended results for example, \"2017\" as the input will use current date with timestamp 20:17 "
    date: String
    "The excerpt of the object"
    excerpt: String
    "The ID of the post object"
    id: ID!
    "A field used for ordering posts. This is typically used with nav menu items or for special ordering of hierarchical content types."
    menuOrder: Int
    "The password used to protect the content of the object"
    password: String
    "The ping status for the object"
    pingStatus: String
    "URLs that have been pinged."
    pinged: [String]
    "Set connections between the post and postFormats"
    postFormats: BlogPostPostFormatsInput
    "The slug of the object"
    slug: String
    "Set connections between the post and tags"
    tags: BlogPostTagsInput
    "The title of the object"
    title: String
    "URLs queued to be pinged."
    toPing: [String]
}

"Input for the updateSettings mutation"
input BlogUpdateSettingsInput {
    clientMutationId: String!
    "Allow people to submit comments on new posts."
    discussionSettingsDefaultCommentStatus: String
    "Allow link notifications from other blogs (pingbacks and trackbacks) on new articles."
    discussionSettingsDefaultPingStatus: String
    "A date format for all date strings."
    generalSettingsDateFormat: String
    "Site tagline."
    generalSettingsDescription: String
    "This address is used for admin purposes, like new user notification."
    generalSettingsEmail: String
    "WordPress locale code."
    generalSettingsLanguage: String
    "A day number of the week that the week should start on."
    generalSettingsStartOfWeek: Int
    "A time format for all time strings."
    generalSettingsTimeFormat: String
    "A city in the same timezone as you."
    generalSettingsTimezone: String
    "Site title."
    generalSettingsTitle: String
    "Site URL."
    generalSettingsUrl: String
    "Blog pages show at most."
    readingSettingsPostsPerPage: Int
    "Default post category."
    writingSettingsDefaultCategory: Int
    "Default post format."
    writingSettingsDefaultPostFormat: String
    "Convert emoticons like :-) and :-P to graphics on display."
    writingSettingsUseSmilies: Boolean
}

"Input for the UpdateTag mutation"
input BlogUpdateTagInput {
    "The slug that the post_tag will be an alias of"
    aliasOf: String
    clientMutationId: String!
    "The description of the post_tag object"
    description: String
    "The ID of the tag object to update"
    id: ID!
    "The name of the post_tag object to mutate"
    name: String
    "If this argument exists then the slug will be checked to see if it is not an existing valid term. If that check succeeds (it is not a valid term), then it is added and the term id is given. If it fails, then a check is made to whether the taxonomy is hierarchical and the parent argument is not empty. If the second check succeeds, the term will be inserted and the term id will be given. If the slug argument is empty, then it will be calculated from the term name."
    slug: String
}

"Input for the updateUser mutation"
input BlogUpdateUserInput {
    "User's AOL IM account."
    aim: String
    clientMutationId: String!
    "A string containing content about the user."
    description: String
    "A string that will be shown on the site. Defaults to user's username. It is likely that you will want to change this, for both appearance and security through obscurity (that is if you dont use and delete the default admin user)."
    displayName: String
    "A string containing the user's email address."
    email: String
    "\tThe user's first name."
    firstName: String
    "The ID of the user"
    id: ID!
    "User's Jabber account."
    jabber: String
    "The user's last name."
    lastName: String
    "User's locale."
    locale: String
    "A string that contains a URL-friendly name for the user. The default is the user's username."
    nicename: String
    "The user's nickname, defaults to the user's username."
    nickname: String
    "A string that contains the plain text password for the user."
    password: String
    "The date the user registered. Format is Y-m-d H:i:s."
    registered: String
    "A string for whether to enable the rich editor or not. False if not empty."
    richEditing: String
    "An array of roles to be assigned to the user."
    roles: [String]
    "A string containing the user's URL for the user's web site."
    websiteUrl: String
    "User's Yahoo IM account."
    yim: String
}

"Arguments for filtering the UserToCommentConnection connection"
input BlogUserToCommentConnectionWhereArgs {
    "Comment author email address."
    authorEmail: String
    "Array of author IDs to include comments for."
    authorIn: [ID]
    "Array of author IDs to exclude comments for."
    authorNotIn: [ID]
    "Comment author URL."
    authorUrl: String
    "Array of comment IDs to include."
    commentIn: [ID]
    """

    Array of IDs of users whose unapproved comments will be returned by the
    query regardless of status.
    """
    commentNotIn: [ID]
    "Include comments of a given type."
    commentType: String
    "Include comments from a given array of comment types."
    commentTypeIn: [String]
    "Exclude comments from a given array of comment types."
    commentTypeNotIn: String
    "Content object author ID to limit results by."
    contentAuthor: [ID]
    "Array of author IDs to retrieve comments for."
    contentAuthorIn: [ID]
    "Array of author IDs *not* to retrieve comments for."
    contentAuthorNotIn: [ID]
    """

    Limit results to those affiliated with a given content object
    ID.
    """
    contentId: ID
    """

    Array of content object IDs to include affiliated comments
    for.
    """
    contentIdIn: [ID]
    """

    Array of content object IDs to exclude affiliated comments
    for.
    """
    contentIdNotIn: [ID]
    "Content object name to retrieve affiliated comments for."
    contentName: String
    "Content Object parent ID to retrieve affiliated comments for."
    contentParent: Int
    "Content object type or array of types to retrieve affiliated comments for. Pass 'any' to match any value."
    contentType: [BlogContentTypeEnum]
    "Array of IDs or email addresses of users whose unapproved comments will be returned by the query regardless of $status. Default empty"
    includeUnapproved: [ID]
    "Karma score to retrieve matching comments for."
    karma: Int
    "The cardinality of the order of the connection"
    order: BlogOrderEnum
    "Field to order the comments by."
    orderby: BlogCommentsConnectionOrderbyEnum
    "Parent ID of comment to retrieve children of."
    parent: Int
    "Array of parent IDs of comments to retrieve children for."
    parentIn: [ID]
    """

    Array of parent IDs of comments *not* to retrieve children
    for.
    """
    parentNotIn: [ID]
    "Search term(s) to retrieve matching comments for."
    search: String
    "Comment status to limit results by."
    status: String
    "Include comments for a specific user ID."
    userId: ID
}

"Arguments for filtering the UserToContentRevisionUnionConnection connection"
input BlogUserToContentRevisionUnionConnectionWhereArgs {
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the UserToMediaItemConnection connection"
input BlogUserToMediaItemConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the UserToPageConnection connection"
input BlogUserToPageConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Title of the object"
    title: String
}

"Arguments for filtering the UserToPostConnection connection"
input BlogUserToPostConnectionWhereArgs {
    "The user that's connected as the author of the object. Use the userId for the author object."
    author: Int
    "Find objects connected to author(s) in the array of author's userIds"
    authorIn: [ID]
    "Find objects connected to the author by the author's nicename"
    authorName: String
    "Find objects NOT connected to author(s) in the array of author's userIds"
    authorNotIn: [ID]
    "Category ID"
    categoryId: Int
    "Array of category IDs, used to display objects from one category OR another"
    categoryIn: [ID]
    "Use Category Slug"
    categoryName: String
    "Array of category IDs, used to display objects from one category OR another"
    categoryNotIn: [ID]
    "Filter the connection based on dates"
    dateQuery: BlogDateQueryInput
    "True for objects with passwords; False for objects without passwords; null for all objects with or without passwords"
    hasPassword: Boolean
    "Specific ID of the object"
    id: Int
    "Array of IDs for the objects to retrieve"
    in: [ID]
    "Get objects with a specific mimeType property"
    mimeType: BlogMimeTypeEnum
    "Slug / post_name of the object"
    name: String
    "Specify objects to retrieve. Use slugs"
    nameIn: [String]
    "Specify IDs NOT to retrieve. If this is used in the same query as \"in\", it will be ignored"
    notIn: [ID]
    "What paramater to use to order the objects by."
    orderby: [BlogPostObjectsConnectionOrderbyInput]
    "Use ID to return only children. Use 0 to return only top-level items"
    parent: String
    "Specify objects whose parent is in an array"
    parentIn: [ID]
    "Specify posts whose parent is not in an array"
    parentNotIn: [ID]
    "Show posts with a specific password."
    password: String
    "Show Posts based on a keyword search"
    search: String
    "Tag Slug"
    tag: String
    "Use Tag ID"
    tagId: String
    "Array of tag IDs, used to display objects from one tag OR another"
    tagIn: [ID]
    "Array of tag IDs, used to display objects from one tag OR another"
    tagNotIn: [ID]
    "Array of tag slugs, used to display objects from one tag OR another"
    tagSlugAnd: [String]
    "Array of tag slugs, used to exclude objects in specified tags"
    tagSlugIn: [String]
    "Title of the object"
    title: String
}

"Options for ordering the connection"
input BlogUsersConnectionOrderbyInput {
    field: BlogUsersConnectionOrderbyEnum!
    order: BlogOrderEnum
}

input ClearBoolFieldUpdateOperationsInput {
    set: Boolean
}

input ClearBoolFilter {
    equals: Boolean
    not: ClearNestedBoolFilter
}

input ClearBoolWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedBoolFilter
    _min: ClearNestedBoolFilter
    equals: Boolean
    not: ClearNestedBoolWithAggregatesFilter
}

input ClearDateTimeFieldUpdateOperationsInput {
    set: ClearDateTime
}

input ClearDateTimeFilter {
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeFilter
    notIn: [ClearDateTime!]
}

input ClearDateTimeNullableFilter {
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeNullableFilter
    notIn: [ClearDateTime!]
}

input ClearDateTimeNullableWithAggregatesFilter {
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedDateTimeNullableFilter
    _min: ClearNestedDateTimeNullableFilter
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeNullableWithAggregatesFilter
    notIn: [ClearDateTime!]
}

input ClearDateTimeWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedDateTimeFilter
    _min: ClearNestedDateTimeFilter
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeWithAggregatesFilter
    notIn: [ClearDateTime!]
}

input ClearEnumTicketTypeFieldUpdateOperationsInput {
    set: ClearTicketType
}

input ClearEnumTicketTypeFilter {
    equals: ClearTicketType
    in: [ClearTicketType!]
    not: ClearNestedEnumTicketTypeFilter
    notIn: [ClearTicketType!]
}

input ClearEnumTicketTypeWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedEnumTicketTypeFilter
    _min: ClearNestedEnumTicketTypeFilter
    equals: ClearTicketType
    in: [ClearTicketType!]
    not: ClearNestedEnumTicketTypeWithAggregatesFilter
    notIn: [ClearTicketType!]
}

input ClearEventAvgOrderByAggregateInput {
    earlyBirdPrice: ClearSortOrder
    ticketPrice: ClearSortOrder
}

input ClearEventCountOrderByAggregateInput {
    contentfulWebname: ClearSortOrder
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    eventGroupId: ClearSortOrder
    id: ClearSortOrder
    managers: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    registrationsOpen: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
    venueId: ClearSortOrder
}

input ClearEventCreateInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    id: String
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateManyEventGroupInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    id: String
    managers: ClearEventCreateManymanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
    venueId: String
}

input ClearEventCreateManyEventGroupInputEnvelope {
    data: [ClearEventCreateManyEventGroupInput!]!
    skipDuplicates: Boolean
}

input ClearEventCreateManyInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroupId: String!
    id: String
    managers: ClearEventCreateManymanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
    venueId: String
}

input ClearEventCreateManyVenueInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroupId: String!
    id: String
    managers: ClearEventCreateManymanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
}

input ClearEventCreateManyVenueInputEnvelope {
    data: [ClearEventCreateManyVenueInput!]!
    skipDuplicates: Boolean
}

input ClearEventCreateManymanagersInput {
    set: [String!]!
}

input ClearEventCreateNestedManyWithoutEventGroupInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutEventGroupInput!]
    create: [ClearEventCreateWithoutEventGroupInput!]
    createMany: ClearEventCreateManyEventGroupInputEnvelope
}

input ClearEventCreateNestedManyWithoutVenueInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutVenueInput!]
    create: [ClearEventCreateWithoutVenueInput!]
    createMany: ClearEventCreateManyVenueInputEnvelope
}

input ClearEventCreateNestedOneWithoutScheduleInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutScheduleInput
    create: ClearEventCreateWithoutScheduleInput
}

input ClearEventCreateNestedOneWithoutSponsorsInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutSponsorsInput
    create: ClearEventCreateWithoutSponsorsInput
}

input ClearEventCreateNestedOneWithoutTicketsInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutTicketsInput
    create: ClearEventCreateWithoutTicketsInput
}

input ClearEventCreateOrConnectWithoutEventGroupInput {
    create: ClearEventCreateWithoutEventGroupInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateOrConnectWithoutScheduleInput {
    create: ClearEventCreateWithoutScheduleInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateOrConnectWithoutSponsorsInput {
    create: ClearEventCreateWithoutSponsorsInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateOrConnectWithoutTicketsInput {
    create: ClearEventCreateWithoutTicketsInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateOrConnectWithoutVenueInput {
    create: ClearEventCreateWithoutVenueInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventCreateWithoutEventGroupInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    id: String
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateWithoutScheduleInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    id: String
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateWithoutSponsorsInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    id: String
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateWithoutTicketsInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    id: String
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
    venue: ClearVenueCreateNestedOneWithoutEventsInput
}

input ClearEventCreateWithoutVenueInput {
    contentfulWebname: String
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    eventGroup: ClearEventGroupCreateNestedOneWithoutEventsInput!
    id: String
    managers: ClearEventCreatemanagersInput
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    registrationsOpen: Boolean
    schedule: ClearScheduleItemCreateNestedManyWithoutEventInput
    sponsors: ClearSponsorCreateNestedManyWithoutEventInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    tickets: ClearTicketCreateNestedManyWithoutEventInput
    updatedAt: ClearDateTime
}

input ClearEventCreatemanagersInput {
    set: [String!]!
}

input ClearEventGroupAvgOrderByAggregateInput {
    earlyBirdPrice: ClearSortOrder
    ticketPrice: ClearSortOrder
}

input ClearEventGroupCountOrderByAggregateInput {
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventGroupCreateInput {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    events: ClearEventCreateNestedManyWithoutEventGroupInput
    id: String
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    schedule: ClearScheduleItemCreateNestedManyWithoutEventGroupInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
}

input ClearEventGroupCreateManyInput {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    id: String
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
}

input ClearEventGroupCreateNestedOneWithoutEventsInput {
    connect: ClearEventGroupWhereUniqueInput
    connectOrCreate: ClearEventGroupCreateOrConnectWithoutEventsInput
    create: ClearEventGroupCreateWithoutEventsInput
}

input ClearEventGroupCreateNestedOneWithoutScheduleInput {
    connect: ClearEventGroupWhereUniqueInput
    connectOrCreate: ClearEventGroupCreateOrConnectWithoutScheduleInput
    create: ClearEventGroupCreateWithoutScheduleInput
}

input ClearEventGroupCreateOrConnectWithoutEventsInput {
    create: ClearEventGroupCreateWithoutEventsInput!
    where: ClearEventGroupWhereUniqueInput!
}

input ClearEventGroupCreateOrConnectWithoutScheduleInput {
    create: ClearEventGroupCreateWithoutScheduleInput!
    where: ClearEventGroupWhereUniqueInput!
}

input ClearEventGroupCreateWithoutEventsInput {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    id: String
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    schedule: ClearScheduleItemCreateNestedManyWithoutEventGroupInput
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
}

input ClearEventGroupCreateWithoutScheduleInput {
    createdAt: ClearDateTime
    earlyBirdCutoff: ClearDateTime!
    earlyBirdPrice: Float!
    endDate: ClearDateTime!
    events: ClearEventCreateNestedManyWithoutEventGroupInput
    id: String
    metadata: ClearJSON
    name: String!
    registrationCutoff: ClearDateTime!
    startDate: ClearDateTime!
    ticketPrice: Float!
    updatedAt: ClearDateTime
}

input ClearEventGroupMaxOrderByAggregateInput {
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    id: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventGroupMinOrderByAggregateInput {
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    id: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventGroupOrderByWithAggregationInput {
    _avg: ClearEventGroupAvgOrderByAggregateInput
    _count: ClearEventGroupCountOrderByAggregateInput
    _max: ClearEventGroupMaxOrderByAggregateInput
    _min: ClearEventGroupMinOrderByAggregateInput
    _sum: ClearEventGroupSumOrderByAggregateInput
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventGroupOrderByWithRelationInput {
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    events: ClearEventOrderByRelationAggregateInput
    id: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    schedule: ClearScheduleItemOrderByRelationAggregateInput
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearEventGroupRelationFilter {
    is: ClearEventGroupWhereInput
    isNot: ClearEventGroupWhereInput
}

input ClearEventGroupScalarWhereWithAggregatesInput {
    AND: [ClearEventGroupScalarWhereWithAggregatesInput!]
    NOT: [ClearEventGroupScalarWhereWithAggregatesInput!]
    OR: [ClearEventGroupScalarWhereWithAggregatesInput!]
    createdAt: ClearDateTimeWithAggregatesFilter
    earlyBirdCutoff: ClearDateTimeWithAggregatesFilter
    earlyBirdPrice: ClearFloatWithAggregatesFilter
    endDate: ClearDateTimeWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringWithAggregatesFilter
    registrationCutoff: ClearDateTimeWithAggregatesFilter
    startDate: ClearDateTimeWithAggregatesFilter
    ticketPrice: ClearFloatWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearEventGroupSumOrderByAggregateInput {
    earlyBirdPrice: ClearSortOrder
    ticketPrice: ClearSortOrder
}

input ClearEventGroupUpdateInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    events: ClearEventUpdateManyWithoutEventGroupInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventGroupInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventGroupUpdateManyMutationInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventGroupUpdateOneRequiredWithoutEventsInput {
    connect: ClearEventGroupWhereUniqueInput
    connectOrCreate: ClearEventGroupCreateOrConnectWithoutEventsInput
    create: ClearEventGroupCreateWithoutEventsInput
    update: ClearEventGroupUpdateWithoutEventsInput
    upsert: ClearEventGroupUpsertWithoutEventsInput
}

input ClearEventGroupUpdateOneWithoutScheduleInput {
    connect: ClearEventGroupWhereUniqueInput
    connectOrCreate: ClearEventGroupCreateOrConnectWithoutScheduleInput
    create: ClearEventGroupCreateWithoutScheduleInput
    delete: Boolean
    disconnect: Boolean
    update: ClearEventGroupUpdateWithoutScheduleInput
    upsert: ClearEventGroupUpsertWithoutScheduleInput
}

input ClearEventGroupUpdateWithoutEventsInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventGroupInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventGroupUpdateWithoutScheduleInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    events: ClearEventUpdateManyWithoutEventGroupInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventGroupUpsertWithoutEventsInput {
    create: ClearEventGroupCreateWithoutEventsInput!
    update: ClearEventGroupUpdateWithoutEventsInput!
}

input ClearEventGroupUpsertWithoutScheduleInput {
    create: ClearEventGroupCreateWithoutScheduleInput!
    update: ClearEventGroupUpdateWithoutScheduleInput!
}

input ClearEventGroupWhereInput {
    AND: [ClearEventGroupWhereInput!]
    NOT: [ClearEventGroupWhereInput!]
    OR: [ClearEventGroupWhereInput!]
    createdAt: ClearDateTimeFilter
    earlyBirdCutoff: ClearDateTimeFilter
    earlyBirdPrice: ClearFloatFilter
    endDate: ClearDateTimeFilter
    events: ClearEventListRelationFilter
    id: ClearStringFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    registrationCutoff: ClearDateTimeFilter
    schedule: ClearScheduleItemListRelationFilter
    startDate: ClearDateTimeFilter
    ticketPrice: ClearFloatFilter
    updatedAt: ClearDateTimeFilter
}

input ClearEventGroupWhereUniqueInput {
    id: String
}

input ClearEventListRelationFilter {
    every: ClearEventWhereInput
    none: ClearEventWhereInput
    some: ClearEventWhereInput
}

input ClearEventMaxOrderByAggregateInput {
    contentfulWebname: ClearSortOrder
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    eventGroupId: ClearSortOrder
    id: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    registrationsOpen: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
    venueId: ClearSortOrder
}

input ClearEventMinOrderByAggregateInput {
    contentfulWebname: ClearSortOrder
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    eventGroupId: ClearSortOrder
    id: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    registrationsOpen: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
    venueId: ClearSortOrder
}

input ClearEventOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearEventOrderByWithAggregationInput {
    _avg: ClearEventAvgOrderByAggregateInput
    _count: ClearEventCountOrderByAggregateInput
    _max: ClearEventMaxOrderByAggregateInput
    _min: ClearEventMinOrderByAggregateInput
    _sum: ClearEventSumOrderByAggregateInput
    contentfulWebname: ClearSortOrder
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    eventGroupId: ClearSortOrder
    id: ClearSortOrder
    managers: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    registrationsOpen: ClearSortOrder
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    updatedAt: ClearSortOrder
    venueId: ClearSortOrder
}

input ClearEventOrderByWithRelationInput {
    contentfulWebname: ClearSortOrder
    createdAt: ClearSortOrder
    earlyBirdCutoff: ClearSortOrder
    earlyBirdPrice: ClearSortOrder
    endDate: ClearSortOrder
    eventGroup: ClearEventGroupOrderByWithRelationInput
    eventGroupId: ClearSortOrder
    id: ClearSortOrder
    managers: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    registrationCutoff: ClearSortOrder
    registrationsOpen: ClearSortOrder
    schedule: ClearScheduleItemOrderByRelationAggregateInput
    sponsors: ClearSponsorOrderByRelationAggregateInput
    startDate: ClearSortOrder
    ticketPrice: ClearSortOrder
    tickets: ClearTicketOrderByRelationAggregateInput
    updatedAt: ClearSortOrder
    venue: ClearVenueOrderByWithRelationInput
    venueId: ClearSortOrder
}

input ClearEventRelationFilter {
    is: ClearEventWhereInput
    isNot: ClearEventWhereInput
}

input ClearEventScalarWhereInput {
    AND: [ClearEventScalarWhereInput!]
    NOT: [ClearEventScalarWhereInput!]
    OR: [ClearEventScalarWhereInput!]
    contentfulWebname: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    earlyBirdCutoff: ClearDateTimeFilter
    earlyBirdPrice: ClearFloatFilter
    endDate: ClearDateTimeFilter
    eventGroupId: ClearStringFilter
    id: ClearStringFilter
    managers: ClearStringNullableListFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    registrationCutoff: ClearDateTimeFilter
    registrationsOpen: ClearBoolFilter
    startDate: ClearDateTimeFilter
    ticketPrice: ClearFloatFilter
    updatedAt: ClearDateTimeFilter
    venueId: ClearStringNullableFilter
}

input ClearEventScalarWhereWithAggregatesInput {
    AND: [ClearEventScalarWhereWithAggregatesInput!]
    NOT: [ClearEventScalarWhereWithAggregatesInput!]
    OR: [ClearEventScalarWhereWithAggregatesInput!]
    contentfulWebname: ClearStringNullableWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    earlyBirdCutoff: ClearDateTimeWithAggregatesFilter
    earlyBirdPrice: ClearFloatWithAggregatesFilter
    endDate: ClearDateTimeWithAggregatesFilter
    eventGroupId: ClearStringWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    managers: ClearStringNullableListFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringWithAggregatesFilter
    registrationCutoff: ClearDateTimeWithAggregatesFilter
    registrationsOpen: ClearBoolWithAggregatesFilter
    startDate: ClearDateTimeWithAggregatesFilter
    ticketPrice: ClearFloatWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
    venueId: ClearStringNullableWithAggregatesFilter
}

input ClearEventSumOrderByAggregateInput {
    earlyBirdPrice: ClearSortOrder
    ticketPrice: ClearSortOrder
}

input ClearEventUpdateInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateManyMutationInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventUpdateManyWithWhereWithoutEventGroupInput {
    data: ClearEventUpdateManyMutationInput!
    where: ClearEventScalarWhereInput!
}

input ClearEventUpdateManyWithWhereWithoutVenueInput {
    data: ClearEventUpdateManyMutationInput!
    where: ClearEventScalarWhereInput!
}

input ClearEventUpdateManyWithoutEventGroupInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutEventGroupInput!]
    create: [ClearEventCreateWithoutEventGroupInput!]
    createMany: ClearEventCreateManyEventGroupInputEnvelope
    delete: [ClearEventWhereUniqueInput!]
    deleteMany: [ClearEventScalarWhereInput!]
    disconnect: [ClearEventWhereUniqueInput!]
    set: [ClearEventWhereUniqueInput!]
    update: [ClearEventUpdateWithWhereUniqueWithoutEventGroupInput!]
    updateMany: [ClearEventUpdateManyWithWhereWithoutEventGroupInput!]
    upsert: [ClearEventUpsertWithWhereUniqueWithoutEventGroupInput!]
}

input ClearEventUpdateManyWithoutVenueInput {
    connect: [ClearEventWhereUniqueInput!]
    connectOrCreate: [ClearEventCreateOrConnectWithoutVenueInput!]
    create: [ClearEventCreateWithoutVenueInput!]
    createMany: ClearEventCreateManyVenueInputEnvelope
    delete: [ClearEventWhereUniqueInput!]
    deleteMany: [ClearEventScalarWhereInput!]
    disconnect: [ClearEventWhereUniqueInput!]
    set: [ClearEventWhereUniqueInput!]
    update: [ClearEventUpdateWithWhereUniqueWithoutVenueInput!]
    updateMany: [ClearEventUpdateManyWithWhereWithoutVenueInput!]
    upsert: [ClearEventUpsertWithWhereUniqueWithoutVenueInput!]
}

input ClearEventUpdateOneRequiredWithoutTicketsInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutTicketsInput
    create: ClearEventCreateWithoutTicketsInput
    update: ClearEventUpdateWithoutTicketsInput
    upsert: ClearEventUpsertWithoutTicketsInput
}

input ClearEventUpdateOneWithoutScheduleInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutScheduleInput
    create: ClearEventCreateWithoutScheduleInput
    delete: Boolean
    disconnect: Boolean
    update: ClearEventUpdateWithoutScheduleInput
    upsert: ClearEventUpsertWithoutScheduleInput
}

input ClearEventUpdateOneWithoutSponsorsInput {
    connect: ClearEventWhereUniqueInput
    connectOrCreate: ClearEventCreateOrConnectWithoutSponsorsInput
    create: ClearEventCreateWithoutSponsorsInput
    delete: Boolean
    disconnect: Boolean
    update: ClearEventUpdateWithoutSponsorsInput
    upsert: ClearEventUpsertWithoutSponsorsInput
}

input ClearEventUpdateWithWhereUniqueWithoutEventGroupInput {
    data: ClearEventUpdateWithoutEventGroupInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpdateWithWhereUniqueWithoutVenueInput {
    data: ClearEventUpdateWithoutVenueInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpdateWithoutEventGroupInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateWithoutScheduleInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateWithoutSponsorsInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateWithoutTicketsInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    venue: ClearVenueUpdateOneWithoutEventsInput
}

input ClearEventUpdateWithoutVenueInput {
    contentfulWebname: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: ClearDateTimeFieldUpdateOperationsInput
    earlyBirdPrice: ClearFloatFieldUpdateOperationsInput
    endDate: ClearDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneRequiredWithoutEventsInput
    id: ClearStringFieldUpdateOperationsInput
    managers: ClearEventUpdatemanagersInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    registrationCutoff: ClearDateTimeFieldUpdateOperationsInput
    registrationsOpen: ClearBoolFieldUpdateOperationsInput
    schedule: ClearScheduleItemUpdateManyWithoutEventInput
    sponsors: ClearSponsorUpdateManyWithoutEventInput
    startDate: ClearDateTimeFieldUpdateOperationsInput
    ticketPrice: ClearFloatFieldUpdateOperationsInput
    tickets: ClearTicketUpdateManyWithoutEventInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearEventUpdatemanagersInput {
    push: [String!]
    set: [String!]
}

input ClearEventUpsertWithWhereUniqueWithoutEventGroupInput {
    create: ClearEventCreateWithoutEventGroupInput!
    update: ClearEventUpdateWithoutEventGroupInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpsertWithWhereUniqueWithoutVenueInput {
    create: ClearEventCreateWithoutVenueInput!
    update: ClearEventUpdateWithoutVenueInput!
    where: ClearEventWhereUniqueInput!
}

input ClearEventUpsertWithoutScheduleInput {
    create: ClearEventCreateWithoutScheduleInput!
    update: ClearEventUpdateWithoutScheduleInput!
}

input ClearEventUpsertWithoutSponsorsInput {
    create: ClearEventCreateWithoutSponsorsInput!
    update: ClearEventUpdateWithoutSponsorsInput!
}

input ClearEventUpsertWithoutTicketsInput {
    create: ClearEventCreateWithoutTicketsInput!
    update: ClearEventUpdateWithoutTicketsInput!
}

input ClearEventWhereInput {
    AND: [ClearEventWhereInput!]
    NOT: [ClearEventWhereInput!]
    OR: [ClearEventWhereInput!]
    contentfulWebname: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    earlyBirdCutoff: ClearDateTimeFilter
    earlyBirdPrice: ClearFloatFilter
    endDate: ClearDateTimeFilter
    eventGroup: ClearEventGroupRelationFilter
    eventGroupId: ClearStringFilter
    id: ClearStringFilter
    managers: ClearStringNullableListFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    registrationCutoff: ClearDateTimeFilter
    registrationsOpen: ClearBoolFilter
    schedule: ClearScheduleItemListRelationFilter
    sponsors: ClearSponsorListRelationFilter
    startDate: ClearDateTimeFilter
    ticketPrice: ClearFloatFilter
    tickets: ClearTicketListRelationFilter
    updatedAt: ClearDateTimeFilter
    venue: ClearVenueRelationFilter
    venueId: ClearStringNullableFilter
}

input ClearEventWhereUniqueInput {
    id: String
}

input ClearFloatFieldUpdateOperationsInput {
    decrement: Float
    divide: Float
    increment: Float
    multiply: Float
    set: Float
}

input ClearFloatFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: ClearNestedFloatFilter
    notIn: [Float!]
}

input ClearFloatWithAggregatesFilter {
    _avg: ClearNestedFloatFilter
    _count: ClearNestedIntFilter
    _max: ClearNestedFloatFilter
    _min: ClearNestedFloatFilter
    _sum: ClearNestedFloatFilter
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: ClearNestedFloatWithAggregatesFilter
    notIn: [Float!]
}

input ClearIntFieldUpdateOperationsInput {
    decrement: Int
    divide: Int
    increment: Int
    multiply: Int
    set: Int
}

input ClearIntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntFilter
    notIn: [Int!]
}

input ClearIntNullableFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntNullableFilter
    notIn: [Int!]
}

input ClearIntNullableWithAggregatesFilter {
    _avg: ClearNestedFloatNullableFilter
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedIntNullableFilter
    _min: ClearNestedIntNullableFilter
    _sum: ClearNestedIntNullableFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntNullableWithAggregatesFilter
    notIn: [Int!]
}

input ClearIntWithAggregatesFilter {
    _avg: ClearNestedFloatFilter
    _count: ClearNestedIntFilter
    _max: ClearNestedIntFilter
    _min: ClearNestedIntFilter
    _sum: ClearNestedIntFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntWithAggregatesFilter
    notIn: [Int!]
}

input ClearJsonNullableFilter {
    equals: ClearJSON
    not: ClearJSON
}

input ClearJsonNullableWithAggregatesFilter {
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedJsonNullableFilter
    _min: ClearNestedJsonNullableFilter
    equals: ClearJSON
    not: ClearJSON
}

input ClearNestedBoolFilter {
    equals: Boolean
    not: ClearNestedBoolFilter
}

input ClearNestedBoolWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedBoolFilter
    _min: ClearNestedBoolFilter
    equals: Boolean
    not: ClearNestedBoolWithAggregatesFilter
}

input ClearNestedDateTimeFilter {
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeFilter
    notIn: [ClearDateTime!]
}

input ClearNestedDateTimeNullableFilter {
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeNullableFilter
    notIn: [ClearDateTime!]
}

input ClearNestedDateTimeNullableWithAggregatesFilter {
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedDateTimeNullableFilter
    _min: ClearNestedDateTimeNullableFilter
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeNullableWithAggregatesFilter
    notIn: [ClearDateTime!]
}

input ClearNestedDateTimeWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedDateTimeFilter
    _min: ClearNestedDateTimeFilter
    equals: ClearDateTime
    gt: ClearDateTime
    gte: ClearDateTime
    in: [ClearDateTime!]
    lt: ClearDateTime
    lte: ClearDateTime
    not: ClearNestedDateTimeWithAggregatesFilter
    notIn: [ClearDateTime!]
}

input ClearNestedEnumTicketTypeFilter {
    equals: ClearTicketType
    in: [ClearTicketType!]
    not: ClearNestedEnumTicketTypeFilter
    notIn: [ClearTicketType!]
}

input ClearNestedEnumTicketTypeWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedEnumTicketTypeFilter
    _min: ClearNestedEnumTicketTypeFilter
    equals: ClearTicketType
    in: [ClearTicketType!]
    not: ClearNestedEnumTicketTypeWithAggregatesFilter
    notIn: [ClearTicketType!]
}

input ClearNestedFloatFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: ClearNestedFloatFilter
    notIn: [Float!]
}

input ClearNestedFloatNullableFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: ClearNestedFloatNullableFilter
    notIn: [Float!]
}

input ClearNestedFloatWithAggregatesFilter {
    _avg: ClearNestedFloatFilter
    _count: ClearNestedIntFilter
    _max: ClearNestedFloatFilter
    _min: ClearNestedFloatFilter
    _sum: ClearNestedFloatFilter
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: ClearNestedFloatWithAggregatesFilter
    notIn: [Float!]
}

input ClearNestedIntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntFilter
    notIn: [Int!]
}

input ClearNestedIntNullableFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntNullableFilter
    notIn: [Int!]
}

input ClearNestedIntNullableWithAggregatesFilter {
    _avg: ClearNestedFloatNullableFilter
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedIntNullableFilter
    _min: ClearNestedIntNullableFilter
    _sum: ClearNestedIntNullableFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntNullableWithAggregatesFilter
    notIn: [Int!]
}

input ClearNestedIntWithAggregatesFilter {
    _avg: ClearNestedFloatFilter
    _count: ClearNestedIntFilter
    _max: ClearNestedIntFilter
    _min: ClearNestedIntFilter
    _sum: ClearNestedIntFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: ClearNestedIntWithAggregatesFilter
    notIn: [Int!]
}

input ClearNestedJsonNullableFilter {
    equals: ClearJSON
    not: ClearJSON
}

input ClearNestedStringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: ClearNestedStringFilter
    notIn: [String!]
    startsWith: String
}

input ClearNestedStringNullableFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: ClearNestedStringNullableFilter
    notIn: [String!]
    startsWith: String
}

input ClearNestedStringNullableWithAggregatesFilter {
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedStringNullableFilter
    _min: ClearNestedStringNullableFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: ClearNestedStringNullableWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input ClearNestedStringWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedStringFilter
    _min: ClearNestedStringFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: ClearNestedStringWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input ClearNullableDateTimeFieldUpdateOperationsInput {
    set: ClearDateTime
}

input ClearNullableIntFieldUpdateOperationsInput {
    decrement: Int
    divide: Int
    increment: Int
    multiply: Int
    set: Int
}

input ClearNullableStringFieldUpdateOperationsInput {
    set: String
}

input ClearPaymentAvgOrderByAggregateInput {
    total: ClearSortOrder
}

input ClearPaymentCountOrderByAggregateInput {
    createdAt: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    total: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearPaymentCreateInput {
    Ticket: ClearTicketCreateNestedManyWithoutPaymentInput
    createdAt: ClearDateTime
    id: String
    metadata: ClearJSON
    total: Float!
    updatedAt: ClearDateTime
}

input ClearPaymentCreateManyInput {
    createdAt: ClearDateTime
    id: String
    metadata: ClearJSON
    total: Float!
    updatedAt: ClearDateTime
}

input ClearPaymentCreateNestedOneWithoutTicketInput {
    connect: ClearPaymentWhereUniqueInput
    connectOrCreate: ClearPaymentCreateOrConnectWithoutTicketInput
    create: ClearPaymentCreateWithoutTicketInput
}

input ClearPaymentCreateOrConnectWithoutTicketInput {
    create: ClearPaymentCreateWithoutTicketInput!
    where: ClearPaymentWhereUniqueInput!
}

input ClearPaymentCreateWithoutTicketInput {
    createdAt: ClearDateTime
    id: String
    metadata: ClearJSON
    total: Float!
    updatedAt: ClearDateTime
}

input ClearPaymentMaxOrderByAggregateInput {
    createdAt: ClearSortOrder
    id: ClearSortOrder
    total: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearPaymentMinOrderByAggregateInput {
    createdAt: ClearSortOrder
    id: ClearSortOrder
    total: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearPaymentOrderByWithAggregationInput {
    _avg: ClearPaymentAvgOrderByAggregateInput
    _count: ClearPaymentCountOrderByAggregateInput
    _max: ClearPaymentMaxOrderByAggregateInput
    _min: ClearPaymentMinOrderByAggregateInput
    _sum: ClearPaymentSumOrderByAggregateInput
    createdAt: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    total: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearPaymentOrderByWithRelationInput {
    Ticket: ClearTicketOrderByRelationAggregateInput
    createdAt: ClearSortOrder
    id: ClearSortOrder
    metadata: ClearSortOrder
    total: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearPaymentRelationFilter {
    is: ClearPaymentWhereInput
    isNot: ClearPaymentWhereInput
}

input ClearPaymentScalarWhereWithAggregatesInput {
    AND: [ClearPaymentScalarWhereWithAggregatesInput!]
    NOT: [ClearPaymentScalarWhereWithAggregatesInput!]
    OR: [ClearPaymentScalarWhereWithAggregatesInput!]
    createdAt: ClearDateTimeWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    total: ClearFloatWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearPaymentSumOrderByAggregateInput {
    total: ClearSortOrder
}

input ClearPaymentUpdateInput {
    Ticket: ClearTicketUpdateManyWithoutPaymentInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    total: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearPaymentUpdateManyMutationInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    total: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearPaymentUpdateOneWithoutTicketInput {
    connect: ClearPaymentWhereUniqueInput
    connectOrCreate: ClearPaymentCreateOrConnectWithoutTicketInput
    create: ClearPaymentCreateWithoutTicketInput
    delete: Boolean
    disconnect: Boolean
    update: ClearPaymentUpdateWithoutTicketInput
    upsert: ClearPaymentUpsertWithoutTicketInput
}

input ClearPaymentUpdateWithoutTicketInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    total: ClearFloatFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearPaymentUpsertWithoutTicketInput {
    create: ClearPaymentCreateWithoutTicketInput!
    update: ClearPaymentUpdateWithoutTicketInput!
}

input ClearPaymentWhereInput {
    AND: [ClearPaymentWhereInput!]
    NOT: [ClearPaymentWhereInput!]
    OR: [ClearPaymentWhereInput!]
    Ticket: ClearTicketListRelationFilter
    createdAt: ClearDateTimeFilter
    id: ClearStringFilter
    metadata: ClearJsonNullableFilter
    total: ClearFloatFilter
    updatedAt: ClearDateTimeFilter
}

input ClearPaymentWhereUniqueInput {
    id: String
}

input ClearPersonAvgOrderByAggregateInput {
    age: ClearSortOrder
}

input ClearPersonCountOrderByAggregateInput {
    age: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    phone: ClearSortOrder
    pronouns: ClearSortOrder
    updatedAt: ClearSortOrder
    username: ClearSortOrder
}

input ClearPersonCreateInput {
    Ticket: ClearTicketCreateNestedManyWithoutGuardianInput
    age: Int
    createdAt: ClearDateTime
    email: String
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    phone: String
    pronouns: String
    updatedAt: ClearDateTime
    username: String
}

input ClearPersonCreateManyInput {
    age: Int
    createdAt: ClearDateTime
    email: String
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    phone: String
    pronouns: String
    updatedAt: ClearDateTime
    username: String
}

input ClearPersonCreateNestedOneWithoutTicketInput {
    connect: ClearPersonWhereUniqueInput
    connectOrCreate: ClearPersonCreateOrConnectWithoutTicketInput
    create: ClearPersonCreateWithoutTicketInput
}

input ClearPersonCreateOrConnectWithoutTicketInput {
    create: ClearPersonCreateWithoutTicketInput!
    where: ClearPersonWhereUniqueInput!
}

input ClearPersonCreateWithoutTicketInput {
    age: Int
    createdAt: ClearDateTime
    email: String
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    phone: String
    pronouns: String
    updatedAt: ClearDateTime
    username: String
}

input ClearPersonMaxOrderByAggregateInput {
    age: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    phone: ClearSortOrder
    pronouns: ClearSortOrder
    updatedAt: ClearSortOrder
    username: ClearSortOrder
}

input ClearPersonMinOrderByAggregateInput {
    age: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    phone: ClearSortOrder
    pronouns: ClearSortOrder
    updatedAt: ClearSortOrder
    username: ClearSortOrder
}

input ClearPersonOrderByWithAggregationInput {
    _avg: ClearPersonAvgOrderByAggregateInput
    _count: ClearPersonCountOrderByAggregateInput
    _max: ClearPersonMaxOrderByAggregateInput
    _min: ClearPersonMinOrderByAggregateInput
    _sum: ClearPersonSumOrderByAggregateInput
    age: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    phone: ClearSortOrder
    pronouns: ClearSortOrder
    updatedAt: ClearSortOrder
    username: ClearSortOrder
}

input ClearPersonOrderByWithRelationInput {
    Ticket: ClearTicketOrderByRelationAggregateInput
    age: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    phone: ClearSortOrder
    pronouns: ClearSortOrder
    updatedAt: ClearSortOrder
    username: ClearSortOrder
}

input ClearPersonRelationFilter {
    is: ClearPersonWhereInput
    isNot: ClearPersonWhereInput
}

input ClearPersonScalarWhereWithAggregatesInput {
    AND: [ClearPersonScalarWhereWithAggregatesInput!]
    NOT: [ClearPersonScalarWhereWithAggregatesInput!]
    OR: [ClearPersonScalarWhereWithAggregatesInput!]
    age: ClearIntNullableWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    email: ClearStringNullableWithAggregatesFilter
    firstName: ClearStringWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    lastName: ClearStringWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    phone: ClearStringNullableWithAggregatesFilter
    pronouns: ClearStringNullableWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
    username: ClearStringNullableWithAggregatesFilter
}

input ClearPersonSumOrderByAggregateInput {
    age: ClearSortOrder
}

input ClearPersonUpdateInput {
    Ticket: ClearTicketUpdateManyWithoutGuardianInput
    age: ClearNullableIntFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    firstName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    phone: ClearNullableStringFieldUpdateOperationsInput
    pronouns: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    username: ClearNullableStringFieldUpdateOperationsInput
}

input ClearPersonUpdateManyMutationInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    firstName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    phone: ClearNullableStringFieldUpdateOperationsInput
    pronouns: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    username: ClearNullableStringFieldUpdateOperationsInput
}

input ClearPersonUpdateOneWithoutTicketInput {
    connect: ClearPersonWhereUniqueInput
    connectOrCreate: ClearPersonCreateOrConnectWithoutTicketInput
    create: ClearPersonCreateWithoutTicketInput
    delete: Boolean
    disconnect: Boolean
    update: ClearPersonUpdateWithoutTicketInput
    upsert: ClearPersonUpsertWithoutTicketInput
}

input ClearPersonUpdateWithoutTicketInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    firstName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    phone: ClearNullableStringFieldUpdateOperationsInput
    pronouns: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    username: ClearNullableStringFieldUpdateOperationsInput
}

input ClearPersonUpsertWithoutTicketInput {
    create: ClearPersonCreateWithoutTicketInput!
    update: ClearPersonUpdateWithoutTicketInput!
}

input ClearPersonWhereInput {
    AND: [ClearPersonWhereInput!]
    NOT: [ClearPersonWhereInput!]
    OR: [ClearPersonWhereInput!]
    Ticket: ClearTicketListRelationFilter
    age: ClearIntNullableFilter
    createdAt: ClearDateTimeFilter
    email: ClearStringNullableFilter
    firstName: ClearStringFilter
    id: ClearStringFilter
    lastName: ClearStringFilter
    metadata: ClearJsonNullableFilter
    phone: ClearStringNullableFilter
    pronouns: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
    username: ClearStringNullableFilter
}

input ClearPersonWhereUniqueInput {
    id: String
}

input ClearScheduleItemCountOrderByAggregateInput {
    createdAt: ClearSortOrder
    description: ClearSortOrder
    end: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    finalized: ClearSortOrder
    hostEmail: ClearSortOrder
    hostName: ClearSortOrder
    hostPronoun: ClearSortOrder
    id: ClearSortOrder
    internal: ClearSortOrder
    link: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    organizerEmail: ClearSortOrder
    organizerName: ClearSortOrder
    organizerPhone: ClearSortOrder
    start: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearScheduleItemCreateInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    event: ClearEventCreateNestedOneWithoutScheduleInput
    eventGroup: ClearEventGroupCreateNestedOneWithoutScheduleInput
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemCreateManyEventGroupInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventId: String
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemCreateManyEventGroupInputEnvelope {
    data: [ClearScheduleItemCreateManyEventGroupInput!]!
    skipDuplicates: Boolean
}

input ClearScheduleItemCreateManyEventInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventGroupId: String
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemCreateManyEventInputEnvelope {
    data: [ClearScheduleItemCreateManyEventInput!]!
    skipDuplicates: Boolean
}

input ClearScheduleItemCreateManyInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventGroupId: String
    eventId: String
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemCreateNestedManyWithoutEventGroupInput {
    connect: [ClearScheduleItemWhereUniqueInput!]
    connectOrCreate: [ClearScheduleItemCreateOrConnectWithoutEventGroupInput!]
    create: [ClearScheduleItemCreateWithoutEventGroupInput!]
    createMany: ClearScheduleItemCreateManyEventGroupInputEnvelope
}

input ClearScheduleItemCreateNestedManyWithoutEventInput {
    connect: [ClearScheduleItemWhereUniqueInput!]
    connectOrCreate: [ClearScheduleItemCreateOrConnectWithoutEventInput!]
    create: [ClearScheduleItemCreateWithoutEventInput!]
    createMany: ClearScheduleItemCreateManyEventInputEnvelope
}

input ClearScheduleItemCreateOrConnectWithoutEventGroupInput {
    create: ClearScheduleItemCreateWithoutEventGroupInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemCreateOrConnectWithoutEventInput {
    create: ClearScheduleItemCreateWithoutEventInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemCreateWithoutEventGroupInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    event: ClearEventCreateNestedOneWithoutScheduleInput
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemCreateWithoutEventInput {
    createdAt: ClearDateTime
    description: String
    end: ClearDateTime
    eventGroup: ClearEventGroupCreateNestedOneWithoutScheduleInput
    finalized: Boolean
    hostEmail: String
    hostName: String
    hostPronoun: String
    id: String
    internal: Boolean
    link: String
    metadata: ClearJSON
    name: String
    organizerEmail: String
    organizerName: String
    organizerPhone: String
    start: ClearDateTime
    type: String
    updatedAt: ClearDateTime
}

input ClearScheduleItemListRelationFilter {
    every: ClearScheduleItemWhereInput
    none: ClearScheduleItemWhereInput
    some: ClearScheduleItemWhereInput
}

input ClearScheduleItemMaxOrderByAggregateInput {
    createdAt: ClearSortOrder
    description: ClearSortOrder
    end: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    finalized: ClearSortOrder
    hostEmail: ClearSortOrder
    hostName: ClearSortOrder
    hostPronoun: ClearSortOrder
    id: ClearSortOrder
    internal: ClearSortOrder
    link: ClearSortOrder
    name: ClearSortOrder
    organizerEmail: ClearSortOrder
    organizerName: ClearSortOrder
    organizerPhone: ClearSortOrder
    start: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearScheduleItemMinOrderByAggregateInput {
    createdAt: ClearSortOrder
    description: ClearSortOrder
    end: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    finalized: ClearSortOrder
    hostEmail: ClearSortOrder
    hostName: ClearSortOrder
    hostPronoun: ClearSortOrder
    id: ClearSortOrder
    internal: ClearSortOrder
    link: ClearSortOrder
    name: ClearSortOrder
    organizerEmail: ClearSortOrder
    organizerName: ClearSortOrder
    organizerPhone: ClearSortOrder
    start: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearScheduleItemOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearScheduleItemOrderByWithAggregationInput {
    _count: ClearScheduleItemCountOrderByAggregateInput
    _max: ClearScheduleItemMaxOrderByAggregateInput
    _min: ClearScheduleItemMinOrderByAggregateInput
    createdAt: ClearSortOrder
    description: ClearSortOrder
    end: ClearSortOrder
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    finalized: ClearSortOrder
    hostEmail: ClearSortOrder
    hostName: ClearSortOrder
    hostPronoun: ClearSortOrder
    id: ClearSortOrder
    internal: ClearSortOrder
    link: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    organizerEmail: ClearSortOrder
    organizerName: ClearSortOrder
    organizerPhone: ClearSortOrder
    start: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearScheduleItemOrderByWithRelationInput {
    createdAt: ClearSortOrder
    description: ClearSortOrder
    end: ClearSortOrder
    event: ClearEventOrderByWithRelationInput
    eventGroup: ClearEventGroupOrderByWithRelationInput
    eventGroupId: ClearSortOrder
    eventId: ClearSortOrder
    finalized: ClearSortOrder
    hostEmail: ClearSortOrder
    hostName: ClearSortOrder
    hostPronoun: ClearSortOrder
    id: ClearSortOrder
    internal: ClearSortOrder
    link: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    organizerEmail: ClearSortOrder
    organizerName: ClearSortOrder
    organizerPhone: ClearSortOrder
    start: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearScheduleItemScalarWhereInput {
    AND: [ClearScheduleItemScalarWhereInput!]
    NOT: [ClearScheduleItemScalarWhereInput!]
    OR: [ClearScheduleItemScalarWhereInput!]
    createdAt: ClearDateTimeFilter
    description: ClearStringNullableFilter
    end: ClearDateTimeNullableFilter
    eventGroupId: ClearStringNullableFilter
    eventId: ClearStringNullableFilter
    finalized: ClearBoolFilter
    hostEmail: ClearStringNullableFilter
    hostName: ClearStringNullableFilter
    hostPronoun: ClearStringNullableFilter
    id: ClearStringFilter
    internal: ClearBoolFilter
    link: ClearStringNullableFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringNullableFilter
    organizerEmail: ClearStringNullableFilter
    organizerName: ClearStringNullableFilter
    organizerPhone: ClearStringNullableFilter
    start: ClearDateTimeNullableFilter
    type: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
}

input ClearScheduleItemScalarWhereWithAggregatesInput {
    AND: [ClearScheduleItemScalarWhereWithAggregatesInput!]
    NOT: [ClearScheduleItemScalarWhereWithAggregatesInput!]
    OR: [ClearScheduleItemScalarWhereWithAggregatesInput!]
    createdAt: ClearDateTimeWithAggregatesFilter
    description: ClearStringNullableWithAggregatesFilter
    end: ClearDateTimeNullableWithAggregatesFilter
    eventGroupId: ClearStringNullableWithAggregatesFilter
    eventId: ClearStringNullableWithAggregatesFilter
    finalized: ClearBoolWithAggregatesFilter
    hostEmail: ClearStringNullableWithAggregatesFilter
    hostName: ClearStringNullableWithAggregatesFilter
    hostPronoun: ClearStringNullableWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    internal: ClearBoolWithAggregatesFilter
    link: ClearStringNullableWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringNullableWithAggregatesFilter
    organizerEmail: ClearStringNullableWithAggregatesFilter
    organizerName: ClearStringNullableWithAggregatesFilter
    organizerPhone: ClearStringNullableWithAggregatesFilter
    start: ClearDateTimeNullableWithAggregatesFilter
    type: ClearStringNullableWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearScheduleItemUpdateInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    end: ClearNullableDateTimeFieldUpdateOperationsInput
    event: ClearEventUpdateOneWithoutScheduleInput
    eventGroup: ClearEventGroupUpdateOneWithoutScheduleInput
    finalized: ClearBoolFieldUpdateOperationsInput
    hostEmail: ClearNullableStringFieldUpdateOperationsInput
    hostName: ClearNullableStringFieldUpdateOperationsInput
    hostPronoun: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    internal: ClearBoolFieldUpdateOperationsInput
    link: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearNullableStringFieldUpdateOperationsInput
    organizerEmail: ClearNullableStringFieldUpdateOperationsInput
    organizerName: ClearNullableStringFieldUpdateOperationsInput
    organizerPhone: ClearNullableStringFieldUpdateOperationsInput
    start: ClearNullableDateTimeFieldUpdateOperationsInput
    type: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearScheduleItemUpdateManyMutationInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    end: ClearNullableDateTimeFieldUpdateOperationsInput
    finalized: ClearBoolFieldUpdateOperationsInput
    hostEmail: ClearNullableStringFieldUpdateOperationsInput
    hostName: ClearNullableStringFieldUpdateOperationsInput
    hostPronoun: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    internal: ClearBoolFieldUpdateOperationsInput
    link: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearNullableStringFieldUpdateOperationsInput
    organizerEmail: ClearNullableStringFieldUpdateOperationsInput
    organizerName: ClearNullableStringFieldUpdateOperationsInput
    organizerPhone: ClearNullableStringFieldUpdateOperationsInput
    start: ClearNullableDateTimeFieldUpdateOperationsInput
    type: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearScheduleItemUpdateManyWithWhereWithoutEventGroupInput {
    data: ClearScheduleItemUpdateManyMutationInput!
    where: ClearScheduleItemScalarWhereInput!
}

input ClearScheduleItemUpdateManyWithWhereWithoutEventInput {
    data: ClearScheduleItemUpdateManyMutationInput!
    where: ClearScheduleItemScalarWhereInput!
}

input ClearScheduleItemUpdateManyWithoutEventGroupInput {
    connect: [ClearScheduleItemWhereUniqueInput!]
    connectOrCreate: [ClearScheduleItemCreateOrConnectWithoutEventGroupInput!]
    create: [ClearScheduleItemCreateWithoutEventGroupInput!]
    createMany: ClearScheduleItemCreateManyEventGroupInputEnvelope
    delete: [ClearScheduleItemWhereUniqueInput!]
    deleteMany: [ClearScheduleItemScalarWhereInput!]
    disconnect: [ClearScheduleItemWhereUniqueInput!]
    set: [ClearScheduleItemWhereUniqueInput!]
    update: [ClearScheduleItemUpdateWithWhereUniqueWithoutEventGroupInput!]
    updateMany: [ClearScheduleItemUpdateManyWithWhereWithoutEventGroupInput!]
    upsert: [ClearScheduleItemUpsertWithWhereUniqueWithoutEventGroupInput!]
}

input ClearScheduleItemUpdateManyWithoutEventInput {
    connect: [ClearScheduleItemWhereUniqueInput!]
    connectOrCreate: [ClearScheduleItemCreateOrConnectWithoutEventInput!]
    create: [ClearScheduleItemCreateWithoutEventInput!]
    createMany: ClearScheduleItemCreateManyEventInputEnvelope
    delete: [ClearScheduleItemWhereUniqueInput!]
    deleteMany: [ClearScheduleItemScalarWhereInput!]
    disconnect: [ClearScheduleItemWhereUniqueInput!]
    set: [ClearScheduleItemWhereUniqueInput!]
    update: [ClearScheduleItemUpdateWithWhereUniqueWithoutEventInput!]
    updateMany: [ClearScheduleItemUpdateManyWithWhereWithoutEventInput!]
    upsert: [ClearScheduleItemUpsertWithWhereUniqueWithoutEventInput!]
}

input ClearScheduleItemUpdateWithWhereUniqueWithoutEventGroupInput {
    data: ClearScheduleItemUpdateWithoutEventGroupInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemUpdateWithWhereUniqueWithoutEventInput {
    data: ClearScheduleItemUpdateWithoutEventInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemUpdateWithoutEventGroupInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    end: ClearNullableDateTimeFieldUpdateOperationsInput
    event: ClearEventUpdateOneWithoutScheduleInput
    finalized: ClearBoolFieldUpdateOperationsInput
    hostEmail: ClearNullableStringFieldUpdateOperationsInput
    hostName: ClearNullableStringFieldUpdateOperationsInput
    hostPronoun: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    internal: ClearBoolFieldUpdateOperationsInput
    link: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearNullableStringFieldUpdateOperationsInput
    organizerEmail: ClearNullableStringFieldUpdateOperationsInput
    organizerName: ClearNullableStringFieldUpdateOperationsInput
    organizerPhone: ClearNullableStringFieldUpdateOperationsInput
    start: ClearNullableDateTimeFieldUpdateOperationsInput
    type: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearScheduleItemUpdateWithoutEventInput {
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    end: ClearNullableDateTimeFieldUpdateOperationsInput
    eventGroup: ClearEventGroupUpdateOneWithoutScheduleInput
    finalized: ClearBoolFieldUpdateOperationsInput
    hostEmail: ClearNullableStringFieldUpdateOperationsInput
    hostName: ClearNullableStringFieldUpdateOperationsInput
    hostPronoun: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    internal: ClearBoolFieldUpdateOperationsInput
    link: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearNullableStringFieldUpdateOperationsInput
    organizerEmail: ClearNullableStringFieldUpdateOperationsInput
    organizerName: ClearNullableStringFieldUpdateOperationsInput
    organizerPhone: ClearNullableStringFieldUpdateOperationsInput
    start: ClearNullableDateTimeFieldUpdateOperationsInput
    type: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearScheduleItemUpsertWithWhereUniqueWithoutEventGroupInput {
    create: ClearScheduleItemCreateWithoutEventGroupInput!
    update: ClearScheduleItemUpdateWithoutEventGroupInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemUpsertWithWhereUniqueWithoutEventInput {
    create: ClearScheduleItemCreateWithoutEventInput!
    update: ClearScheduleItemUpdateWithoutEventInput!
    where: ClearScheduleItemWhereUniqueInput!
}

input ClearScheduleItemWhereInput {
    AND: [ClearScheduleItemWhereInput!]
    NOT: [ClearScheduleItemWhereInput!]
    OR: [ClearScheduleItemWhereInput!]
    createdAt: ClearDateTimeFilter
    description: ClearStringNullableFilter
    end: ClearDateTimeNullableFilter
    event: ClearEventRelationFilter
    eventGroup: ClearEventGroupRelationFilter
    eventGroupId: ClearStringNullableFilter
    eventId: ClearStringNullableFilter
    finalized: ClearBoolFilter
    hostEmail: ClearStringNullableFilter
    hostName: ClearStringNullableFilter
    hostPronoun: ClearStringNullableFilter
    id: ClearStringFilter
    internal: ClearBoolFilter
    link: ClearStringNullableFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringNullableFilter
    organizerEmail: ClearStringNullableFilter
    organizerName: ClearStringNullableFilter
    organizerPhone: ClearStringNullableFilter
    start: ClearDateTimeNullableFilter
    type: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
}

input ClearScheduleItemWhereUniqueInput {
    id: String
}

input ClearSponsorAvgOrderByAggregateInput {
    amount: ClearSortOrder
}

input ClearSponsorCountOrderByAggregateInput {
    amount: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    description: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    logoImageUri: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    perks: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearSponsorCreateInput {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    description: String
    event: ClearEventCreateNestedOneWithoutSponsorsInput
    id: String
    logoImageUri: String
    metadata: ClearJSON
    name: String!
    perks: String
    updatedAt: ClearDateTime
}

input ClearSponsorCreateManyEventInput {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    description: String
    id: String
    logoImageUri: String
    metadata: ClearJSON
    name: String!
    perks: String
    updatedAt: ClearDateTime
}

input ClearSponsorCreateManyEventInputEnvelope {
    data: [ClearSponsorCreateManyEventInput!]!
    skipDuplicates: Boolean
}

input ClearSponsorCreateManyInput {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    description: String
    eventId: String
    id: String
    logoImageUri: String
    metadata: ClearJSON
    name: String!
    perks: String
    updatedAt: ClearDateTime
}

input ClearSponsorCreateNestedManyWithoutEventInput {
    connect: [ClearSponsorWhereUniqueInput!]
    connectOrCreate: [ClearSponsorCreateOrConnectWithoutEventInput!]
    create: [ClearSponsorCreateWithoutEventInput!]
    createMany: ClearSponsorCreateManyEventInputEnvelope
}

input ClearSponsorCreateOrConnectWithoutEventInput {
    create: ClearSponsorCreateWithoutEventInput!
    where: ClearSponsorWhereUniqueInput!
}

input ClearSponsorCreateWithoutEventInput {
    amount: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    description: String
    id: String
    logoImageUri: String
    metadata: ClearJSON
    name: String!
    perks: String
    updatedAt: ClearDateTime
}

input ClearSponsorListRelationFilter {
    every: ClearSponsorWhereInput
    none: ClearSponsorWhereInput
    some: ClearSponsorWhereInput
}

input ClearSponsorMaxOrderByAggregateInput {
    amount: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    description: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    logoImageUri: ClearSortOrder
    name: ClearSortOrder
    perks: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearSponsorMinOrderByAggregateInput {
    amount: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    description: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    logoImageUri: ClearSortOrder
    name: ClearSortOrder
    perks: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearSponsorOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearSponsorOrderByWithAggregationInput {
    _avg: ClearSponsorAvgOrderByAggregateInput
    _count: ClearSponsorCountOrderByAggregateInput
    _max: ClearSponsorMaxOrderByAggregateInput
    _min: ClearSponsorMinOrderByAggregateInput
    _sum: ClearSponsorSumOrderByAggregateInput
    amount: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    description: ClearSortOrder
    eventId: ClearSortOrder
    id: ClearSortOrder
    logoImageUri: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    perks: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearSponsorOrderByWithRelationInput {
    amount: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    description: ClearSortOrder
    event: ClearEventOrderByWithRelationInput
    eventId: ClearSortOrder
    id: ClearSortOrder
    logoImageUri: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    perks: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearSponsorScalarWhereInput {
    AND: [ClearSponsorScalarWhereInput!]
    NOT: [ClearSponsorScalarWhereInput!]
    OR: [ClearSponsorScalarWhereInput!]
    amount: ClearIntFilter
    contactEmail: ClearStringNullableFilter
    contactName: ClearStringNullableFilter
    contactPhone: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    description: ClearStringNullableFilter
    eventId: ClearStringNullableFilter
    id: ClearStringFilter
    logoImageUri: ClearStringNullableFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    perks: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
}

input ClearSponsorScalarWhereWithAggregatesInput {
    AND: [ClearSponsorScalarWhereWithAggregatesInput!]
    NOT: [ClearSponsorScalarWhereWithAggregatesInput!]
    OR: [ClearSponsorScalarWhereWithAggregatesInput!]
    amount: ClearIntWithAggregatesFilter
    contactEmail: ClearStringNullableWithAggregatesFilter
    contactName: ClearStringNullableWithAggregatesFilter
    contactPhone: ClearStringNullableWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    description: ClearStringNullableWithAggregatesFilter
    eventId: ClearStringNullableWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    logoImageUri: ClearStringNullableWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringWithAggregatesFilter
    perks: ClearStringNullableWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearSponsorSumOrderByAggregateInput {
    amount: ClearSortOrder
}

input ClearSponsorUpdateInput {
    amount: ClearIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    event: ClearEventUpdateOneWithoutSponsorsInput
    id: ClearStringFieldUpdateOperationsInput
    logoImageUri: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    perks: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearSponsorUpdateManyMutationInput {
    amount: ClearIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    logoImageUri: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    perks: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearSponsorUpdateManyWithWhereWithoutEventInput {
    data: ClearSponsorUpdateManyMutationInput!
    where: ClearSponsorScalarWhereInput!
}

input ClearSponsorUpdateManyWithoutEventInput {
    connect: [ClearSponsorWhereUniqueInput!]
    connectOrCreate: [ClearSponsorCreateOrConnectWithoutEventInput!]
    create: [ClearSponsorCreateWithoutEventInput!]
    createMany: ClearSponsorCreateManyEventInputEnvelope
    delete: [ClearSponsorWhereUniqueInput!]
    deleteMany: [ClearSponsorScalarWhereInput!]
    disconnect: [ClearSponsorWhereUniqueInput!]
    set: [ClearSponsorWhereUniqueInput!]
    update: [ClearSponsorUpdateWithWhereUniqueWithoutEventInput!]
    updateMany: [ClearSponsorUpdateManyWithWhereWithoutEventInput!]
    upsert: [ClearSponsorUpsertWithWhereUniqueWithoutEventInput!]
}

input ClearSponsorUpdateWithWhereUniqueWithoutEventInput {
    data: ClearSponsorUpdateWithoutEventInput!
    where: ClearSponsorWhereUniqueInput!
}

input ClearSponsorUpdateWithoutEventInput {
    amount: ClearIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    description: ClearNullableStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    logoImageUri: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearStringFieldUpdateOperationsInput
    perks: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearSponsorUpsertWithWhereUniqueWithoutEventInput {
    create: ClearSponsorCreateWithoutEventInput!
    update: ClearSponsorUpdateWithoutEventInput!
    where: ClearSponsorWhereUniqueInput!
}

input ClearSponsorWhereInput {
    AND: [ClearSponsorWhereInput!]
    NOT: [ClearSponsorWhereInput!]
    OR: [ClearSponsorWhereInput!]
    amount: ClearIntFilter
    contactEmail: ClearStringNullableFilter
    contactName: ClearStringNullableFilter
    contactPhone: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    description: ClearStringNullableFilter
    event: ClearEventRelationFilter
    eventId: ClearStringNullableFilter
    id: ClearStringFilter
    logoImageUri: ClearStringNullableFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringFilter
    perks: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
}

input ClearSponsorWhereUniqueInput {
    id: String
}

input ClearStringFieldUpdateOperationsInput {
    set: String
}

input ClearStringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: ClearQueryMode
    not: ClearNestedStringFilter
    notIn: [String!]
    startsWith: String
}

input ClearStringNullableFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: ClearQueryMode
    not: ClearNestedStringNullableFilter
    notIn: [String!]
    startsWith: String
}

input ClearStringNullableListFilter {
    equals: [String!]
    has: String
    hasEvery: [String!]
    hasSome: [String!]
    isEmpty: Boolean
}

input ClearStringNullableWithAggregatesFilter {
    _count: ClearNestedIntNullableFilter
    _max: ClearNestedStringNullableFilter
    _min: ClearNestedStringNullableFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: ClearQueryMode
    not: ClearNestedStringNullableWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input ClearStringWithAggregatesFilter {
    _count: ClearNestedIntFilter
    _max: ClearNestedStringFilter
    _min: ClearNestedStringFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: ClearQueryMode
    not: ClearNestedStringWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input ClearTicketAvgOrderByAggregateInput {
    age: ClearSortOrder
}

input ClearTicketCountOrderByAggregateInput {
    age: ClearSortOrder
    couponCode: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    eventId: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    paymentId: ClearSortOrder
    personId: ClearSortOrder
    phone: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    waiverSigned: ClearSortOrder
}

input ClearTicketCreateInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    event: ClearEventCreateNestedOneWithoutTicketsInput!
    firstName: String!
    guardian: ClearPersonCreateNestedOneWithoutTicketInput
    id: String
    lastName: String!
    metadata: ClearJSON
    payment: ClearPaymentCreateNestedOneWithoutTicketInput
    phone: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateManyEventInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    paymentId: String
    personId: String
    phone: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateManyEventInputEnvelope {
    data: [ClearTicketCreateManyEventInput!]!
    skipDuplicates: Boolean
}

input ClearTicketCreateManyGuardianInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    eventId: String!
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    paymentId: String
    phone: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateManyGuardianInputEnvelope {
    data: [ClearTicketCreateManyGuardianInput!]!
    skipDuplicates: Boolean
}

input ClearTicketCreateManyInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    eventId: String!
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    paymentId: String
    personId: String
    phone: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateManyPaymentInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    eventId: String!
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    personId: String
    phone: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateManyPaymentInputEnvelope {
    data: [ClearTicketCreateManyPaymentInput!]!
    skipDuplicates: Boolean
}

input ClearTicketCreateNestedManyWithoutEventInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutEventInput!]
    create: [ClearTicketCreateWithoutEventInput!]
    createMany: ClearTicketCreateManyEventInputEnvelope
}

input ClearTicketCreateNestedManyWithoutGuardianInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutGuardianInput!]
    create: [ClearTicketCreateWithoutGuardianInput!]
    createMany: ClearTicketCreateManyGuardianInputEnvelope
}

input ClearTicketCreateNestedManyWithoutPaymentInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutPaymentInput!]
    create: [ClearTicketCreateWithoutPaymentInput!]
    createMany: ClearTicketCreateManyPaymentInputEnvelope
}

input ClearTicketCreateOrConnectWithoutEventInput {
    create: ClearTicketCreateWithoutEventInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketCreateOrConnectWithoutGuardianInput {
    create: ClearTicketCreateWithoutGuardianInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketCreateOrConnectWithoutPaymentInput {
    create: ClearTicketCreateWithoutPaymentInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketCreateWithoutEventInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    firstName: String!
    guardian: ClearPersonCreateNestedOneWithoutTicketInput
    id: String
    lastName: String!
    metadata: ClearJSON
    payment: ClearPaymentCreateNestedOneWithoutTicketInput
    phone: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateWithoutGuardianInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    event: ClearEventCreateNestedOneWithoutTicketsInput!
    firstName: String!
    id: String
    lastName: String!
    metadata: ClearJSON
    payment: ClearPaymentCreateNestedOneWithoutTicketInput
    phone: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketCreateWithoutPaymentInput {
    age: Int
    couponCode: String
    createdAt: ClearDateTime
    email: String
    event: ClearEventCreateNestedOneWithoutTicketsInput!
    firstName: String!
    guardian: ClearPersonCreateNestedOneWithoutTicketInput
    id: String
    lastName: String!
    metadata: ClearJSON
    phone: String
    type: ClearTicketType
    updatedAt: ClearDateTime
    waiverSigned: Boolean
}

input ClearTicketListRelationFilter {
    every: ClearTicketWhereInput
    none: ClearTicketWhereInput
    some: ClearTicketWhereInput
}

input ClearTicketMaxOrderByAggregateInput {
    age: ClearSortOrder
    couponCode: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    eventId: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    paymentId: ClearSortOrder
    personId: ClearSortOrder
    phone: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    waiverSigned: ClearSortOrder
}

input ClearTicketMinOrderByAggregateInput {
    age: ClearSortOrder
    couponCode: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    eventId: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    paymentId: ClearSortOrder
    personId: ClearSortOrder
    phone: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    waiverSigned: ClearSortOrder
}

input ClearTicketOrderByRelationAggregateInput {
    _count: ClearSortOrder
}

input ClearTicketOrderByWithAggregationInput {
    _avg: ClearTicketAvgOrderByAggregateInput
    _count: ClearTicketCountOrderByAggregateInput
    _max: ClearTicketMaxOrderByAggregateInput
    _min: ClearTicketMinOrderByAggregateInput
    _sum: ClearTicketSumOrderByAggregateInput
    age: ClearSortOrder
    couponCode: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    eventId: ClearSortOrder
    firstName: ClearSortOrder
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    paymentId: ClearSortOrder
    personId: ClearSortOrder
    phone: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    waiverSigned: ClearSortOrder
}

input ClearTicketOrderByWithRelationInput {
    age: ClearSortOrder
    couponCode: ClearSortOrder
    createdAt: ClearSortOrder
    email: ClearSortOrder
    event: ClearEventOrderByWithRelationInput
    eventId: ClearSortOrder
    firstName: ClearSortOrder
    guardian: ClearPersonOrderByWithRelationInput
    id: ClearSortOrder
    lastName: ClearSortOrder
    metadata: ClearSortOrder
    payment: ClearPaymentOrderByWithRelationInput
    paymentId: ClearSortOrder
    personId: ClearSortOrder
    phone: ClearSortOrder
    type: ClearSortOrder
    updatedAt: ClearSortOrder
    waiverSigned: ClearSortOrder
}

input ClearTicketScalarWhereInput {
    AND: [ClearTicketScalarWhereInput!]
    NOT: [ClearTicketScalarWhereInput!]
    OR: [ClearTicketScalarWhereInput!]
    age: ClearIntNullableFilter
    couponCode: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    email: ClearStringNullableFilter
    eventId: ClearStringFilter
    firstName: ClearStringFilter
    id: ClearStringFilter
    lastName: ClearStringFilter
    metadata: ClearJsonNullableFilter
    paymentId: ClearStringNullableFilter
    personId: ClearStringNullableFilter
    phone: ClearStringNullableFilter
    type: ClearEnumTicketTypeFilter
    updatedAt: ClearDateTimeFilter
    waiverSigned: ClearBoolFilter
}

input ClearTicketScalarWhereWithAggregatesInput {
    AND: [ClearTicketScalarWhereWithAggregatesInput!]
    NOT: [ClearTicketScalarWhereWithAggregatesInput!]
    OR: [ClearTicketScalarWhereWithAggregatesInput!]
    age: ClearIntNullableWithAggregatesFilter
    couponCode: ClearStringNullableWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    email: ClearStringNullableWithAggregatesFilter
    eventId: ClearStringWithAggregatesFilter
    firstName: ClearStringWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    lastName: ClearStringWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    paymentId: ClearStringNullableWithAggregatesFilter
    personId: ClearStringNullableWithAggregatesFilter
    phone: ClearStringNullableWithAggregatesFilter
    type: ClearEnumTicketTypeWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
    waiverSigned: ClearBoolWithAggregatesFilter
}

input ClearTicketSumOrderByAggregateInput {
    age: ClearSortOrder
}

input ClearTicketUpdateInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    event: ClearEventUpdateOneRequiredWithoutTicketsInput
    firstName: ClearStringFieldUpdateOperationsInput
    guardian: ClearPersonUpdateOneWithoutTicketInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    payment: ClearPaymentUpdateOneWithoutTicketInput
    phone: ClearNullableStringFieldUpdateOperationsInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpdateManyMutationInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    firstName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    phone: ClearNullableStringFieldUpdateOperationsInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpdateManyWithWhereWithoutEventInput {
    data: ClearTicketUpdateManyMutationInput!
    where: ClearTicketScalarWhereInput!
}

input ClearTicketUpdateManyWithWhereWithoutGuardianInput {
    data: ClearTicketUpdateManyMutationInput!
    where: ClearTicketScalarWhereInput!
}

input ClearTicketUpdateManyWithWhereWithoutPaymentInput {
    data: ClearTicketUpdateManyMutationInput!
    where: ClearTicketScalarWhereInput!
}

input ClearTicketUpdateManyWithoutEventInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutEventInput!]
    create: [ClearTicketCreateWithoutEventInput!]
    createMany: ClearTicketCreateManyEventInputEnvelope
    delete: [ClearTicketWhereUniqueInput!]
    deleteMany: [ClearTicketScalarWhereInput!]
    disconnect: [ClearTicketWhereUniqueInput!]
    set: [ClearTicketWhereUniqueInput!]
    update: [ClearTicketUpdateWithWhereUniqueWithoutEventInput!]
    updateMany: [ClearTicketUpdateManyWithWhereWithoutEventInput!]
    upsert: [ClearTicketUpsertWithWhereUniqueWithoutEventInput!]
}

input ClearTicketUpdateManyWithoutGuardianInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutGuardianInput!]
    create: [ClearTicketCreateWithoutGuardianInput!]
    createMany: ClearTicketCreateManyGuardianInputEnvelope
    delete: [ClearTicketWhereUniqueInput!]
    deleteMany: [ClearTicketScalarWhereInput!]
    disconnect: [ClearTicketWhereUniqueInput!]
    set: [ClearTicketWhereUniqueInput!]
    update: [ClearTicketUpdateWithWhereUniqueWithoutGuardianInput!]
    updateMany: [ClearTicketUpdateManyWithWhereWithoutGuardianInput!]
    upsert: [ClearTicketUpsertWithWhereUniqueWithoutGuardianInput!]
}

input ClearTicketUpdateManyWithoutPaymentInput {
    connect: [ClearTicketWhereUniqueInput!]
    connectOrCreate: [ClearTicketCreateOrConnectWithoutPaymentInput!]
    create: [ClearTicketCreateWithoutPaymentInput!]
    createMany: ClearTicketCreateManyPaymentInputEnvelope
    delete: [ClearTicketWhereUniqueInput!]
    deleteMany: [ClearTicketScalarWhereInput!]
    disconnect: [ClearTicketWhereUniqueInput!]
    set: [ClearTicketWhereUniqueInput!]
    update: [ClearTicketUpdateWithWhereUniqueWithoutPaymentInput!]
    updateMany: [ClearTicketUpdateManyWithWhereWithoutPaymentInput!]
    upsert: [ClearTicketUpsertWithWhereUniqueWithoutPaymentInput!]
}

input ClearTicketUpdateWithWhereUniqueWithoutEventInput {
    data: ClearTicketUpdateWithoutEventInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpdateWithWhereUniqueWithoutGuardianInput {
    data: ClearTicketUpdateWithoutGuardianInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpdateWithWhereUniqueWithoutPaymentInput {
    data: ClearTicketUpdateWithoutPaymentInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpdateWithoutEventInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    firstName: ClearStringFieldUpdateOperationsInput
    guardian: ClearPersonUpdateOneWithoutTicketInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    payment: ClearPaymentUpdateOneWithoutTicketInput
    phone: ClearNullableStringFieldUpdateOperationsInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpdateWithoutGuardianInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    event: ClearEventUpdateOneRequiredWithoutTicketsInput
    firstName: ClearStringFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    payment: ClearPaymentUpdateOneWithoutTicketInput
    phone: ClearNullableStringFieldUpdateOperationsInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpdateWithoutPaymentInput {
    age: ClearNullableIntFieldUpdateOperationsInput
    couponCode: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    email: ClearNullableStringFieldUpdateOperationsInput
    event: ClearEventUpdateOneRequiredWithoutTicketsInput
    firstName: ClearStringFieldUpdateOperationsInput
    guardian: ClearPersonUpdateOneWithoutTicketInput
    id: ClearStringFieldUpdateOperationsInput
    lastName: ClearStringFieldUpdateOperationsInput
    metadata: ClearJSON
    phone: ClearNullableStringFieldUpdateOperationsInput
    type: ClearEnumTicketTypeFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
    waiverSigned: ClearBoolFieldUpdateOperationsInput
}

input ClearTicketUpsertWithWhereUniqueWithoutEventInput {
    create: ClearTicketCreateWithoutEventInput!
    update: ClearTicketUpdateWithoutEventInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpsertWithWhereUniqueWithoutGuardianInput {
    create: ClearTicketCreateWithoutGuardianInput!
    update: ClearTicketUpdateWithoutGuardianInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketUpsertWithWhereUniqueWithoutPaymentInput {
    create: ClearTicketCreateWithoutPaymentInput!
    update: ClearTicketUpdateWithoutPaymentInput!
    where: ClearTicketWhereUniqueInput!
}

input ClearTicketWhereInput {
    AND: [ClearTicketWhereInput!]
    NOT: [ClearTicketWhereInput!]
    OR: [ClearTicketWhereInput!]
    age: ClearIntNullableFilter
    couponCode: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    email: ClearStringNullableFilter
    event: ClearEventRelationFilter
    eventId: ClearStringFilter
    firstName: ClearStringFilter
    guardian: ClearPersonRelationFilter
    id: ClearStringFilter
    lastName: ClearStringFilter
    metadata: ClearJsonNullableFilter
    payment: ClearPaymentRelationFilter
    paymentId: ClearStringNullableFilter
    personId: ClearStringNullableFilter
    phone: ClearStringNullableFilter
    type: ClearEnumTicketTypeFilter
    updatedAt: ClearDateTimeFilter
    waiverSigned: ClearBoolFilter
}

input ClearTicketWhereUniqueInput {
    id: String
}

input ClearVenueAvgOrderByAggregateInput {
    capacity: ClearSortOrder
}

input ClearVenueCountOrderByAggregateInput {
    address: ClearSortOrder
    capacity: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    mapLink: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearVenueCreateInput {
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    events: ClearEventCreateNestedManyWithoutVenueInput
    id: String
    mapLink: String
    metadata: ClearJSON
    name: String
    updatedAt: ClearDateTime
}

input ClearVenueCreateManyInput {
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    id: String
    mapLink: String
    metadata: ClearJSON
    name: String
    updatedAt: ClearDateTime
}

input ClearVenueCreateNestedOneWithoutEventsInput {
    connect: ClearVenueWhereUniqueInput
    connectOrCreate: ClearVenueCreateOrConnectWithoutEventsInput
    create: ClearVenueCreateWithoutEventsInput
}

input ClearVenueCreateOrConnectWithoutEventsInput {
    create: ClearVenueCreateWithoutEventsInput!
    where: ClearVenueWhereUniqueInput!
}

input ClearVenueCreateWithoutEventsInput {
    address: String
    capacity: Int
    contactEmail: String
    contactName: String
    contactPhone: String
    createdAt: ClearDateTime
    id: String
    mapLink: String
    metadata: ClearJSON
    name: String
    updatedAt: ClearDateTime
}

input ClearVenueMaxOrderByAggregateInput {
    address: ClearSortOrder
    capacity: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    mapLink: ClearSortOrder
    name: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearVenueMinOrderByAggregateInput {
    address: ClearSortOrder
    capacity: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    mapLink: ClearSortOrder
    name: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearVenueOrderByWithAggregationInput {
    _avg: ClearVenueAvgOrderByAggregateInput
    _count: ClearVenueCountOrderByAggregateInput
    _max: ClearVenueMaxOrderByAggregateInput
    _min: ClearVenueMinOrderByAggregateInput
    _sum: ClearVenueSumOrderByAggregateInput
    address: ClearSortOrder
    capacity: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    id: ClearSortOrder
    mapLink: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearVenueOrderByWithRelationInput {
    address: ClearSortOrder
    capacity: ClearSortOrder
    contactEmail: ClearSortOrder
    contactName: ClearSortOrder
    contactPhone: ClearSortOrder
    createdAt: ClearSortOrder
    events: ClearEventOrderByRelationAggregateInput
    id: ClearSortOrder
    mapLink: ClearSortOrder
    metadata: ClearSortOrder
    name: ClearSortOrder
    updatedAt: ClearSortOrder
}

input ClearVenueRelationFilter {
    is: ClearVenueWhereInput
    isNot: ClearVenueWhereInput
}

input ClearVenueScalarWhereWithAggregatesInput {
    AND: [ClearVenueScalarWhereWithAggregatesInput!]
    NOT: [ClearVenueScalarWhereWithAggregatesInput!]
    OR: [ClearVenueScalarWhereWithAggregatesInput!]
    address: ClearStringNullableWithAggregatesFilter
    capacity: ClearIntNullableWithAggregatesFilter
    contactEmail: ClearStringNullableWithAggregatesFilter
    contactName: ClearStringNullableWithAggregatesFilter
    contactPhone: ClearStringNullableWithAggregatesFilter
    createdAt: ClearDateTimeWithAggregatesFilter
    id: ClearStringWithAggregatesFilter
    mapLink: ClearStringNullableWithAggregatesFilter
    metadata: ClearJsonNullableWithAggregatesFilter
    name: ClearStringNullableWithAggregatesFilter
    updatedAt: ClearDateTimeWithAggregatesFilter
}

input ClearVenueSumOrderByAggregateInput {
    capacity: ClearSortOrder
}

input ClearVenueUpdateInput {
    address: ClearNullableStringFieldUpdateOperationsInput
    capacity: ClearNullableIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    events: ClearEventUpdateManyWithoutVenueInput
    id: ClearStringFieldUpdateOperationsInput
    mapLink: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearVenueUpdateManyMutationInput {
    address: ClearNullableStringFieldUpdateOperationsInput
    capacity: ClearNullableIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    mapLink: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearVenueUpdateOneWithoutEventsInput {
    connect: ClearVenueWhereUniqueInput
    connectOrCreate: ClearVenueCreateOrConnectWithoutEventsInput
    create: ClearVenueCreateWithoutEventsInput
    delete: Boolean
    disconnect: Boolean
    update: ClearVenueUpdateWithoutEventsInput
    upsert: ClearVenueUpsertWithoutEventsInput
}

input ClearVenueUpdateWithoutEventsInput {
    address: ClearNullableStringFieldUpdateOperationsInput
    capacity: ClearNullableIntFieldUpdateOperationsInput
    contactEmail: ClearNullableStringFieldUpdateOperationsInput
    contactName: ClearNullableStringFieldUpdateOperationsInput
    contactPhone: ClearNullableStringFieldUpdateOperationsInput
    createdAt: ClearDateTimeFieldUpdateOperationsInput
    id: ClearStringFieldUpdateOperationsInput
    mapLink: ClearNullableStringFieldUpdateOperationsInput
    metadata: ClearJSON
    name: ClearNullableStringFieldUpdateOperationsInput
    updatedAt: ClearDateTimeFieldUpdateOperationsInput
}

input ClearVenueUpsertWithoutEventsInput {
    create: ClearVenueCreateWithoutEventsInput!
    update: ClearVenueUpdateWithoutEventsInput!
}

input ClearVenueWhereInput {
    AND: [ClearVenueWhereInput!]
    NOT: [ClearVenueWhereInput!]
    OR: [ClearVenueWhereInput!]
    address: ClearStringNullableFilter
    capacity: ClearIntNullableFilter
    contactEmail: ClearStringNullableFilter
    contactName: ClearStringNullableFilter
    contactPhone: ClearStringNullableFilter
    createdAt: ClearDateTimeFilter
    events: ClearEventListRelationFilter
    id: ClearStringFilter
    mapLink: ClearStringNullableFilter
    metadata: ClearJsonNullableFilter
    name: ClearStringNullableFilter
    updatedAt: ClearDateTimeFilter
}

input ClearVenueWhereUniqueInput {
    id: String
}

input CmsAnnouncementFilter {
    AND: [CmsAnnouncementFilter]
    OR: [CmsAnnouncementFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    displayAt: CmsDateTime
    displayAt_exists: Boolean
    displayAt_gt: CmsDateTime
    displayAt_gte: CmsDateTime
    displayAt_in: [CmsDateTime]
    displayAt_lt: CmsDateTime
    displayAt_lte: CmsDateTime
    displayAt_not: CmsDateTime
    displayAt_not_in: [CmsDateTime]
    endAt: CmsDateTime
    endAt_exists: Boolean
    endAt_gt: CmsDateTime
    endAt_gte: CmsDateTime
    endAt_in: [CmsDateTime]
    endAt_lt: CmsDateTime
    endAt_lte: CmsDateTime
    endAt_not: CmsDateTime
    endAt_not_in: [CmsDateTime]
    link: String
    link_contains: String
    link_exists: Boolean
    link_in: [String]
    link_not: String
    link_not_contains: String
    link_not_in: [String]
    oneline: String
    oneline_contains: String
    oneline_exists: Boolean
    oneline_in: [String]
    oneline_not: String
    oneline_not_contains: String
    oneline_not_in: [String]
    programCollection_exists: Boolean
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
    visibility: String
    visibility_contains: String
    visibility_exists: Boolean
    visibility_in: [String]
    visibility_not: String
    visibility_not_contains: String
    visibility_not_in: [String]
}

input CmsAssetFilter {
    AND: [CmsAssetFilter]
    OR: [CmsAssetFilter]
    contentType: String
    contentType_contains: String
    contentType_exists: Boolean
    contentType_in: [String]
    contentType_not: String
    contentType_not_contains: String
    contentType_not_in: [String]
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    fileName: String
    fileName_contains: String
    fileName_exists: Boolean
    fileName_in: [String]
    fileName_not: String
    fileName_not_contains: String
    fileName_not_in: [String]
    height: Int
    height_exists: Boolean
    height_gt: Int
    height_gte: Int
    height_in: [Int]
    height_lt: Int
    height_lte: Int
    height_not: Int
    height_not_in: [Int]
    size: Int
    size_exists: Boolean
    size_gt: Int
    size_gte: Int
    size_in: [Int]
    size_lt: Int
    size_lte: Int
    size_not: Int
    size_not_in: [Int]
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
    width: Int
    width_exists: Boolean
    width_gt: Int
    width_gte: Int
    width_in: [Int]
    width_lt: Int
    width_lte: Int
    width_not: Int
    width_not_in: [Int]
}

input CmsAwardFilter {
    AND: [CmsAwardFilter]
    OR: [CmsAwardFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    icon_exists: Boolean
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    programsCollection_exists: Boolean
    ranking: Int
    ranking_exists: Boolean
    ranking_gt: Int
    ranking_gte: Int
    ranking_in: [Int]
    ranking_lt: Int
    ranking_lte: Int
    ranking_not: Int
    ranking_not_in: [Int]
    sys: CmsSysFilter
}

input CmsBadgeFilter {
    AND: [CmsBadgeFilter]
    OR: [CmsBadgeFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    earnCriteria: String
    earnCriteria_contains: String
    earnCriteria_exists: Boolean
    earnCriteria_in: [String]
    earnCriteria_not: String
    earnCriteria_not_contains: String
    earnCriteria_not_in: [String]
    earnMessage: String
    earnMessage_contains: String
    earnMessage_exists: Boolean
    earnMessage_in: [String]
    earnMessage_not: String
    earnMessage_not_contains: String
    earnMessage_not_in: [String]
    emoji: String
    emoji_contains: String
    emoji_exists: Boolean
    emoji_in: [String]
    emoji_not: String
    emoji_not_contains: String
    emoji_not_in: [String]
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    image_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    sys: CmsSysFilter
}

input CmsBumperFilter {
    AND: [CmsBumperFilter]
    OR: [CmsBumperFilter]
    ambient: Boolean
    ambient_exists: Boolean
    ambient_not: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    purpose_contains_all: [String]
    purpose_contains_none: [String]
    purpose_contains_some: [String]
    purpose_exists: Boolean
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmsCommunityPartnerFilter {
    AND: [CmsCommunityPartnerFilter]
    OR: [CmsCommunityPartnerFilter]
    audience_contains_all: [String]
    audience_contains_none: [String]
    audience_contains_some: [String]
    audience_exists: Boolean
    blurb: String
    blurb_contains: String
    blurb_exists: Boolean
    blurb_in: [String]
    blurb_not: String
    blurb_not_contains: String
    blurb_not_in: [String]
    contentfulMetadata: CmsContentfulMetadataFilter
    cost: Int
    cost_exists: Boolean
    cost_gt: Int
    cost_gte: Int
    cost_in: [Int]
    cost_lt: Int
    cost_lte: Int
    cost_not: Int
    cost_not_in: [Int]
    details: String
    details_contains: String
    details_exists: Boolean
    details_in: [String]
    details_not: String
    details_not_contains: String
    details_not_in: [String]
    displayUrl: String
    displayUrl_contains: String
    displayUrl_exists: Boolean
    displayUrl_in: [String]
    displayUrl_not: String
    displayUrl_not_contains: String
    displayUrl_not_in: [String]
    eligibility: String
    eligibility_contains: String
    eligibility_exists: Boolean
    eligibility_in: [String]
    eligibility_not: String
    eligibility_not_contains: String
    eligibility_not_in: [String]
    expires: CmsDateTime
    expires_exists: Boolean
    expires_gt: CmsDateTime
    expires_gte: CmsDateTime
    expires_in: [CmsDateTime]
    expires_lt: CmsDateTime
    expires_lte: CmsDateTime
    expires_not: CmsDateTime
    expires_not_in: [CmsDateTime]
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    regionCollection_exists: Boolean
    sys: CmsSysFilter
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
}

input CmsContentTypeStringFilter {
    AND: [CmsContentTypeStringFilter]
    OR: [CmsContentTypeStringFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    key: String
    key_contains: String
    key_exists: Boolean
    key_in: [String]
    key_not: String
    key_not_contains: String
    key_not_in: [String]
    richValue_contains: String
    richValue_exists: Boolean
    richValue_not_contains: String
    subvalueCollection_exists: Boolean
    sys: CmsSysFilter
    value: String
    value_contains: String
    value_exists: Boolean
    value_in: [String]
    value_not: String
    value_not_contains: String
    value_not_in: [String]
}

input CmsContentfulMetadataFilter {
    tags: CmsContentfulMetadataTagsFilter
    tags_exists: Boolean
}

input CmsContentfulMetadataTagsFilter {
    id_contains_all: [String]
    id_contains_none: [String]
    id_contains_some: [String]
}

input CmsEntryFilter {
    AND: [CmsEntryFilter]
    OR: [CmsEntryFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    sys: CmsSysFilter
}

input CmsEventFilter {
    AND: [CmsEventFilter]
    OR: [CmsEventFilter]
    awardsAt: CmsDateTime
    awardsAt_exists: Boolean
    awardsAt_gt: CmsDateTime
    awardsAt_gte: CmsDateTime
    awardsAt_in: [CmsDateTime]
    awardsAt_lt: CmsDateTime
    awardsAt_lte: CmsDateTime
    awardsAt_not: CmsDateTime
    awardsAt_not_in: [CmsDateTime]
    calendarReleaseDate: CmsDateTime
    calendarReleaseDate_exists: Boolean
    calendarReleaseDate_gt: CmsDateTime
    calendarReleaseDate_gte: CmsDateTime
    calendarReleaseDate_in: [CmsDateTime]
    calendarReleaseDate_lt: CmsDateTime
    calendarReleaseDate_lte: CmsDateTime
    calendarReleaseDate_not: CmsDateTime
    calendarReleaseDate_not_in: [CmsDateTime]
    contentfulMetadata: CmsContentfulMetadataFilter
    endsAt: CmsDateTime
    endsAt_exists: Boolean
    endsAt_gt: CmsDateTime
    endsAt_gte: CmsDateTime
    endsAt_in: [CmsDateTime]
    endsAt_lt: CmsDateTime
    endsAt_lte: CmsDateTime
    endsAt_not: CmsDateTime
    endsAt_not_in: [CmsDateTime]
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    kickoffVideoCaptions_exists: Boolean
    kickoffVideo_exists: Boolean
    notice_contains: String
    notice_exists: Boolean
    notice_not_contains: String
    participantRoleId: String
    participantRoleId_contains: String
    participantRoleId_exists: Boolean
    participantRoleId_in: [String]
    participantRoleId_not: String
    participantRoleId_not_contains: String
    participantRoleId_not_in: [String]
    postersCollection_exists: Boolean
    program: CmscfProgramNestedFilter
    program_exists: Boolean
    registrationsCloseAt: CmsDateTime
    registrationsCloseAt_exists: Boolean
    registrationsCloseAt_gt: CmsDateTime
    registrationsCloseAt_gte: CmsDateTime
    registrationsCloseAt_in: [CmsDateTime]
    registrationsCloseAt_lt: CmsDateTime
    registrationsCloseAt_lte: CmsDateTime
    registrationsCloseAt_not: CmsDateTime
    registrationsCloseAt_not_in: [CmsDateTime]
    registrationsOpenAt: CmsDateTime
    registrationsOpenAt_exists: Boolean
    registrationsOpenAt_gt: CmsDateTime
    registrationsOpenAt_gte: CmsDateTime
    registrationsOpenAt_in: [CmsDateTime]
    registrationsOpenAt_lt: CmsDateTime
    registrationsOpenAt_lte: CmsDateTime
    registrationsOpenAt_not: CmsDateTime
    registrationsOpenAt_not_in: [CmsDateTime]
    startsAt: CmsDateTime
    startsAt_exists: Boolean
    startsAt_gt: CmsDateTime
    startsAt_gte: CmsDateTime
    startsAt_in: [CmsDateTime]
    startsAt_lt: CmsDateTime
    startsAt_lte: CmsDateTime
    startsAt_not: CmsDateTime
    startsAt_not_in: [CmsDateTime]
    statEventCount: Int
    statEventCount_exists: Boolean
    statEventCount_gt: Int
    statEventCount_gte: Int
    statEventCount_in: [Int]
    statEventCount_lt: Int
    statEventCount_lte: Int
    statEventCount_not: Int
    statEventCount_not_in: [Int]
    statLowInterestContinuedCount: Int
    statLowInterestContinuedCount_exists: Boolean
    statLowInterestContinuedCount_gt: Int
    statLowInterestContinuedCount_gte: Int
    statLowInterestContinuedCount_in: [Int]
    statLowInterestContinuedCount_lt: Int
    statLowInterestContinuedCount_lte: Int
    statLowInterestContinuedCount_not: Int
    statLowInterestContinuedCount_not_in: [Int]
    statLowInterestCount: Int
    statLowInterestCount_exists: Boolean
    statLowInterestCount_gt: Int
    statLowInterestCount_gte: Int
    statLowInterestCount_in: [Int]
    statLowInterestCount_lt: Int
    statLowInterestCount_lte: Int
    statLowInterestCount_not: Int
    statLowInterestCount_not_in: [Int]
    statStudentCount: Int
    statStudentCount_exists: Boolean
    statStudentCount_gt: Int
    statStudentCount_gte: Int
    statStudentCount_in: [Int]
    statStudentCount_lt: Int
    statStudentCount_lte: Int
    statStudentCount_not: Int
    statStudentCount_not_in: [Int]
    sys: CmsSysFilter
    theme: String
    themeBackgroundsCollection_exists: Boolean
    themeLogoBackgroundsCollection_exists: Boolean
    theme_contains: String
    theme_exists: Boolean
    theme_in: [String]
    theme_not: String
    theme_not_contains: String
    theme_not_in: [String]
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmsFaqFilter {
    AND: [CmsFaqFilter]
    OR: [CmsFaqFilter]
    answer_contains: String
    answer_exists: Boolean
    answer_not_contains: String
    audience_contains_all: [String]
    audience_contains_none: [String]
    audience_contains_some: [String]
    audience_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    featured: Boolean
    featured_exists: Boolean
    featured_not: Boolean
    program: CmscfProgramNestedFilter
    program_exists: Boolean
    relatedAnswersCollection_exists: Boolean
    sys: CmsSysFilter
    tags_contains_all: [String]
    tags_contains_none: [String]
    tags_contains_some: [String]
    tags_exists: Boolean
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmsFormFilter {
    AND: [CmsFormFilter]
    OR: [CmsFormFilter]
    cognitoForm: Int
    cognitoForm_exists: Boolean
    cognitoForm_gt: Int
    cognitoForm_gte: Int
    cognitoForm_in: [Int]
    cognitoForm_lt: Int
    cognitoForm_lte: Int
    cognitoForm_not: Int
    cognitoForm_not_in: [Int]
    contentfulMetadata: CmsContentfulMetadataFilter
    details_contains: String
    details_exists: Boolean
    details_not_contains: String
    image_exists: Boolean
    sidebar_contains: String
    sidebar_exists: Boolean
    sidebar_not_contains: String
    slug: String
    slug_contains: String
    slug_exists: Boolean
    slug_in: [String]
    slug_not: String
    slug_not_contains: String
    slug_not_in: [String]
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmsGlobalSponsorFilter {
    AND: [CmsGlobalSponsorFilter]
    OR: [CmsGlobalSponsorFilter]
    audio_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    instagramUsername: String
    instagramUsername_contains: String
    instagramUsername_exists: Boolean
    instagramUsername_in: [String]
    instagramUsername_not: String
    instagramUsername_not_contains: String
    instagramUsername_not_in: [String]
    link: String
    link_contains: String
    link_exists: Boolean
    link_in: [String]
    link_not: String
    link_not_contains: String
    link_not_in: [String]
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    perks: String
    perks_contains: String
    perks_exists: Boolean
    perks_in: [String]
    perks_not: String
    perks_not_contains: String
    perks_not_in: [String]
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: CmsSysFilter
    twitterUsername: String
    twitterUsername_contains: String
    twitterUsername_exists: Boolean
    twitterUsername_in: [String]
    twitterUsername_not: String
    twitterUsername_not_contains: String
    twitterUsername_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
}

input CmsHiringCompanyFilter {
    AND: [CmsHiringCompanyFilter]
    OR: [CmsHiringCompanyFilter]
    alumniReferrals_contains_all: [String]
    alumniReferrals_contains_none: [String]
    alumniReferrals_contains_some: [String]
    alumniReferrals_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description_contains: String
    description_exists: Boolean
    description_not_contains: String
    featured: Boolean
    featured_exists: Boolean
    featured_not: Boolean
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    relatedSponsor: CmscfGlobalSponsorNestedFilter
    relatedSponsor_exists: Boolean
    sys: CmsSysFilter
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
}

input CmsHiringPostFilter {
    AND: [CmsHiringPostFilter]
    OR: [CmsHiringPostFilter]
    company: CmscfHiringCompanyNestedFilter
    company_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description_contains: String
    description_exists: Boolean
    description_not_contains: String
    paid: Boolean
    paid_exists: Boolean
    paid_not: Boolean
    regionsCollection_exists: Boolean
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
}

input CmsImageTransformOptions {
    """

    Desired background color, used with corner radius or `PAD` resize strategy.
    Defaults to transparent (for `PNG`, `PNG8` and `WEBP`) or white (for `JPG` and `JPG_PROGRESSIVE`).
    """
    backgroundColor: CmsHexColor
    """

    Desired corner radius in pixels.
    Results in an image with rounded corners (pass `-1` for a full circle/ellipse).
    Defaults to `0`. Uses desired background color as padding color,
    unless the format is `JPG` or `JPG_PROGRESSIVE` and resize strategy is `PAD`, then defaults to white.
    """
    cornerRadius: Int
    "Desired image format. Defaults to the original image format."
    format: CmsImageFormat
    "Desired height in pixels. Defaults to the original image height."
    height: CmsDimension
    """

    Desired quality of the image in percents.
    Used for `PNG8`, `JPG`, `JPG_PROGRESSIVE` and `WEBP` formats.
    """
    quality: CmsQuality
    "Desired resize focus area. Defaults to `CENTER`."
    resizeFocus: CmsImageResizeFocus
    "Desired resize strategy. Defaults to `FIT`."
    resizeStrategy: CmsImageResizeStrategy
    "Desired width in pixels. Defaults to the original image width."
    width: CmsDimension
}

input CmsLegalDocumentFilter {
    AND: [CmsLegalDocumentFilter]
    OR: [CmsLegalDocumentFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    date: CmsDateTime
    date_exists: Boolean
    date_gt: CmsDateTime
    date_gte: CmsDateTime
    date_in: [CmsDateTime]
    date_lt: CmsDateTime
    date_lte: CmsDateTime
    date_not: CmsDateTime
    date_not_in: [CmsDateTime]
    file_exists: Boolean
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
}

input CmsNewsCoverageFilter {
    AND: [CmsNewsCoverageFilter]
    OR: [CmsNewsCoverageFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    date: CmsDateTime
    date_exists: Boolean
    date_gt: CmsDateTime
    date_gte: CmsDateTime
    date_in: [CmsDateTime]
    date_lt: CmsDateTime
    date_lte: CmsDateTime
    date_not: CmsDateTime
    date_not_in: [CmsDateTime]
    featured: Boolean
    featured_exists: Boolean
    featured_not: Boolean
    publicationLogo_exists: Boolean
    publicationName: String
    publicationName_contains: String
    publicationName_exists: Boolean
    publicationName_in: [String]
    publicationName_not: String
    publicationName_not_contains: String
    publicationName_not_in: [String]
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
}

input CmsPressPhotoFilter {
    AND: [CmsPressPhotoFilter]
    OR: [CmsPressPhotoFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    event: CmscfEventNestedFilter
    event_exists: Boolean
    photo_exists: Boolean
    region: CmscfRegionNestedFilter
    region_exists: Boolean
    subProgram: CmscfProgramNestedFilter
    subProgram_exists: Boolean
    sys: CmsSysFilter
    tags_contains_all: [String]
    tags_contains_none: [String]
    tags_contains_some: [String]
    tags_exists: Boolean
}

input CmsProgramFilter {
    AND: [CmsProgramFilter]
    OR: [CmsProgramFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    educationDetails_contains: String
    educationDetails_exists: Boolean
    educationDetails_not_contains: String
    eligibility_contains: String
    eligibility_exists: Boolean
    eligibility_not_contains: String
    logoWhite_exists: Boolean
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    postersCollection_exists: Boolean
    presentingSponsorsCollection_exists: Boolean
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: CmsSysFilter
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
    virtual: Boolean
    virtual_exists: Boolean
    virtual_not: Boolean
    volunteerBlurb_contains: String
    volunteerBlurb_exists: Boolean
    volunteerBlurb_not_contains: String
    volunteerDetails_contains: String
    volunteerDetails_exists: Boolean
    volunteerDetails_not_contains: String
    volunteerPositions_contains_all: [String]
    volunteerPositions_contains_none: [String]
    volunteerPositions_contains_some: [String]
    volunteerPositions_exists: Boolean
    volunteerRecruitingResourcesCollection_exists: Boolean
    volunteerUrl: String
    volunteerUrl_contains: String
    volunteerUrl_exists: Boolean
    volunteerUrl_in: [String]
    volunteerUrl_not: String
    volunteerUrl_not_contains: String
    volunteerUrl_not_in: [String]
    webname: String
    webname_contains: String
    webname_exists: Boolean
    webname_in: [String]
    webname_not: String
    webname_not_contains: String
    webname_not_in: [String]
}

input CmsRegionFilter {
    AND: [CmsRegionFilter]
    OR: [CmsRegionFilter]
    abbr: String
    abbr_contains: String
    abbr_exists: Boolean
    abbr_in: [String]
    abbr_not: String
    abbr_not_contains: String
    abbr_not_in: [String]
    accountingName: String
    accountingName_contains: String
    accountingName_exists: Boolean
    accountingName_in: [String]
    accountingName_not: String
    accountingName_not_contains: String
    accountingName_not_in: [String]
    aliases_contains_all: [String]
    aliases_contains_none: [String]
    aliases_contains_some: [String]
    aliases_exists: Boolean
    complication_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    location_exists: Boolean
    location_within_circle: CmsCircle
    location_within_rectangle: CmsRectangle
    motto: String
    motto_contains: String
    motto_exists: Boolean
    motto_in: [String]
    motto_not: String
    motto_not_contains: String
    motto_not_in: [String]
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    primaryColor: String
    primaryColor_contains: String
    primaryColor_exists: Boolean
    primaryColor_in: [String]
    primaryColor_not: String
    primaryColor_not_contains: String
    primaryColor_not_in: [String]
    regionPhotosCollection_exists: Boolean
    skylinePhoto_exists: Boolean
    stickerLarge_exists: Boolean
    stickerSmall_exists: Boolean
    sys: CmsSysFilter
    timezone: String
    timezone_contains: String
    timezone_exists: Boolean
    timezone_in: [String]
    timezone_not: String
    timezone_not_contains: String
    timezone_not_in: [String]
    webname: String
    webname_contains: String
    webname_exists: Boolean
    webname_in: [String]
    webname_not: String
    webname_not_contains: String
    webname_not_in: [String]
}

input CmsSiteFilter {
    AND: [CmsSiteFilter]
    OR: [CmsSiteFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    display_contains_all: [String]
    display_contains_none: [String]
    display_contains_some: [String]
    display_exists: Boolean
    link: String
    link_contains: String
    link_exists: Boolean
    link_in: [String]
    link_not: String
    link_not_contains: String
    link_not_in: [String]
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
}

input CmsStockMusicFilter {
    AND: [CmsStockMusicFilter]
    OR: [CmsStockMusicFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    music_exists: Boolean
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmsSysFilter {
    firstPublishedAt: CmsDateTime
    firstPublishedAt_exists: Boolean
    firstPublishedAt_gt: CmsDateTime
    firstPublishedAt_gte: CmsDateTime
    firstPublishedAt_in: [CmsDateTime]
    firstPublishedAt_lt: CmsDateTime
    firstPublishedAt_lte: CmsDateTime
    firstPublishedAt_not: CmsDateTime
    firstPublishedAt_not_in: [CmsDateTime]
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    publishedAt: CmsDateTime
    publishedAt_exists: Boolean
    publishedAt_gt: CmsDateTime
    publishedAt_gte: CmsDateTime
    publishedAt_in: [CmsDateTime]
    publishedAt_lt: CmsDateTime
    publishedAt_lte: CmsDateTime
    publishedAt_not: CmsDateTime
    publishedAt_not_in: [CmsDateTime]
    publishedVersion: Float
    publishedVersion_exists: Boolean
    publishedVersion_gt: Float
    publishedVersion_gte: Float
    publishedVersion_in: [Float]
    publishedVersion_lt: Float
    publishedVersion_lte: Float
    publishedVersion_not: Float
    publishedVersion_not_in: [Float]
}

input CmsTestimonialFilter {
    AND: [CmsTestimonialFilter]
    OR: [CmsTestimonialFilter]
    company: String
    company_contains: String
    company_exists: Boolean
    company_in: [String]
    company_not: String
    company_not_contains: String
    company_not_in: [String]
    contentfulMetadata: CmsContentfulMetadataFilter
    experience: String
    experience_contains: String
    experience_exists: Boolean
    experience_in: [String]
    experience_not: String
    experience_not_contains: String
    experience_not_in: [String]
    featured: Boolean
    featured_exists: Boolean
    featured_not: Boolean
    firstName: String
    firstName_contains: String
    firstName_exists: Boolean
    firstName_in: [String]
    firstName_not: String
    firstName_not_contains: String
    firstName_not_in: [String]
    groupName: String
    groupName_contains: String
    groupName_exists: Boolean
    groupName_in: [String]
    groupName_not: String
    groupName_not_contains: String
    groupName_not_in: [String]
    image_exists: Boolean
    lastName: String
    lastName_contains: String
    lastName_exists: Boolean
    lastName_in: [String]
    lastName_not: String
    lastName_not_contains: String
    lastName_not_in: [String]
    program: CmscfProgramNestedFilter
    program_exists: Boolean
    quote: String
    quote_contains: String
    quote_exists: Boolean
    quote_in: [String]
    quote_not: String
    quote_not_contains: String
    quote_not_in: [String]
    region: CmscfRegionNestedFilter
    region_exists: Boolean
    sys: CmsSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
    video_exists: Boolean
}

input CmscfEventNestedFilter {
    AND: [CmscfEventNestedFilter]
    OR: [CmscfEventNestedFilter]
    awardsAt: CmsDateTime
    awardsAt_exists: Boolean
    awardsAt_gt: CmsDateTime
    awardsAt_gte: CmsDateTime
    awardsAt_in: [CmsDateTime]
    awardsAt_lt: CmsDateTime
    awardsAt_lte: CmsDateTime
    awardsAt_not: CmsDateTime
    awardsAt_not_in: [CmsDateTime]
    calendarReleaseDate: CmsDateTime
    calendarReleaseDate_exists: Boolean
    calendarReleaseDate_gt: CmsDateTime
    calendarReleaseDate_gte: CmsDateTime
    calendarReleaseDate_in: [CmsDateTime]
    calendarReleaseDate_lt: CmsDateTime
    calendarReleaseDate_lte: CmsDateTime
    calendarReleaseDate_not: CmsDateTime
    calendarReleaseDate_not_in: [CmsDateTime]
    contentfulMetadata: CmsContentfulMetadataFilter
    endsAt: CmsDateTime
    endsAt_exists: Boolean
    endsAt_gt: CmsDateTime
    endsAt_gte: CmsDateTime
    endsAt_in: [CmsDateTime]
    endsAt_lt: CmsDateTime
    endsAt_lte: CmsDateTime
    endsAt_not: CmsDateTime
    endsAt_not_in: [CmsDateTime]
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    kickoffVideoCaptions_exists: Boolean
    kickoffVideo_exists: Boolean
    notice_contains: String
    notice_exists: Boolean
    notice_not_contains: String
    participantRoleId: String
    participantRoleId_contains: String
    participantRoleId_exists: Boolean
    participantRoleId_in: [String]
    participantRoleId_not: String
    participantRoleId_not_contains: String
    participantRoleId_not_in: [String]
    postersCollection_exists: Boolean
    program_exists: Boolean
    registrationsCloseAt: CmsDateTime
    registrationsCloseAt_exists: Boolean
    registrationsCloseAt_gt: CmsDateTime
    registrationsCloseAt_gte: CmsDateTime
    registrationsCloseAt_in: [CmsDateTime]
    registrationsCloseAt_lt: CmsDateTime
    registrationsCloseAt_lte: CmsDateTime
    registrationsCloseAt_not: CmsDateTime
    registrationsCloseAt_not_in: [CmsDateTime]
    registrationsOpenAt: CmsDateTime
    registrationsOpenAt_exists: Boolean
    registrationsOpenAt_gt: CmsDateTime
    registrationsOpenAt_gte: CmsDateTime
    registrationsOpenAt_in: [CmsDateTime]
    registrationsOpenAt_lt: CmsDateTime
    registrationsOpenAt_lte: CmsDateTime
    registrationsOpenAt_not: CmsDateTime
    registrationsOpenAt_not_in: [CmsDateTime]
    startsAt: CmsDateTime
    startsAt_exists: Boolean
    startsAt_gt: CmsDateTime
    startsAt_gte: CmsDateTime
    startsAt_in: [CmsDateTime]
    startsAt_lt: CmsDateTime
    startsAt_lte: CmsDateTime
    startsAt_not: CmsDateTime
    startsAt_not_in: [CmsDateTime]
    statEventCount: Int
    statEventCount_exists: Boolean
    statEventCount_gt: Int
    statEventCount_gte: Int
    statEventCount_in: [Int]
    statEventCount_lt: Int
    statEventCount_lte: Int
    statEventCount_not: Int
    statEventCount_not_in: [Int]
    statLowInterestContinuedCount: Int
    statLowInterestContinuedCount_exists: Boolean
    statLowInterestContinuedCount_gt: Int
    statLowInterestContinuedCount_gte: Int
    statLowInterestContinuedCount_in: [Int]
    statLowInterestContinuedCount_lt: Int
    statLowInterestContinuedCount_lte: Int
    statLowInterestContinuedCount_not: Int
    statLowInterestContinuedCount_not_in: [Int]
    statLowInterestCount: Int
    statLowInterestCount_exists: Boolean
    statLowInterestCount_gt: Int
    statLowInterestCount_gte: Int
    statLowInterestCount_in: [Int]
    statLowInterestCount_lt: Int
    statLowInterestCount_lte: Int
    statLowInterestCount_not: Int
    statLowInterestCount_not_in: [Int]
    statStudentCount: Int
    statStudentCount_exists: Boolean
    statStudentCount_gt: Int
    statStudentCount_gte: Int
    statStudentCount_in: [Int]
    statStudentCount_lt: Int
    statStudentCount_lte: Int
    statStudentCount_not: Int
    statStudentCount_not_in: [Int]
    sys: CmsSysFilter
    theme: String
    themeBackgroundsCollection_exists: Boolean
    themeLogoBackgroundsCollection_exists: Boolean
    theme_contains: String
    theme_exists: Boolean
    theme_in: [String]
    theme_not: String
    theme_not_contains: String
    theme_not_in: [String]
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
}

input CmscfGlobalSponsorNestedFilter {
    AND: [CmscfGlobalSponsorNestedFilter]
    OR: [CmscfGlobalSponsorNestedFilter]
    audio_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    instagramUsername: String
    instagramUsername_contains: String
    instagramUsername_exists: Boolean
    instagramUsername_in: [String]
    instagramUsername_not: String
    instagramUsername_not_contains: String
    instagramUsername_not_in: [String]
    link: String
    link_contains: String
    link_exists: Boolean
    link_in: [String]
    link_not: String
    link_not_contains: String
    link_not_in: [String]
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    perks: String
    perks_contains: String
    perks_exists: Boolean
    perks_in: [String]
    perks_not: String
    perks_not_contains: String
    perks_not_in: [String]
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: CmsSysFilter
    twitterUsername: String
    twitterUsername_contains: String
    twitterUsername_exists: Boolean
    twitterUsername_in: [String]
    twitterUsername_not: String
    twitterUsername_not_contains: String
    twitterUsername_not_in: [String]
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
}

input CmscfHiringCompanyNestedFilter {
    AND: [CmscfHiringCompanyNestedFilter]
    OR: [CmscfHiringCompanyNestedFilter]
    alumniReferrals_contains_all: [String]
    alumniReferrals_contains_none: [String]
    alumniReferrals_contains_some: [String]
    alumniReferrals_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    description_contains: String
    description_exists: Boolean
    description_not_contains: String
    featured: Boolean
    featured_exists: Boolean
    featured_not: Boolean
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    relatedSponsor_exists: Boolean
    sys: CmsSysFilter
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
}

input CmscfProgramNestedFilter {
    AND: [CmscfProgramNestedFilter]
    OR: [CmscfProgramNestedFilter]
    contentfulMetadata: CmsContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    educationDetails_contains: String
    educationDetails_exists: Boolean
    educationDetails_not_contains: String
    eligibility_contains: String
    eligibility_exists: Boolean
    eligibility_not_contains: String
    logoWhite_exists: Boolean
    logo_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    postersCollection_exists: Boolean
    presentingSponsorsCollection_exists: Boolean
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: CmsSysFilter
    type: String
    type_contains: String
    type_exists: Boolean
    type_in: [String]
    type_not: String
    type_not_contains: String
    type_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
    virtual: Boolean
    virtual_exists: Boolean
    virtual_not: Boolean
    volunteerBlurb_contains: String
    volunteerBlurb_exists: Boolean
    volunteerBlurb_not_contains: String
    volunteerDetails_contains: String
    volunteerDetails_exists: Boolean
    volunteerDetails_not_contains: String
    volunteerPositions_contains_all: [String]
    volunteerPositions_contains_none: [String]
    volunteerPositions_contains_some: [String]
    volunteerPositions_exists: Boolean
    volunteerRecruitingResourcesCollection_exists: Boolean
    volunteerUrl: String
    volunteerUrl_contains: String
    volunteerUrl_exists: Boolean
    volunteerUrl_in: [String]
    volunteerUrl_not: String
    volunteerUrl_not_contains: String
    volunteerUrl_not_in: [String]
    webname: String
    webname_contains: String
    webname_exists: Boolean
    webname_in: [String]
    webname_not: String
    webname_not_contains: String
    webname_not_in: [String]
}

input CmscfRegionNestedFilter {
    AND: [CmscfRegionNestedFilter]
    OR: [CmscfRegionNestedFilter]
    abbr: String
    abbr_contains: String
    abbr_exists: Boolean
    abbr_in: [String]
    abbr_not: String
    abbr_not_contains: String
    abbr_not_in: [String]
    accountingName: String
    accountingName_contains: String
    accountingName_exists: Boolean
    accountingName_in: [String]
    accountingName_not: String
    accountingName_not_contains: String
    accountingName_not_in: [String]
    aliases_contains_all: [String]
    aliases_contains_none: [String]
    aliases_contains_some: [String]
    aliases_exists: Boolean
    complication_exists: Boolean
    contentfulMetadata: CmsContentfulMetadataFilter
    location_exists: Boolean
    location_within_circle: CmsCircle
    location_within_rectangle: CmsRectangle
    motto: String
    motto_contains: String
    motto_exists: Boolean
    motto_in: [String]
    motto_not: String
    motto_not_contains: String
    motto_not_in: [String]
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    primaryColor: String
    primaryColor_contains: String
    primaryColor_exists: Boolean
    primaryColor_in: [String]
    primaryColor_not: String
    primaryColor_not_contains: String
    primaryColor_not_in: [String]
    regionPhotosCollection_exists: Boolean
    skylinePhoto_exists: Boolean
    stickerLarge_exists: Boolean
    stickerSmall_exists: Boolean
    sys: CmsSysFilter
    timezone: String
    timezone_contains: String
    timezone_exists: Boolean
    timezone_in: [String]
    timezone_not: String
    timezone_not_contains: String
    timezone_not_in: [String]
    webname: String
    webname_contains: String
    webname_exists: Boolean
    webname_in: [String]
    webname_not: String
    webname_not_contains: String
    webname_not_in: [String]
}

input LabsGtLtEq {
    eq: Float
    gt: Float
    gte: Float
    lt: Float
    lte: Float
}

input LabsIdOrUsernameInput {
    id: String
    username: String
}

input LabsMentorApplyInput {
    email: String!
    givenName: String!
    maxWeeks: Int
    profile: LabsJSONObject
    projects: [LabsProjectCreateInput!]!
    surname: String!
}

input LabsMentorCreateInput {
    email: String!
    givenName: String!
    maxWeeks: Int
    profile: LabsJSONObject
    status: LabsMentorStatus
    surname: String!
    username: String
}

input LabsMentorEditInput {
    email: String
    givenName: String
    managerUsername: String
    maxWeeks: Int
    profile: LabsJSONObject
    status: LabsMentorStatus
    surname: String
    username: String
}

input LabsMentorFilterInput {
    assignedToManager: String
    inStatus: LabsMentorStatus
    studentWeeks: LabsGtLtEq
    track: LabsTrack
    weeksGte: Float
    withProjects: Boolean
}

input LabsProjectCreateInput {
    deliverables: String
    description: String
    maxStudents: Int
    tags: [String!]
    track: LabsTrack!
}

input LabsProjectEditInput {
    deliverables: String
    description: String
    maxStudents: Int
    status: LabsProjectStatus
    tags: [String!]
    track: LabsTrack
}

input LabsStudentApplyInput {
    email: String!
    givenName: String!
    minHours: Int!
    partnerCode: String
    profile: LabsJSONObject
    surname: String!
    tags: [String!]
    track: LabsTrack!
}

input LabsStudentCreateInput {
    email: String!
    givenName: String!
    minHours: Int!
    partnerCode: String
    profile: LabsJSONObject
    status: LabsStudentStatus
    surname: String!
    tags: [String!]
    track: LabsTrack!
    username: String!
    weeks: Int
}

input LabsStudentEditInput {
    email: String
    givenName: String
    minHours: Int
    partnerCode: String
    profile: LabsJSONObject
    status: LabsStudentStatus
    surname: String
    tags: [String!]
    track: LabsTrack
    username: String
    weeks: Int
}

input LabsStudentFilterInput {
    email: String
    givenName: String
    inStatus: LabsStudentStatus
    partnerCode: String
    surname: String
    track: LabsTrack
    weeks: LabsGtLtEq
    withProjects: Boolean
}

input LabsTagCreateInput {
    id: String!
    mentorDisplayName: String!
    studentDisplayName: String!
    trainingLink: String
    type: LabsTagType!
}

input LabsTagEditInput {
    mentorDisplayName: String
    studentDisplayName: String
    trainingLink: String
    type: LabsTagType
}

input LearnAssetFilter {
    AND: [LearnAssetFilter]
    OR: [LearnAssetFilter]
    contentType: String
    contentType_contains: String
    contentType_exists: Boolean
    contentType_in: [String]
    contentType_not: String
    contentType_not_contains: String
    contentType_not_in: [String]
    contentfulMetadata: LearnContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    fileName: String
    fileName_contains: String
    fileName_exists: Boolean
    fileName_in: [String]
    fileName_not: String
    fileName_not_contains: String
    fileName_not_in: [String]
    height: Int
    height_exists: Boolean
    height_gt: Int
    height_gte: Int
    height_in: [Int]
    height_lt: Int
    height_lte: Int
    height_not: Int
    height_not_in: [Int]
    size: Int
    size_exists: Boolean
    size_gt: Int
    size_gte: Int
    size_in: [Int]
    size_lt: Int
    size_lte: Int
    size_not: Int
    size_not_in: [Int]
    sys: LearnSysFilter
    title: String
    title_contains: String
    title_exists: Boolean
    title_in: [String]
    title_not: String
    title_not_contains: String
    title_not_in: [String]
    url: String
    url_contains: String
    url_exists: Boolean
    url_in: [String]
    url_not: String
    url_not_contains: String
    url_not_in: [String]
    width: Int
    width_exists: Boolean
    width_gt: Int
    width_gte: Int
    width_in: [Int]
    width_lt: Int
    width_lte: Int
    width_not: Int
    width_not_in: [Int]
}

input LearnCodeBlockFilter {
    AND: [LearnCodeBlockFilter]
    OR: [LearnCodeBlockFilter]
    code: String
    code_contains: String
    code_exists: Boolean
    code_in: [String]
    code_not: String
    code_not_contains: String
    code_not_in: [String]
    contentfulMetadata: LearnContentfulMetadataFilter
    language: String
    language_contains: String
    language_exists: Boolean
    language_in: [String]
    language_not: String
    language_not_contains: String
    language_not_in: [String]
    sys: LearnSysFilter
}

input LearnContentfulMetadataFilter {
    tags: LearnContentfulMetadataTagsFilter
    tags_exists: Boolean
}

input LearnContentfulMetadataTagsFilter {
    id_contains_all: [String]
    id_contains_none: [String]
    id_contains_some: [String]
}

input LearnDifficultyFilter {
    AND: [LearnDifficultyFilter]
    OR: [LearnDifficultyFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    hexCodeColor: String
    hexCodeColor_contains: String
    hexCodeColor_exists: Boolean
    hexCodeColor_in: [String]
    hexCodeColor_not: String
    hexCodeColor_not_contains: String
    hexCodeColor_not_in: [String]
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: LearnSysFilter
}

input LearnEntryFilter {
    AND: [LearnEntryFilter]
    OR: [LearnEntryFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    sys: LearnSysFilter
}

input LearnImageTransformOptions {
    """

    Desired background color, used with corner radius or `PAD` resize strategy.
    Defaults to transparent (for `PNG`, `PNG8` and `WEBP`) or white (for `JPG` and `JPG_PROGRESSIVE`).
    """
    backgroundColor: LearnHexColor
    """

    Desired corner radius in pixels.
    Results in an image with rounded corners (pass `-1` for a full circle/ellipse).
    Defaults to `0`. Uses desired background color as padding color,
    unless the format is `JPG` or `JPG_PROGRESSIVE` and resize strategy is `PAD`, then defaults to white.
    """
    cornerRadius: Int
    "Desired image format. Defaults to the original image format."
    format: LearnImageFormat
    "Desired height in pixels. Defaults to the original image height."
    height: LearnDimension
    """

    Desired quality of the image in percents.
    Used for `PNG8`, `JPG`, `JPG_PROGRESSIVE` and `WEBP` formats.
    """
    quality: LearnQuality
    "Desired resize focus area. Defaults to `CENTER`."
    resizeFocus: LearnImageResizeFocus
    "Desired resize strategy. Defaults to `FIT`."
    resizeStrategy: LearnImageResizeStrategy
    "Desired width in pixels. Defaults to the original image width."
    width: LearnDimension
}

input LearnLessonFilter {
    AND: [LearnLessonFilter]
    OR: [LearnLessonFilter]
    content_contains: String
    content_exists: Boolean
    content_not_contains: String
    contentfulMetadata: LearnContentfulMetadataFilter
    hasNextPage: Boolean
    hasNextPage_exists: Boolean
    hasNextPage_not: Boolean
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    nameHeader: String
    nameHeader_contains: String
    nameHeader_exists: Boolean
    nameHeader_in: [String]
    nameHeader_not: String
    nameHeader_not_contains: String
    nameHeader_not_in: [String]
    pageNumber: Int
    pageNumber_exists: Boolean
    pageNumber_gt: Int
    pageNumber_gte: Int
    pageNumber_in: [Int]
    pageNumber_lt: Int
    pageNumber_lte: Int
    pageNumber_not: Int
    pageNumber_not_in: [Int]
    points: Int
    points_exists: Boolean
    points_gt: Int
    points_gte: Int
    points_in: [Int]
    points_lt: Int
    points_lte: Int
    points_not: Int
    points_not_in: [Int]
    sys: LearnSysFilter
    tags_contains_all: [String]
    tags_contains_none: [String]
    tags_contains_some: [String]
    tags_exists: Boolean
    track: LearncfTrackNestedFilter
    track_exists: Boolean
}

input LearnRewardFilter {
    AND: [LearnRewardFilter]
    OR: [LearnRewardFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: LearnSysFilter
}

input LearnSysFilter {
    firstPublishedAt: LearnDateTime
    firstPublishedAt_exists: Boolean
    firstPublishedAt_gt: LearnDateTime
    firstPublishedAt_gte: LearnDateTime
    firstPublishedAt_in: [LearnDateTime]
    firstPublishedAt_lt: LearnDateTime
    firstPublishedAt_lte: LearnDateTime
    firstPublishedAt_not: LearnDateTime
    firstPublishedAt_not_in: [LearnDateTime]
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    publishedAt: LearnDateTime
    publishedAt_exists: Boolean
    publishedAt_gt: LearnDateTime
    publishedAt_gte: LearnDateTime
    publishedAt_in: [LearnDateTime]
    publishedAt_lt: LearnDateTime
    publishedAt_lte: LearnDateTime
    publishedAt_not: LearnDateTime
    publishedAt_not_in: [LearnDateTime]
    publishedVersion: Float
    publishedVersion_exists: Boolean
    publishedVersion_gt: Float
    publishedVersion_gte: Float
    publishedVersion_in: [Float]
    publishedVersion_lt: Float
    publishedVersion_lte: Float
    publishedVersion_not: Float
    publishedVersion_not_in: [Float]
}

input LearnTechnologyFilter {
    AND: [LearnTechnologyFilter]
    OR: [LearnTechnologyFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    image_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    sys: LearnSysFilter
}

input LearnTrackFilter {
    AND: [LearnTrackFilter]
    OR: [LearnTrackFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    difficulty: LearncfDifficultyNestedFilter
    difficulty_exists: Boolean
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    lessonsCollection_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    previewProjectIds_contains_all: [String]
    previewProjectIds_contains_none: [String]
    previewProjectIds_contains_some: [String]
    previewProjectIds_exists: Boolean
    spotlighted: Boolean
    spotlighted_exists: Boolean
    spotlighted_not: Boolean
    sys: LearnSysFilter
    technologiesCollection_exists: Boolean
}

input LearncfDifficultyNestedFilter {
    AND: [LearncfDifficultyNestedFilter]
    OR: [LearncfDifficultyNestedFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    hexCodeColor: String
    hexCodeColor_contains: String
    hexCodeColor_exists: Boolean
    hexCodeColor_in: [String]
    hexCodeColor_not: String
    hexCodeColor_not_contains: String
    hexCodeColor_not_in: [String]
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    shortDescription: String
    shortDescription_contains: String
    shortDescription_exists: Boolean
    shortDescription_in: [String]
    shortDescription_not: String
    shortDescription_not_contains: String
    shortDescription_not_in: [String]
    sys: LearnSysFilter
}

input LearncfTrackNestedFilter {
    AND: [LearncfTrackNestedFilter]
    OR: [LearncfTrackNestedFilter]
    contentfulMetadata: LearnContentfulMetadataFilter
    description: String
    description_contains: String
    description_exists: Boolean
    description_in: [String]
    description_not: String
    description_not_contains: String
    description_not_in: [String]
    difficulty_exists: Boolean
    id: String
    id_contains: String
    id_exists: Boolean
    id_in: [String]
    id_not: String
    id_not_contains: String
    id_not_in: [String]
    lessonsCollection_exists: Boolean
    name: String
    name_contains: String
    name_exists: Boolean
    name_in: [String]
    name_not: String
    name_not_contains: String
    name_not_in: [String]
    previewProjectIds_contains_all: [String]
    previewProjectIds_contains_none: [String]
    previewProjectIds_contains_some: [String]
    previewProjectIds_exists: Boolean
    spotlighted: Boolean
    spotlighted_exists: Boolean
    spotlighted_not: Boolean
    sys: LearnSysFilter
    technologiesCollection_exists: Boolean
}

input ShowcaseAddReactionsInput {
    count: Float!
    type: ShowcaseReactionType!
}

input ShowcaseCreateJudgingPoolInput {
    eventGroupId: String
    eventId: String
    judgingCriteria: [ShowcaseJudgingCriteriaInput!]!
    name: String!
    programId: String
    regionId: String
}

input ShowcaseCreateProjectInput {
    challengesEncountered: String
    codeLink: String
    description: String
    name: String!
    priorExperience: String
    type: ShowcaseProjectType!
    viewLink: String
}

input ShowcaseEditProjectInput {
    challengesEncountered: String
    codeLink: String
    description: String
    name: String
    priorExperience: String
    slug: String
    type: ShowcaseProjectType
    viewLink: String
}

input ShowcaseJudgingCriteriaInput {
    name: String!
    weight: Float!
}

input ShowcaseProjectsWhere {
    awarded: Boolean
    contains: String
    event: String
    eventGroup: String
    featured: Boolean
    media: ShowcaseMediaFilterType
    mediaTopic: ShowcaseMediaTopic
    program: String
    region: String
    type: ShowcaseProjectType
    user: String
}


"The `Upload` scalar type represents a file upload."
scalar Upload

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z,
compliant with the 'date-time' format outlined in section 5.6 of
the RFC 3339 profile of the ISO 8601 standard for representation
of dates and times using the Gregorian calendar.
"""
scalar CmsDateTime

"The 'Dimension' type represents dimensions as whole numeric values between `1` and `4000`."
scalar CmsDimension

"The 'Quality' type represents quality as whole numeric values between `1` and `100`."
scalar CmsQuality

"The 'HexColor' type represents color in `rgb:ffffff` string format."
scalar CmsHexColor

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar CmsJSON

"The Circle scalar type represents a circle, defined by the coordinates of its center and a radius. The Circle type is used to represent a searchable area together with the '_within_circle' filter."
scalar CmsCircle

"The Rectangle scalar type represents a rectangle, defined by the coordinates of its top left and bottom right corners. The Rectangle type is used to represent a searchable area together with the '_within_rectangle' filter."
scalar CmsRectangle

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar ShowYourWorkDateTime

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar ShowcaseDateTime

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar CalendarDateTime

"The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar CalendarJSONObject

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z,
compliant with the 'date-time' format outlined in section 5.6 of
the RFC 3339 profile of the ISO 8601 standard for representation
of dates and times using the Gregorian calendar.
"""
scalar LearnDateTime

"The 'Dimension' type represents dimensions as whole numeric values between `1` and `4000`."
scalar LearnDimension

"The 'Quality' type represents quality as whole numeric values between `1` and `100`."
scalar LearnQuality

"The 'HexColor' type represents color in `rgb:ffffff` string format."
scalar LearnHexColor

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar LearnJSON

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar LabsDateTime

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar LabsJSON

"The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar LabsJSONObject

"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar ClearDateTime

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar ClearJSON
