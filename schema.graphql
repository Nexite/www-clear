# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

type AffectedRowsOutput {
    count: Int!
}

type AggregateEvent {
    _avg: EventAvgAggregate
    _count: EventCountAggregate
    _max: EventMaxAggregate
    _min: EventMinAggregate
    _sum: EventSumAggregate
}

type AggregateEventGroup {
    _avg: EventGroupAvgAggregate
    _count: EventGroupCountAggregate
    _max: EventGroupMaxAggregate
    _min: EventGroupMinAggregate
    _sum: EventGroupSumAggregate
}

type AggregatePayment {
    _avg: PaymentAvgAggregate
    _count: PaymentCountAggregate
    _max: PaymentMaxAggregate
    _min: PaymentMinAggregate
    _sum: PaymentSumAggregate
}

type AggregatePerson {
    _avg: PersonAvgAggregate
    _count: PersonCountAggregate
    _max: PersonMaxAggregate
    _min: PersonMinAggregate
    _sum: PersonSumAggregate
}

type AggregateSponsor {
    _avg: SponsorAvgAggregate
    _count: SponsorCountAggregate
    _max: SponsorMaxAggregate
    _min: SponsorMinAggregate
    _sum: SponsorSumAggregate
}

type AggregateTicket {
    _count: TicketCountAggregate
    _max: TicketMaxAggregate
    _min: TicketMinAggregate
}

type AggregateVenue {
    _avg: VenueAvgAggregate
    _count: VenueCountAggregate
    _max: VenueMaxAggregate
    _min: VenueMinAggregate
    _sum: VenueSumAggregate
}

type Event {
    createdAt: DateTime!
    displayDate: String!
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    eventGroup: EventGroup!
    eventGroupId: String!
    id: String!
    managers: [String!]!
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    sponsors(cursor: SponsorWhereUniqueInput, distinct: [SponsorScalarFieldEnum!], orderBy: [SponsorOrderByInput!], skip: Int, take: Int, where: SponsorWhereInput): [Sponsor!]!
    startDate: DateTime!
    ticketPrice: Float!
    tickets(cursor: TicketWhereUniqueInput, distinct: [TicketScalarFieldEnum!], orderBy: [TicketOrderByInput!], skip: Int, take: Int, where: TicketWhereInput): [Ticket!]!
    updatedAt: DateTime!
    venue: Venue
    venueId: String
}

type EventAvgAggregate {
    earlyBirdPrice: Float
    ticketPrice: Float
}

type EventCountAggregate {
    _all: Int!
    createdAt: Int!
    earlyBirdCutoff: Int!
    earlyBirdPrice: Int!
    endDate: Int!
    eventGroupId: Int!
    id: Int!
    managers: Int!
    metadata: Int!
    name: Int!
    registrationCutoff: Int!
    startDate: Int!
    ticketPrice: Int!
    updatedAt: Int!
    venueId: Int!
}

type EventGroup {
    createdAt: DateTime!
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    events(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByInput!], skip: Int, take: Int, where: EventWhereInput): [Event!]!
    id: String!
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    startDate: DateTime!
    ticketPrice: Float!
    updatedAt: DateTime!
}

type EventGroupAvgAggregate {
    earlyBirdPrice: Float
    ticketPrice: Float
}

type EventGroupBy {
    _avg: EventAvgAggregate
    _count: EventCountAggregate
    _max: EventMaxAggregate
    _min: EventMinAggregate
    _sum: EventSumAggregate
    createdAt: DateTime!
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    eventGroupId: String!
    id: String!
    managers: [String!]
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    startDate: DateTime!
    ticketPrice: Float!
    updatedAt: DateTime!
    venueId: String
}

type EventGroupCountAggregate {
    _all: Int!
    createdAt: Int!
    earlyBirdCutoff: Int!
    earlyBirdPrice: Int!
    endDate: Int!
    id: Int!
    metadata: Int!
    name: Int!
    registrationCutoff: Int!
    startDate: Int!
    ticketPrice: Int!
    updatedAt: Int!
}

type EventGroupGroupBy {
    _avg: EventGroupAvgAggregate
    _count: EventGroupCountAggregate
    _max: EventGroupMaxAggregate
    _min: EventGroupMinAggregate
    _sum: EventGroupSumAggregate
    createdAt: DateTime!
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    id: String!
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    startDate: DateTime!
    ticketPrice: Float!
    updatedAt: DateTime!
}

type EventGroupMaxAggregate {
    createdAt: DateTime
    earlyBirdCutoff: DateTime
    earlyBirdPrice: Float
    endDate: DateTime
    id: String
    name: String
    registrationCutoff: DateTime
    startDate: DateTime
    ticketPrice: Float
    updatedAt: DateTime
}

type EventGroupMinAggregate {
    createdAt: DateTime
    earlyBirdCutoff: DateTime
    earlyBirdPrice: Float
    endDate: DateTime
    id: String
    name: String
    registrationCutoff: DateTime
    startDate: DateTime
    ticketPrice: Float
    updatedAt: DateTime
}

type EventGroupSumAggregate {
    earlyBirdPrice: Float
    ticketPrice: Float
}

type EventMaxAggregate {
    createdAt: DateTime
    earlyBirdCutoff: DateTime
    earlyBirdPrice: Float
    endDate: DateTime
    eventGroupId: String
    id: String
    name: String
    registrationCutoff: DateTime
    startDate: DateTime
    ticketPrice: Float
    updatedAt: DateTime
    venueId: String
}

type EventMinAggregate {
    createdAt: DateTime
    earlyBirdCutoff: DateTime
    earlyBirdPrice: Float
    endDate: DateTime
    eventGroupId: String
    id: String
    name: String
    registrationCutoff: DateTime
    startDate: DateTime
    ticketPrice: Float
    updatedAt: DateTime
    venueId: String
}

type EventSumAggregate {
    earlyBirdPrice: Float
    ticketPrice: Float
}

type Mutation {
    createEvent(data: EventCreateInput!): Event!
    createEventGroup(data: EventGroupCreateInput!): EventGroup!
    createManyEvent(data: [EventCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyEventGroup(data: [EventGroupCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyPayment(data: [PaymentCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyPerson(data: [PersonCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManySponsor(data: [SponsorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyTicket(data: [TicketCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createManyVenue(data: [VenueCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
    createPayment(data: PaymentCreateInput!): Payment!
    createPerson(data: PersonCreateInput!): Person!
    createSponsor(data: SponsorCreateInput!): Sponsor!
    createTicket(data: TicketCreateInput!): Ticket!
    createVenue(data: VenueCreateInput!): Venue!
    deleteEvent(where: EventWhereUniqueInput!): Event
    deleteEventGroup(where: EventGroupWhereUniqueInput!): EventGroup
    deleteManyEvent(where: EventWhereInput): AffectedRowsOutput!
    deleteManyEventGroup(where: EventGroupWhereInput): AffectedRowsOutput!
    deleteManyPayment(where: PaymentWhereInput): AffectedRowsOutput!
    deleteManyPerson(where: PersonWhereInput): AffectedRowsOutput!
    deleteManySponsor(where: SponsorWhereInput): AffectedRowsOutput!
    deleteManyTicket(where: TicketWhereInput): AffectedRowsOutput!
    deleteManyVenue(where: VenueWhereInput): AffectedRowsOutput!
    deletePayment(where: PaymentWhereUniqueInput!): Payment
    deletePerson(where: PersonWhereUniqueInput!): Person
    deleteSponsor(where: SponsorWhereUniqueInput!): Sponsor
    deleteTicket(where: TicketWhereUniqueInput!): Ticket
    deleteVenue(where: VenueWhereUniqueInput!): Venue
    updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
    updateEventGroup(data: EventGroupUpdateInput!, where: EventGroupWhereUniqueInput!): EventGroup
    updateManyEvent(data: EventUpdateManyMutationInput!, where: EventWhereInput): AffectedRowsOutput!
    updateManyEventGroup(data: EventGroupUpdateManyMutationInput!, where: EventGroupWhereInput): AffectedRowsOutput!
    updateManyPayment(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): AffectedRowsOutput!
    updateManyPerson(data: PersonUpdateManyMutationInput!, where: PersonWhereInput): AffectedRowsOutput!
    updateManySponsor(data: SponsorUpdateManyMutationInput!, where: SponsorWhereInput): AffectedRowsOutput!
    updateManyTicket(data: TicketUpdateManyMutationInput!, where: TicketWhereInput): AffectedRowsOutput!
    updateManyVenue(data: VenueUpdateManyMutationInput!, where: VenueWhereInput): AffectedRowsOutput!
    updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
    updatePerson(data: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person
    updateSponsor(data: SponsorUpdateInput!, where: SponsorWhereUniqueInput!): Sponsor
    updateTicket(data: TicketUpdateInput!, where: TicketWhereUniqueInput!): Ticket
    updateVenue(data: VenueUpdateInput!, where: VenueWhereUniqueInput!): Venue
    upsertEvent(create: EventCreateInput!, update: EventUpdateInput!, where: EventWhereUniqueInput!): Event!
    upsertEventGroup(create: EventGroupCreateInput!, update: EventGroupUpdateInput!, where: EventGroupWhereUniqueInput!): EventGroup!
    upsertPayment(create: PaymentCreateInput!, update: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment!
    upsertPerson(create: PersonCreateInput!, update: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person!
    upsertSponsor(create: SponsorCreateInput!, update: SponsorUpdateInput!, where: SponsorWhereUniqueInput!): Sponsor!
    upsertTicket(create: TicketCreateInput!, update: TicketUpdateInput!, where: TicketWhereUniqueInput!): Ticket!
    upsertVenue(create: VenueCreateInput!, update: VenueUpdateInput!, where: VenueWhereUniqueInput!): Venue!
}

type Payment {
    Ticket(cursor: TicketWhereUniqueInput, distinct: [TicketScalarFieldEnum!], orderBy: [TicketOrderByInput!], skip: Int, take: Int, where: TicketWhereInput): [Ticket!]!
    createdAt: DateTime!
    id: String!
    metadata: JSON
    total: Float!
    updatedAt: DateTime!
}

type PaymentAvgAggregate {
    total: Float
}

type PaymentCountAggregate {
    _all: Int!
    createdAt: Int!
    id: Int!
    metadata: Int!
    total: Int!
    updatedAt: Int!
}

type PaymentGroupBy {
    _avg: PaymentAvgAggregate
    _count: PaymentCountAggregate
    _max: PaymentMaxAggregate
    _min: PaymentMinAggregate
    _sum: PaymentSumAggregate
    createdAt: DateTime!
    id: String!
    metadata: JSON
    total: Float!
    updatedAt: DateTime!
}

type PaymentMaxAggregate {
    createdAt: DateTime
    id: String
    total: Float
    updatedAt: DateTime
}

type PaymentMinAggregate {
    createdAt: DateTime
    id: String
    total: Float
    updatedAt: DateTime
}

type PaymentSumAggregate {
    total: Float
}

type Person {
    Person(cursor: PersonWhereUniqueInput, distinct: [PersonScalarFieldEnum!], orderBy: [PersonOrderByInput!], skip: Int, take: Int, where: PersonWhereInput): [Person!]!
    Venue(cursor: VenueWhereUniqueInput, distinct: [VenueScalarFieldEnum!], orderBy: [VenueOrderByInput!], skip: Int, take: Int, where: VenueWhereInput): [Venue!]!
    age: Int
    createdAt: DateTime!
    email: String!
    firstName: String!
    guardian: Person
    id: String!
    lastName: String!
    metadata: JSON
    personId: String
    phone: String
    tickets(cursor: TicketWhereUniqueInput, distinct: [TicketScalarFieldEnum!], orderBy: [TicketOrderByInput!], skip: Int, take: Int, where: TicketWhereInput): [Ticket!]!
    updatedAt: DateTime!
}

type PersonAvgAggregate {
    age: Float
}

type PersonCountAggregate {
    _all: Int!
    age: Int!
    createdAt: Int!
    email: Int!
    firstName: Int!
    id: Int!
    lastName: Int!
    metadata: Int!
    personId: Int!
    phone: Int!
    updatedAt: Int!
}

type PersonGroupBy {
    _avg: PersonAvgAggregate
    _count: PersonCountAggregate
    _max: PersonMaxAggregate
    _min: PersonMinAggregate
    _sum: PersonSumAggregate
    age: Int
    createdAt: DateTime!
    email: String!
    firstName: String!
    id: String!
    lastName: String!
    metadata: JSON
    personId: String
    phone: String
    updatedAt: DateTime!
}

type PersonMaxAggregate {
    age: Int
    createdAt: DateTime
    email: String
    firstName: String
    id: String
    lastName: String
    personId: String
    phone: String
    updatedAt: DateTime
}

type PersonMinAggregate {
    age: Int
    createdAt: DateTime
    email: String
    firstName: String
    id: String
    lastName: String
    personId: String
    phone: String
    updatedAt: DateTime
}

type PersonSumAggregate {
    age: Int
}

type Query {
    aggregateEvent(cursor: EventWhereUniqueInput, orderBy: [EventOrderByInput!], skip: Int, take: Int, where: EventWhereInput): AggregateEvent!
    aggregateEventGroup(cursor: EventGroupWhereUniqueInput, orderBy: [EventGroupOrderByInput!], skip: Int, take: Int, where: EventGroupWhereInput): AggregateEventGroup!
    aggregatePayment(cursor: PaymentWhereUniqueInput, orderBy: [PaymentOrderByInput!], skip: Int, take: Int, where: PaymentWhereInput): AggregatePayment!
    aggregatePerson(cursor: PersonWhereUniqueInput, orderBy: [PersonOrderByInput!], skip: Int, take: Int, where: PersonWhereInput): AggregatePerson!
    aggregateSponsor(cursor: SponsorWhereUniqueInput, orderBy: [SponsorOrderByInput!], skip: Int, take: Int, where: SponsorWhereInput): AggregateSponsor!
    aggregateTicket(cursor: TicketWhereUniqueInput, orderBy: [TicketOrderByInput!], skip: Int, take: Int, where: TicketWhereInput): AggregateTicket!
    aggregateVenue(cursor: VenueWhereUniqueInput, orderBy: [VenueOrderByInput!], skip: Int, take: Int, where: VenueWhereInput): AggregateVenue!
    event(where: EventWhereUniqueInput!): Event
    eventGroup(where: EventGroupWhereUniqueInput!): EventGroup
    eventGroups(cursor: EventGroupWhereUniqueInput, distinct: [EventGroupScalarFieldEnum!], orderBy: [EventGroupOrderByInput!], skip: Int, take: Int, where: EventGroupWhereInput): [EventGroup!]!
    events(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByInput!], skip: Int, take: Int, where: EventWhereInput): [Event!]!
    findFirstEvent(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByInput!], skip: Int, take: Int, where: EventWhereInput): Event
    findFirstEventGroup(cursor: EventGroupWhereUniqueInput, distinct: [EventGroupScalarFieldEnum!], orderBy: [EventGroupOrderByInput!], skip: Int, take: Int, where: EventGroupWhereInput): EventGroup
    findFirstPayment(cursor: PaymentWhereUniqueInput, distinct: [PaymentScalarFieldEnum!], orderBy: [PaymentOrderByInput!], skip: Int, take: Int, where: PaymentWhereInput): Payment
    findFirstPerson(cursor: PersonWhereUniqueInput, distinct: [PersonScalarFieldEnum!], orderBy: [PersonOrderByInput!], skip: Int, take: Int, where: PersonWhereInput): Person
    findFirstSponsor(cursor: SponsorWhereUniqueInput, distinct: [SponsorScalarFieldEnum!], orderBy: [SponsorOrderByInput!], skip: Int, take: Int, where: SponsorWhereInput): Sponsor
    findFirstTicket(cursor: TicketWhereUniqueInput, distinct: [TicketScalarFieldEnum!], orderBy: [TicketOrderByInput!], skip: Int, take: Int, where: TicketWhereInput): Ticket
    findFirstVenue(cursor: VenueWhereUniqueInput, distinct: [VenueScalarFieldEnum!], orderBy: [VenueOrderByInput!], skip: Int, take: Int, where: VenueWhereInput): Venue
    groupByEvent(by: [EventScalarFieldEnum!]!, having: EventScalarWhereWithAggregatesInput, orderBy: [EventOrderByInput!], skip: Int, take: Int, where: EventWhereInput): [EventGroupBy!]!
    groupByEventGroup(by: [EventGroupScalarFieldEnum!]!, having: EventGroupScalarWhereWithAggregatesInput, orderBy: [EventGroupOrderByInput!], skip: Int, take: Int, where: EventGroupWhereInput): [EventGroupGroupBy!]!
    groupByPayment(by: [PaymentScalarFieldEnum!]!, having: PaymentScalarWhereWithAggregatesInput, orderBy: [PaymentOrderByInput!], skip: Int, take: Int, where: PaymentWhereInput): [PaymentGroupBy!]!
    groupByPerson(by: [PersonScalarFieldEnum!]!, having: PersonScalarWhereWithAggregatesInput, orderBy: [PersonOrderByInput!], skip: Int, take: Int, where: PersonWhereInput): [PersonGroupBy!]!
    groupBySponsor(by: [SponsorScalarFieldEnum!]!, having: SponsorScalarWhereWithAggregatesInput, orderBy: [SponsorOrderByInput!], skip: Int, take: Int, where: SponsorWhereInput): [SponsorGroupBy!]!
    groupByTicket(by: [TicketScalarFieldEnum!]!, having: TicketScalarWhereWithAggregatesInput, orderBy: [TicketOrderByInput!], skip: Int, take: Int, where: TicketWhereInput): [TicketGroupBy!]!
    groupByVenue(by: [VenueScalarFieldEnum!]!, having: VenueScalarWhereWithAggregatesInput, orderBy: [VenueOrderByInput!], skip: Int, take: Int, where: VenueWhereInput): [VenueGroupBy!]!
    payment(where: PaymentWhereUniqueInput!): Payment
    payments(cursor: PaymentWhereUniqueInput, distinct: [PaymentScalarFieldEnum!], orderBy: [PaymentOrderByInput!], skip: Int, take: Int, where: PaymentWhereInput): [Payment!]!
    people(cursor: PersonWhereUniqueInput, distinct: [PersonScalarFieldEnum!], orderBy: [PersonOrderByInput!], skip: Int, take: Int, where: PersonWhereInput): [Person!]!
    person(where: PersonWhereUniqueInput!): Person
    sponsor(where: SponsorWhereUniqueInput!): Sponsor
    sponsors(cursor: SponsorWhereUniqueInput, distinct: [SponsorScalarFieldEnum!], orderBy: [SponsorOrderByInput!], skip: Int, take: Int, where: SponsorWhereInput): [Sponsor!]!
    ticket(where: TicketWhereUniqueInput!): Ticket
    tickets(cursor: TicketWhereUniqueInput, distinct: [TicketScalarFieldEnum!], orderBy: [TicketOrderByInput!], skip: Int, take: Int, where: TicketWhereInput): [Ticket!]!
    venue(where: VenueWhereUniqueInput!): Venue
    venues(cursor: VenueWhereUniqueInput, distinct: [VenueScalarFieldEnum!], orderBy: [VenueOrderByInput!], skip: Int, take: Int, where: VenueWhereInput): [Venue!]!
}

type Sponsor {
    Event: Event
    amount: Int!
    createdAt: DateTime!
    eventId: String
    id: String!
    logoImageUri: String!
    metadata: JSON
    name: String!
    updatedAt: DateTime!
}

type SponsorAvgAggregate {
    amount: Float
}

type SponsorCountAggregate {
    _all: Int!
    amount: Int!
    createdAt: Int!
    eventId: Int!
    id: Int!
    logoImageUri: Int!
    metadata: Int!
    name: Int!
    updatedAt: Int!
}

type SponsorGroupBy {
    _avg: SponsorAvgAggregate
    _count: SponsorCountAggregate
    _max: SponsorMaxAggregate
    _min: SponsorMinAggregate
    _sum: SponsorSumAggregate
    amount: Int!
    createdAt: DateTime!
    eventId: String
    id: String!
    logoImageUri: String!
    metadata: JSON
    name: String!
    updatedAt: DateTime!
}

type SponsorMaxAggregate {
    amount: Int
    createdAt: DateTime
    eventId: String
    id: String
    logoImageUri: String
    name: String
    updatedAt: DateTime
}

type SponsorMinAggregate {
    amount: Int
    createdAt: DateTime
    eventId: String
    id: String
    logoImageUri: String
    name: String
    updatedAt: DateTime
}

type SponsorSumAggregate {
    amount: Int
}

type Ticket {
    couponCode: String
    createdAt: DateTime!
    event: Event!
    eventId: String!
    id: String!
    metadata: JSON
    payment: Payment
    paymentId: String
    person: Person!
    personId: String!
    type: TicketType!
    updatedAt: DateTime!
    waiverSigned: Boolean!
}

type TicketCountAggregate {
    _all: Int!
    couponCode: Int!
    createdAt: Int!
    eventId: Int!
    id: Int!
    metadata: Int!
    paymentId: Int!
    personId: Int!
    type: Int!
    updatedAt: Int!
    waiverSigned: Int!
}

type TicketGroupBy {
    _count: TicketCountAggregate
    _max: TicketMaxAggregate
    _min: TicketMinAggregate
    couponCode: String
    createdAt: DateTime!
    eventId: String!
    id: String!
    metadata: JSON
    paymentId: String
    personId: String!
    type: TicketType!
    updatedAt: DateTime!
    waiverSigned: Boolean!
}

type TicketMaxAggregate {
    couponCode: String
    createdAt: DateTime
    eventId: String
    id: String
    paymentId: String
    personId: String
    type: TicketType
    updatedAt: DateTime
    waiverSigned: Boolean
}

type TicketMinAggregate {
    couponCode: String
    createdAt: DateTime
    eventId: String
    id: String
    paymentId: String
    personId: String
    type: TicketType
    updatedAt: DateTime
    waiverSigned: Boolean
}

type Venue {
    address: String!
    capacity: Int!
    contact: Person
    createdAt: DateTime!
    events(cursor: EventWhereUniqueInput, distinct: [EventScalarFieldEnum!], orderBy: [EventOrderByInput!], skip: Int, take: Int, where: EventWhereInput): [Event!]!
    id: String!
    mapLink: String!
    metadata: JSON
    name: String!
    personId: String
    updatedAt: DateTime!
}

type VenueAvgAggregate {
    capacity: Float
}

type VenueCountAggregate {
    _all: Int!
    address: Int!
    capacity: Int!
    createdAt: Int!
    id: Int!
    mapLink: Int!
    metadata: Int!
    name: Int!
    personId: Int!
    updatedAt: Int!
}

type VenueGroupBy {
    _avg: VenueAvgAggregate
    _count: VenueCountAggregate
    _max: VenueMaxAggregate
    _min: VenueMinAggregate
    _sum: VenueSumAggregate
    address: String!
    capacity: Int!
    createdAt: DateTime!
    id: String!
    mapLink: String!
    metadata: JSON
    name: String!
    personId: String
    updatedAt: DateTime!
}

type VenueMaxAggregate {
    address: String
    capacity: Int
    createdAt: DateTime
    id: String
    mapLink: String
    name: String
    personId: String
    updatedAt: DateTime
}

type VenueMinAggregate {
    address: String
    capacity: Int
    createdAt: DateTime
    id: String
    mapLink: String
    name: String
    personId: String
    updatedAt: DateTime
}

type VenueSumAggregate {
    capacity: Int
}

enum EventGroupScalarFieldEnum {
    createdAt
    earlyBirdCutoff
    earlyBirdPrice
    endDate
    id
    metadata
    name
    registrationCutoff
    startDate
    ticketPrice
    updatedAt
}

enum EventScalarFieldEnum {
    createdAt
    earlyBirdCutoff
    earlyBirdPrice
    endDate
    eventGroupId
    id
    managers
    metadata
    name
    registrationCutoff
    startDate
    ticketPrice
    updatedAt
    venueId
}

enum PaymentScalarFieldEnum {
    createdAt
    id
    metadata
    total
    updatedAt
}

enum PersonScalarFieldEnum {
    age
    createdAt
    email
    firstName
    id
    lastName
    metadata
    personId
    phone
    updatedAt
}

enum QueryMode {
    default
    insensitive
}

enum SortOrder {
    asc
    desc
}

enum SponsorScalarFieldEnum {
    amount
    createdAt
    eventId
    id
    logoImageUri
    metadata
    name
    updatedAt
}

enum TicketScalarFieldEnum {
    couponCode
    createdAt
    eventId
    id
    metadata
    paymentId
    personId
    type
    updatedAt
    waiverSigned
}

enum TicketType {
    JUDGE
    MENTOR
    STAFF
    STUDENT
    TEACHER
    VIP
}

enum VenueScalarFieldEnum {
    address
    capacity
    createdAt
    id
    mapLink
    metadata
    name
    personId
    updatedAt
}

input BoolFieldUpdateOperationsInput {
    set: Boolean
}

input BoolFilter {
    equals: Boolean
    not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedBoolFilter
    _min: NestedBoolFilter
    equals: Boolean
    not: NestedBoolWithAggregatesFilter
}

input DateTimeFieldUpdateOperationsInput {
    set: DateTime
}

input DateTimeFilter {
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeFilter
    notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedDateTimeFilter
    _min: NestedDateTimeFilter
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeWithAggregatesFilter
    notIn: [DateTime!]
}

input EnumTicketTypeFieldUpdateOperationsInput {
    set: TicketType
}

input EnumTicketTypeFilter {
    equals: TicketType
    in: [TicketType!]
    not: NestedEnumTicketTypeFilter
    notIn: [TicketType!]
}

input EnumTicketTypeWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumTicketTypeFilter
    _min: NestedEnumTicketTypeFilter
    equals: TicketType
    in: [TicketType!]
    not: NestedEnumTicketTypeWithAggregatesFilter
    notIn: [TicketType!]
}

input EventCreateInput {
    createdAt: DateTime
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    eventGroup: EventGroupCreateNestedOneWithoutEventsInput!
    id: String
    managers: EventCreatemanagersInput
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    sponsors: SponsorCreateNestedManyWithoutEventInput
    startDate: DateTime!
    ticketPrice: Float!
    tickets: TicketCreateNestedManyWithoutEventInput
    updatedAt: DateTime
    venue: VenueCreateNestedOneWithoutEventsInput
}

input EventCreateManyEventGroupInput {
    createdAt: DateTime
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    id: String
    managers: EventCreateManymanagersInput
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    startDate: DateTime!
    ticketPrice: Float!
    updatedAt: DateTime
    venueId: String
}

input EventCreateManyEventGroupInputEnvelope {
    data: [EventCreateManyEventGroupInput!]!
    skipDuplicates: Boolean
}

input EventCreateManyInput {
    createdAt: DateTime
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    eventGroupId: String!
    id: String
    managers: EventCreateManymanagersInput
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    startDate: DateTime!
    ticketPrice: Float!
    updatedAt: DateTime
    venueId: String
}

input EventCreateManyVenueInput {
    createdAt: DateTime
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    eventGroupId: String!
    id: String
    managers: EventCreateManymanagersInput
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    startDate: DateTime!
    ticketPrice: Float!
    updatedAt: DateTime
}

input EventCreateManyVenueInputEnvelope {
    data: [EventCreateManyVenueInput!]!
    skipDuplicates: Boolean
}

input EventCreateManymanagersInput {
    set: [String!]!
}

input EventCreateNestedManyWithoutEventGroupInput {
    connect: [EventWhereUniqueInput!]
    connectOrCreate: [EventCreateOrConnectWithoutEventGroupInput!]
    create: [EventCreateWithoutEventGroupInput!]
    createMany: EventCreateManyEventGroupInputEnvelope
}

input EventCreateNestedManyWithoutVenueInput {
    connect: [EventWhereUniqueInput!]
    connectOrCreate: [EventCreateOrConnectWithoutVenueInput!]
    create: [EventCreateWithoutVenueInput!]
    createMany: EventCreateManyVenueInputEnvelope
}

input EventCreateNestedOneWithoutSponsorsInput {
    connect: EventWhereUniqueInput
    connectOrCreate: EventCreateOrConnectWithoutSponsorsInput
    create: EventCreateWithoutSponsorsInput
}

input EventCreateNestedOneWithoutTicketsInput {
    connect: EventWhereUniqueInput
    connectOrCreate: EventCreateOrConnectWithoutTicketsInput
    create: EventCreateWithoutTicketsInput
}

input EventCreateOrConnectWithoutEventGroupInput {
    create: EventCreateWithoutEventGroupInput!
    where: EventWhereUniqueInput!
}

input EventCreateOrConnectWithoutSponsorsInput {
    create: EventCreateWithoutSponsorsInput!
    where: EventWhereUniqueInput!
}

input EventCreateOrConnectWithoutTicketsInput {
    create: EventCreateWithoutTicketsInput!
    where: EventWhereUniqueInput!
}

input EventCreateOrConnectWithoutVenueInput {
    create: EventCreateWithoutVenueInput!
    where: EventWhereUniqueInput!
}

input EventCreateWithoutEventGroupInput {
    createdAt: DateTime
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    id: String
    managers: EventCreatemanagersInput
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    sponsors: SponsorCreateNestedManyWithoutEventInput
    startDate: DateTime!
    ticketPrice: Float!
    tickets: TicketCreateNestedManyWithoutEventInput
    updatedAt: DateTime
    venue: VenueCreateNestedOneWithoutEventsInput
}

input EventCreateWithoutSponsorsInput {
    createdAt: DateTime
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    eventGroup: EventGroupCreateNestedOneWithoutEventsInput!
    id: String
    managers: EventCreatemanagersInput
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    startDate: DateTime!
    ticketPrice: Float!
    tickets: TicketCreateNestedManyWithoutEventInput
    updatedAt: DateTime
    venue: VenueCreateNestedOneWithoutEventsInput
}

input EventCreateWithoutTicketsInput {
    createdAt: DateTime
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    eventGroup: EventGroupCreateNestedOneWithoutEventsInput!
    id: String
    managers: EventCreatemanagersInput
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    sponsors: SponsorCreateNestedManyWithoutEventInput
    startDate: DateTime!
    ticketPrice: Float!
    updatedAt: DateTime
    venue: VenueCreateNestedOneWithoutEventsInput
}

input EventCreateWithoutVenueInput {
    createdAt: DateTime
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    eventGroup: EventGroupCreateNestedOneWithoutEventsInput!
    id: String
    managers: EventCreatemanagersInput
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    sponsors: SponsorCreateNestedManyWithoutEventInput
    startDate: DateTime!
    ticketPrice: Float!
    tickets: TicketCreateNestedManyWithoutEventInput
    updatedAt: DateTime
}

input EventCreatemanagersInput {
    set: [String!]!
}

input EventGroupCreateInput {
    createdAt: DateTime
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    events: EventCreateNestedManyWithoutEventGroupInput
    id: String
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    startDate: DateTime!
    ticketPrice: Float!
    updatedAt: DateTime
}

input EventGroupCreateManyInput {
    createdAt: DateTime
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    id: String
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    startDate: DateTime!
    ticketPrice: Float!
    updatedAt: DateTime
}

input EventGroupCreateNestedOneWithoutEventsInput {
    connect: EventGroupWhereUniqueInput
    connectOrCreate: EventGroupCreateOrConnectWithoutEventsInput
    create: EventGroupCreateWithoutEventsInput
}

input EventGroupCreateOrConnectWithoutEventsInput {
    create: EventGroupCreateWithoutEventsInput!
    where: EventGroupWhereUniqueInput!
}

input EventGroupCreateWithoutEventsInput {
    createdAt: DateTime
    earlyBirdCutoff: DateTime!
    earlyBirdPrice: Float!
    endDate: DateTime!
    id: String
    metadata: JSON
    name: String!
    registrationCutoff: DateTime!
    startDate: DateTime!
    ticketPrice: Float!
    updatedAt: DateTime
}

input EventGroupOrderByInput {
    createdAt: SortOrder
    earlyBirdCutoff: SortOrder
    earlyBirdPrice: SortOrder
    endDate: SortOrder
    id: SortOrder
    metadata: SortOrder
    name: SortOrder
    registrationCutoff: SortOrder
    startDate: SortOrder
    ticketPrice: SortOrder
    updatedAt: SortOrder
}

input EventGroupRelationFilter {
    is: EventGroupWhereInput
    isNot: EventGroupWhereInput
}

input EventGroupScalarWhereWithAggregatesInput {
    AND: [EventGroupScalarWhereWithAggregatesInput!]
    NOT: [EventGroupScalarWhereWithAggregatesInput!]
    OR: [EventGroupScalarWhereWithAggregatesInput!]
    createdAt: DateTimeWithAggregatesFilter
    earlyBirdCutoff: DateTimeWithAggregatesFilter
    earlyBirdPrice: FloatWithAggregatesFilter
    endDate: DateTimeWithAggregatesFilter
    id: StringWithAggregatesFilter
    metadata: JsonNullableWithAggregatesFilter
    name: StringWithAggregatesFilter
    registrationCutoff: DateTimeWithAggregatesFilter
    startDate: DateTimeWithAggregatesFilter
    ticketPrice: FloatWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
}

input EventGroupUpdateInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: DateTimeFieldUpdateOperationsInput
    earlyBirdPrice: FloatFieldUpdateOperationsInput
    endDate: DateTimeFieldUpdateOperationsInput
    events: EventUpdateManyWithoutEventGroupInput
    id: StringFieldUpdateOperationsInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    registrationCutoff: DateTimeFieldUpdateOperationsInput
    startDate: DateTimeFieldUpdateOperationsInput
    ticketPrice: FloatFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input EventGroupUpdateManyMutationInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: DateTimeFieldUpdateOperationsInput
    earlyBirdPrice: FloatFieldUpdateOperationsInput
    endDate: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    registrationCutoff: DateTimeFieldUpdateOperationsInput
    startDate: DateTimeFieldUpdateOperationsInput
    ticketPrice: FloatFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input EventGroupUpdateOneRequiredWithoutEventsInput {
    connect: EventGroupWhereUniqueInput
    connectOrCreate: EventGroupCreateOrConnectWithoutEventsInput
    create: EventGroupCreateWithoutEventsInput
    update: EventGroupUpdateWithoutEventsInput
    upsert: EventGroupUpsertWithoutEventsInput
}

input EventGroupUpdateWithoutEventsInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: DateTimeFieldUpdateOperationsInput
    earlyBirdPrice: FloatFieldUpdateOperationsInput
    endDate: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    registrationCutoff: DateTimeFieldUpdateOperationsInput
    startDate: DateTimeFieldUpdateOperationsInput
    ticketPrice: FloatFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input EventGroupUpsertWithoutEventsInput {
    create: EventGroupCreateWithoutEventsInput!
    update: EventGroupUpdateWithoutEventsInput!
}

input EventGroupWhereInput {
    AND: [EventGroupWhereInput!]
    NOT: [EventGroupWhereInput!]
    OR: [EventGroupWhereInput!]
    createdAt: DateTimeFilter
    earlyBirdCutoff: DateTimeFilter
    earlyBirdPrice: FloatFilter
    endDate: DateTimeFilter
    events: EventListRelationFilter
    id: StringFilter
    metadata: JsonNullableFilter
    name: StringFilter
    registrationCutoff: DateTimeFilter
    startDate: DateTimeFilter
    ticketPrice: FloatFilter
    updatedAt: DateTimeFilter
}

input EventGroupWhereUniqueInput {
    id: String
}

input EventListRelationFilter {
    every: EventWhereInput
    none: EventWhereInput
    some: EventWhereInput
}

input EventOrderByInput {
    createdAt: SortOrder
    earlyBirdCutoff: SortOrder
    earlyBirdPrice: SortOrder
    endDate: SortOrder
    eventGroupId: SortOrder
    id: SortOrder
    managers: SortOrder
    metadata: SortOrder
    name: SortOrder
    registrationCutoff: SortOrder
    startDate: SortOrder
    ticketPrice: SortOrder
    updatedAt: SortOrder
    venueId: SortOrder
}

input EventRelationFilter {
    is: EventWhereInput
    isNot: EventWhereInput
}

input EventScalarWhereInput {
    AND: [EventScalarWhereInput!]
    NOT: [EventScalarWhereInput!]
    OR: [EventScalarWhereInput!]
    createdAt: DateTimeFilter
    earlyBirdCutoff: DateTimeFilter
    earlyBirdPrice: FloatFilter
    endDate: DateTimeFilter
    eventGroupId: StringFilter
    id: StringFilter
    managers: StringNullableListFilter
    metadata: JsonNullableFilter
    name: StringFilter
    registrationCutoff: DateTimeFilter
    startDate: DateTimeFilter
    ticketPrice: FloatFilter
    updatedAt: DateTimeFilter
    venueId: StringNullableFilter
}

input EventScalarWhereWithAggregatesInput {
    AND: [EventScalarWhereWithAggregatesInput!]
    NOT: [EventScalarWhereWithAggregatesInput!]
    OR: [EventScalarWhereWithAggregatesInput!]
    createdAt: DateTimeWithAggregatesFilter
    earlyBirdCutoff: DateTimeWithAggregatesFilter
    earlyBirdPrice: FloatWithAggregatesFilter
    endDate: DateTimeWithAggregatesFilter
    eventGroupId: StringWithAggregatesFilter
    id: StringWithAggregatesFilter
    managers: StringNullableListFilter
    metadata: JsonNullableWithAggregatesFilter
    name: StringWithAggregatesFilter
    registrationCutoff: DateTimeWithAggregatesFilter
    startDate: DateTimeWithAggregatesFilter
    ticketPrice: FloatWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
    venueId: StringNullableWithAggregatesFilter
}

input EventUpdateInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: DateTimeFieldUpdateOperationsInput
    earlyBirdPrice: FloatFieldUpdateOperationsInput
    endDate: DateTimeFieldUpdateOperationsInput
    eventGroup: EventGroupUpdateOneRequiredWithoutEventsInput
    id: StringFieldUpdateOperationsInput
    managers: EventUpdatemanagersInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    registrationCutoff: DateTimeFieldUpdateOperationsInput
    sponsors: SponsorUpdateManyWithoutEventInput
    startDate: DateTimeFieldUpdateOperationsInput
    ticketPrice: FloatFieldUpdateOperationsInput
    tickets: TicketUpdateManyWithoutEventInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    venue: VenueUpdateOneWithoutEventsInput
}

input EventUpdateManyMutationInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: DateTimeFieldUpdateOperationsInput
    earlyBirdPrice: FloatFieldUpdateOperationsInput
    endDate: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    managers: EventUpdatemanagersInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    registrationCutoff: DateTimeFieldUpdateOperationsInput
    startDate: DateTimeFieldUpdateOperationsInput
    ticketPrice: FloatFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input EventUpdateManyWithWhereWithoutEventGroupInput {
    data: EventUpdateManyMutationInput!
    where: EventScalarWhereInput!
}

input EventUpdateManyWithWhereWithoutVenueInput {
    data: EventUpdateManyMutationInput!
    where: EventScalarWhereInput!
}

input EventUpdateManyWithoutEventGroupInput {
    connect: [EventWhereUniqueInput!]
    connectOrCreate: [EventCreateOrConnectWithoutEventGroupInput!]
    create: [EventCreateWithoutEventGroupInput!]
    createMany: EventCreateManyEventGroupInputEnvelope
    delete: [EventWhereUniqueInput!]
    deleteMany: [EventScalarWhereInput!]
    disconnect: [EventWhereUniqueInput!]
    set: [EventWhereUniqueInput!]
    update: [EventUpdateWithWhereUniqueWithoutEventGroupInput!]
    updateMany: [EventUpdateManyWithWhereWithoutEventGroupInput!]
    upsert: [EventUpsertWithWhereUniqueWithoutEventGroupInput!]
}

input EventUpdateManyWithoutVenueInput {
    connect: [EventWhereUniqueInput!]
    connectOrCreate: [EventCreateOrConnectWithoutVenueInput!]
    create: [EventCreateWithoutVenueInput!]
    createMany: EventCreateManyVenueInputEnvelope
    delete: [EventWhereUniqueInput!]
    deleteMany: [EventScalarWhereInput!]
    disconnect: [EventWhereUniqueInput!]
    set: [EventWhereUniqueInput!]
    update: [EventUpdateWithWhereUniqueWithoutVenueInput!]
    updateMany: [EventUpdateManyWithWhereWithoutVenueInput!]
    upsert: [EventUpsertWithWhereUniqueWithoutVenueInput!]
}

input EventUpdateOneRequiredWithoutTicketsInput {
    connect: EventWhereUniqueInput
    connectOrCreate: EventCreateOrConnectWithoutTicketsInput
    create: EventCreateWithoutTicketsInput
    update: EventUpdateWithoutTicketsInput
    upsert: EventUpsertWithoutTicketsInput
}

input EventUpdateOneWithoutSponsorsInput {
    connect: EventWhereUniqueInput
    connectOrCreate: EventCreateOrConnectWithoutSponsorsInput
    create: EventCreateWithoutSponsorsInput
    delete: Boolean
    disconnect: Boolean
    update: EventUpdateWithoutSponsorsInput
    upsert: EventUpsertWithoutSponsorsInput
}

input EventUpdateWithWhereUniqueWithoutEventGroupInput {
    data: EventUpdateWithoutEventGroupInput!
    where: EventWhereUniqueInput!
}

input EventUpdateWithWhereUniqueWithoutVenueInput {
    data: EventUpdateWithoutVenueInput!
    where: EventWhereUniqueInput!
}

input EventUpdateWithoutEventGroupInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: DateTimeFieldUpdateOperationsInput
    earlyBirdPrice: FloatFieldUpdateOperationsInput
    endDate: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    managers: EventUpdatemanagersInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    registrationCutoff: DateTimeFieldUpdateOperationsInput
    sponsors: SponsorUpdateManyWithoutEventInput
    startDate: DateTimeFieldUpdateOperationsInput
    ticketPrice: FloatFieldUpdateOperationsInput
    tickets: TicketUpdateManyWithoutEventInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    venue: VenueUpdateOneWithoutEventsInput
}

input EventUpdateWithoutSponsorsInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: DateTimeFieldUpdateOperationsInput
    earlyBirdPrice: FloatFieldUpdateOperationsInput
    endDate: DateTimeFieldUpdateOperationsInput
    eventGroup: EventGroupUpdateOneRequiredWithoutEventsInput
    id: StringFieldUpdateOperationsInput
    managers: EventUpdatemanagersInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    registrationCutoff: DateTimeFieldUpdateOperationsInput
    startDate: DateTimeFieldUpdateOperationsInput
    ticketPrice: FloatFieldUpdateOperationsInput
    tickets: TicketUpdateManyWithoutEventInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    venue: VenueUpdateOneWithoutEventsInput
}

input EventUpdateWithoutTicketsInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: DateTimeFieldUpdateOperationsInput
    earlyBirdPrice: FloatFieldUpdateOperationsInput
    endDate: DateTimeFieldUpdateOperationsInput
    eventGroup: EventGroupUpdateOneRequiredWithoutEventsInput
    id: StringFieldUpdateOperationsInput
    managers: EventUpdatemanagersInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    registrationCutoff: DateTimeFieldUpdateOperationsInput
    sponsors: SponsorUpdateManyWithoutEventInput
    startDate: DateTimeFieldUpdateOperationsInput
    ticketPrice: FloatFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    venue: VenueUpdateOneWithoutEventsInput
}

input EventUpdateWithoutVenueInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    earlyBirdCutoff: DateTimeFieldUpdateOperationsInput
    earlyBirdPrice: FloatFieldUpdateOperationsInput
    endDate: DateTimeFieldUpdateOperationsInput
    eventGroup: EventGroupUpdateOneRequiredWithoutEventsInput
    id: StringFieldUpdateOperationsInput
    managers: EventUpdatemanagersInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    registrationCutoff: DateTimeFieldUpdateOperationsInput
    sponsors: SponsorUpdateManyWithoutEventInput
    startDate: DateTimeFieldUpdateOperationsInput
    ticketPrice: FloatFieldUpdateOperationsInput
    tickets: TicketUpdateManyWithoutEventInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input EventUpdatemanagersInput {
    push: [String!]
    set: [String!]
}

input EventUpsertWithWhereUniqueWithoutEventGroupInput {
    create: EventCreateWithoutEventGroupInput!
    update: EventUpdateWithoutEventGroupInput!
    where: EventWhereUniqueInput!
}

input EventUpsertWithWhereUniqueWithoutVenueInput {
    create: EventCreateWithoutVenueInput!
    update: EventUpdateWithoutVenueInput!
    where: EventWhereUniqueInput!
}

input EventUpsertWithoutSponsorsInput {
    create: EventCreateWithoutSponsorsInput!
    update: EventUpdateWithoutSponsorsInput!
}

input EventUpsertWithoutTicketsInput {
    create: EventCreateWithoutTicketsInput!
    update: EventUpdateWithoutTicketsInput!
}

input EventWhereInput {
    AND: [EventWhereInput!]
    NOT: [EventWhereInput!]
    OR: [EventWhereInput!]
    createdAt: DateTimeFilter
    earlyBirdCutoff: DateTimeFilter
    earlyBirdPrice: FloatFilter
    endDate: DateTimeFilter
    eventGroup: EventGroupRelationFilter
    eventGroupId: StringFilter
    id: StringFilter
    managers: StringNullableListFilter
    metadata: JsonNullableFilter
    name: StringFilter
    registrationCutoff: DateTimeFilter
    sponsors: SponsorListRelationFilter
    startDate: DateTimeFilter
    ticketPrice: FloatFilter
    tickets: TicketListRelationFilter
    updatedAt: DateTimeFilter
    venue: VenueRelationFilter
    venueId: StringNullableFilter
}

input EventWhereUniqueInput {
    id: String
}

input FloatFieldUpdateOperationsInput {
    decrement: Float
    divide: Float
    increment: Float
    multiply: Float
    set: Float
}

input FloatFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: NestedFloatFilter
    notIn: [Float!]
}

input FloatWithAggregatesFilter {
    _avg: NestedFloatFilter
    _count: NestedIntFilter
    _max: NestedFloatFilter
    _min: NestedFloatFilter
    _sum: NestedFloatFilter
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: NestedFloatWithAggregatesFilter
    notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
    decrement: Int
    divide: Int
    increment: Int
    multiply: Int
    set: Int
}

input IntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntFilter
    notIn: [Int!]
}

input IntNullableFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntNullableFilter
    notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
    _avg: NestedFloatNullableFilter
    _count: NestedIntNullableFilter
    _max: NestedIntNullableFilter
    _min: NestedIntNullableFilter
    _sum: NestedIntNullableFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntNullableWithAggregatesFilter
    notIn: [Int!]
}

input IntWithAggregatesFilter {
    _avg: NestedFloatFilter
    _count: NestedIntFilter
    _max: NestedIntFilter
    _min: NestedIntFilter
    _sum: NestedIntFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntWithAggregatesFilter
    notIn: [Int!]
}

input JsonNullableFilter {
    equals: JSON
    not: JSON
}

input JsonNullableWithAggregatesFilter {
    _count: NestedIntNullableFilter
    _max: NestedJsonNullableFilter
    _min: NestedJsonNullableFilter
    equals: JSON
    not: JSON
}

input NestedBoolFilter {
    equals: Boolean
    not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedBoolFilter
    _min: NestedBoolFilter
    equals: Boolean
    not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeFilter
    notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedDateTimeFilter
    _min: NestedDateTimeFilter
    equals: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    not: NestedDateTimeWithAggregatesFilter
    notIn: [DateTime!]
}

input NestedEnumTicketTypeFilter {
    equals: TicketType
    in: [TicketType!]
    not: NestedEnumTicketTypeFilter
    notIn: [TicketType!]
}

input NestedEnumTicketTypeWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedEnumTicketTypeFilter
    _min: NestedEnumTicketTypeFilter
    equals: TicketType
    in: [TicketType!]
    not: NestedEnumTicketTypeWithAggregatesFilter
    notIn: [TicketType!]
}

input NestedFloatFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: NestedFloatFilter
    notIn: [Float!]
}

input NestedFloatNullableFilter {
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: NestedFloatNullableFilter
    notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
    _avg: NestedFloatFilter
    _count: NestedIntFilter
    _max: NestedFloatFilter
    _min: NestedFloatFilter
    _sum: NestedFloatFilter
    equals: Float
    gt: Float
    gte: Float
    in: [Float!]
    lt: Float
    lte: Float
    not: NestedFloatWithAggregatesFilter
    notIn: [Float!]
}

input NestedIntFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntFilter
    notIn: [Int!]
}

input NestedIntNullableFilter {
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntNullableFilter
    notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
    _avg: NestedFloatNullableFilter
    _count: NestedIntNullableFilter
    _max: NestedIntNullableFilter
    _min: NestedIntNullableFilter
    _sum: NestedIntNullableFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntNullableWithAggregatesFilter
    notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
    _avg: NestedFloatFilter
    _count: NestedIntFilter
    _max: NestedIntFilter
    _min: NestedIntFilter
    _sum: NestedIntFilter
    equals: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    not: NestedIntWithAggregatesFilter
    notIn: [Int!]
}

input NestedJsonNullableFilter {
    equals: JSON
    not: JSON
}

input NestedStringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringFilter
    notIn: [String!]
    startsWith: String
}

input NestedStringNullableFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringNullableFilter
    notIn: [String!]
    startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
    _count: NestedIntNullableFilter
    _max: NestedStringNullableFilter
    _min: NestedStringNullableFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringNullableWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input NestedStringWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedStringFilter
    _min: NestedStringFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    not: NestedStringWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input NullableIntFieldUpdateOperationsInput {
    decrement: Int
    divide: Int
    increment: Int
    multiply: Int
    set: Int
}

input NullableStringFieldUpdateOperationsInput {
    set: String
}

input PaymentCreateInput {
    Ticket: TicketCreateNestedManyWithoutPaymentInput
    createdAt: DateTime
    id: String
    metadata: JSON
    total: Float!
    updatedAt: DateTime
}

input PaymentCreateManyInput {
    createdAt: DateTime
    id: String
    metadata: JSON
    total: Float!
    updatedAt: DateTime
}

input PaymentCreateNestedOneWithoutTicketInput {
    connect: PaymentWhereUniqueInput
    connectOrCreate: PaymentCreateOrConnectWithoutTicketInput
    create: PaymentCreateWithoutTicketInput
}

input PaymentCreateOrConnectWithoutTicketInput {
    create: PaymentCreateWithoutTicketInput!
    where: PaymentWhereUniqueInput!
}

input PaymentCreateWithoutTicketInput {
    createdAt: DateTime
    id: String
    metadata: JSON
    total: Float!
    updatedAt: DateTime
}

input PaymentOrderByInput {
    createdAt: SortOrder
    id: SortOrder
    metadata: SortOrder
    total: SortOrder
    updatedAt: SortOrder
}

input PaymentRelationFilter {
    is: PaymentWhereInput
    isNot: PaymentWhereInput
}

input PaymentScalarWhereWithAggregatesInput {
    AND: [PaymentScalarWhereWithAggregatesInput!]
    NOT: [PaymentScalarWhereWithAggregatesInput!]
    OR: [PaymentScalarWhereWithAggregatesInput!]
    createdAt: DateTimeWithAggregatesFilter
    id: StringWithAggregatesFilter
    metadata: JsonNullableWithAggregatesFilter
    total: FloatWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
}

input PaymentUpdateInput {
    Ticket: TicketUpdateManyWithoutPaymentInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    metadata: JSON
    total: FloatFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input PaymentUpdateManyMutationInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    metadata: JSON
    total: FloatFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input PaymentUpdateOneWithoutTicketInput {
    connect: PaymentWhereUniqueInput
    connectOrCreate: PaymentCreateOrConnectWithoutTicketInput
    create: PaymentCreateWithoutTicketInput
    delete: Boolean
    disconnect: Boolean
    update: PaymentUpdateWithoutTicketInput
    upsert: PaymentUpsertWithoutTicketInput
}

input PaymentUpdateWithoutTicketInput {
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    metadata: JSON
    total: FloatFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input PaymentUpsertWithoutTicketInput {
    create: PaymentCreateWithoutTicketInput!
    update: PaymentUpdateWithoutTicketInput!
}

input PaymentWhereInput {
    AND: [PaymentWhereInput!]
    NOT: [PaymentWhereInput!]
    OR: [PaymentWhereInput!]
    Ticket: TicketListRelationFilter
    createdAt: DateTimeFilter
    id: StringFilter
    metadata: JsonNullableFilter
    total: FloatFilter
    updatedAt: DateTimeFilter
}

input PaymentWhereUniqueInput {
    id: String
}

input PersonCreateInput {
    Person: PersonCreateNestedManyWithoutGuardianInput
    Venue: VenueCreateNestedManyWithoutContactInput
    age: Int
    createdAt: DateTime
    email: String!
    firstName: String!
    guardian: PersonCreateNestedOneWithoutPersonInput
    id: String
    lastName: String!
    metadata: JSON
    phone: String
    tickets: TicketCreateNestedManyWithoutPersonInput
    updatedAt: DateTime
}

input PersonCreateManyGuardianInput {
    age: Int
    createdAt: DateTime
    email: String!
    firstName: String!
    id: String
    lastName: String!
    metadata: JSON
    phone: String
    updatedAt: DateTime
}

input PersonCreateManyGuardianInputEnvelope {
    data: [PersonCreateManyGuardianInput!]!
    skipDuplicates: Boolean
}

input PersonCreateManyInput {
    age: Int
    createdAt: DateTime
    email: String!
    firstName: String!
    id: String
    lastName: String!
    metadata: JSON
    personId: String
    phone: String
    updatedAt: DateTime
}

input PersonCreateNestedManyWithoutGuardianInput {
    connect: [PersonWhereUniqueInput!]
    connectOrCreate: [PersonCreateOrConnectWithoutGuardianInput!]
    create: [PersonCreateWithoutGuardianInput!]
    createMany: PersonCreateManyGuardianInputEnvelope
}

input PersonCreateNestedOneWithoutPersonInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutPersonInput
    create: PersonCreateWithoutPersonInput
}

input PersonCreateNestedOneWithoutTicketsInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutTicketsInput
    create: PersonCreateWithoutTicketsInput
}

input PersonCreateNestedOneWithoutVenueInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutVenueInput
    create: PersonCreateWithoutVenueInput
}

input PersonCreateOrConnectWithoutGuardianInput {
    create: PersonCreateWithoutGuardianInput!
    where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutPersonInput {
    create: PersonCreateWithoutPersonInput!
    where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutTicketsInput {
    create: PersonCreateWithoutTicketsInput!
    where: PersonWhereUniqueInput!
}

input PersonCreateOrConnectWithoutVenueInput {
    create: PersonCreateWithoutVenueInput!
    where: PersonWhereUniqueInput!
}

input PersonCreateWithoutGuardianInput {
    Person: PersonCreateNestedManyWithoutGuardianInput
    Venue: VenueCreateNestedManyWithoutContactInput
    age: Int
    createdAt: DateTime
    email: String!
    firstName: String!
    id: String
    lastName: String!
    metadata: JSON
    phone: String
    tickets: TicketCreateNestedManyWithoutPersonInput
    updatedAt: DateTime
}

input PersonCreateWithoutPersonInput {
    Venue: VenueCreateNestedManyWithoutContactInput
    age: Int
    createdAt: DateTime
    email: String!
    firstName: String!
    guardian: PersonCreateNestedOneWithoutPersonInput
    id: String
    lastName: String!
    metadata: JSON
    phone: String
    tickets: TicketCreateNestedManyWithoutPersonInput
    updatedAt: DateTime
}

input PersonCreateWithoutTicketsInput {
    Person: PersonCreateNestedManyWithoutGuardianInput
    Venue: VenueCreateNestedManyWithoutContactInput
    age: Int
    createdAt: DateTime
    email: String!
    firstName: String!
    guardian: PersonCreateNestedOneWithoutPersonInput
    id: String
    lastName: String!
    metadata: JSON
    phone: String
    updatedAt: DateTime
}

input PersonCreateWithoutVenueInput {
    Person: PersonCreateNestedManyWithoutGuardianInput
    age: Int
    createdAt: DateTime
    email: String!
    firstName: String!
    guardian: PersonCreateNestedOneWithoutPersonInput
    id: String
    lastName: String!
    metadata: JSON
    phone: String
    tickets: TicketCreateNestedManyWithoutPersonInput
    updatedAt: DateTime
}

input PersonListRelationFilter {
    every: PersonWhereInput
    none: PersonWhereInput
    some: PersonWhereInput
}

input PersonOrderByInput {
    age: SortOrder
    createdAt: SortOrder
    email: SortOrder
    firstName: SortOrder
    id: SortOrder
    lastName: SortOrder
    metadata: SortOrder
    personId: SortOrder
    phone: SortOrder
    updatedAt: SortOrder
}

input PersonRelationFilter {
    is: PersonWhereInput
    isNot: PersonWhereInput
}

input PersonScalarWhereInput {
    AND: [PersonScalarWhereInput!]
    NOT: [PersonScalarWhereInput!]
    OR: [PersonScalarWhereInput!]
    age: IntNullableFilter
    createdAt: DateTimeFilter
    email: StringFilter
    firstName: StringFilter
    id: StringFilter
    lastName: StringFilter
    metadata: JsonNullableFilter
    personId: StringNullableFilter
    phone: StringNullableFilter
    updatedAt: DateTimeFilter
}

input PersonScalarWhereWithAggregatesInput {
    AND: [PersonScalarWhereWithAggregatesInput!]
    NOT: [PersonScalarWhereWithAggregatesInput!]
    OR: [PersonScalarWhereWithAggregatesInput!]
    age: IntNullableWithAggregatesFilter
    createdAt: DateTimeWithAggregatesFilter
    email: StringWithAggregatesFilter
    firstName: StringWithAggregatesFilter
    id: StringWithAggregatesFilter
    lastName: StringWithAggregatesFilter
    metadata: JsonNullableWithAggregatesFilter
    personId: StringNullableWithAggregatesFilter
    phone: StringNullableWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
}

input PersonUpdateInput {
    Person: PersonUpdateManyWithoutGuardianInput
    Venue: VenueUpdateManyWithoutContactInput
    age: NullableIntFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    email: StringFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    guardian: PersonUpdateOneWithoutPersonInput
    id: StringFieldUpdateOperationsInput
    lastName: StringFieldUpdateOperationsInput
    metadata: JSON
    phone: NullableStringFieldUpdateOperationsInput
    tickets: TicketUpdateManyWithoutPersonInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input PersonUpdateManyMutationInput {
    age: NullableIntFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    email: StringFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    lastName: StringFieldUpdateOperationsInput
    metadata: JSON
    phone: NullableStringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input PersonUpdateManyWithWhereWithoutGuardianInput {
    data: PersonUpdateManyMutationInput!
    where: PersonScalarWhereInput!
}

input PersonUpdateManyWithoutGuardianInput {
    connect: [PersonWhereUniqueInput!]
    connectOrCreate: [PersonCreateOrConnectWithoutGuardianInput!]
    create: [PersonCreateWithoutGuardianInput!]
    createMany: PersonCreateManyGuardianInputEnvelope
    delete: [PersonWhereUniqueInput!]
    deleteMany: [PersonScalarWhereInput!]
    disconnect: [PersonWhereUniqueInput!]
    set: [PersonWhereUniqueInput!]
    update: [PersonUpdateWithWhereUniqueWithoutGuardianInput!]
    updateMany: [PersonUpdateManyWithWhereWithoutGuardianInput!]
    upsert: [PersonUpsertWithWhereUniqueWithoutGuardianInput!]
}

input PersonUpdateOneRequiredWithoutTicketsInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutTicketsInput
    create: PersonCreateWithoutTicketsInput
    update: PersonUpdateWithoutTicketsInput
    upsert: PersonUpsertWithoutTicketsInput
}

input PersonUpdateOneWithoutPersonInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutPersonInput
    create: PersonCreateWithoutPersonInput
    delete: Boolean
    disconnect: Boolean
    update: PersonUpdateWithoutPersonInput
    upsert: PersonUpsertWithoutPersonInput
}

input PersonUpdateOneWithoutVenueInput {
    connect: PersonWhereUniqueInput
    connectOrCreate: PersonCreateOrConnectWithoutVenueInput
    create: PersonCreateWithoutVenueInput
    delete: Boolean
    disconnect: Boolean
    update: PersonUpdateWithoutVenueInput
    upsert: PersonUpsertWithoutVenueInput
}

input PersonUpdateWithWhereUniqueWithoutGuardianInput {
    data: PersonUpdateWithoutGuardianInput!
    where: PersonWhereUniqueInput!
}

input PersonUpdateWithoutGuardianInput {
    Person: PersonUpdateManyWithoutGuardianInput
    Venue: VenueUpdateManyWithoutContactInput
    age: NullableIntFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    email: StringFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    lastName: StringFieldUpdateOperationsInput
    metadata: JSON
    phone: NullableStringFieldUpdateOperationsInput
    tickets: TicketUpdateManyWithoutPersonInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input PersonUpdateWithoutPersonInput {
    Venue: VenueUpdateManyWithoutContactInput
    age: NullableIntFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    email: StringFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    guardian: PersonUpdateOneWithoutPersonInput
    id: StringFieldUpdateOperationsInput
    lastName: StringFieldUpdateOperationsInput
    metadata: JSON
    phone: NullableStringFieldUpdateOperationsInput
    tickets: TicketUpdateManyWithoutPersonInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input PersonUpdateWithoutTicketsInput {
    Person: PersonUpdateManyWithoutGuardianInput
    Venue: VenueUpdateManyWithoutContactInput
    age: NullableIntFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    email: StringFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    guardian: PersonUpdateOneWithoutPersonInput
    id: StringFieldUpdateOperationsInput
    lastName: StringFieldUpdateOperationsInput
    metadata: JSON
    phone: NullableStringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input PersonUpdateWithoutVenueInput {
    Person: PersonUpdateManyWithoutGuardianInput
    age: NullableIntFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    email: StringFieldUpdateOperationsInput
    firstName: StringFieldUpdateOperationsInput
    guardian: PersonUpdateOneWithoutPersonInput
    id: StringFieldUpdateOperationsInput
    lastName: StringFieldUpdateOperationsInput
    metadata: JSON
    phone: NullableStringFieldUpdateOperationsInput
    tickets: TicketUpdateManyWithoutPersonInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input PersonUpsertWithWhereUniqueWithoutGuardianInput {
    create: PersonCreateWithoutGuardianInput!
    update: PersonUpdateWithoutGuardianInput!
    where: PersonWhereUniqueInput!
}

input PersonUpsertWithoutPersonInput {
    create: PersonCreateWithoutPersonInput!
    update: PersonUpdateWithoutPersonInput!
}

input PersonUpsertWithoutTicketsInput {
    create: PersonCreateWithoutTicketsInput!
    update: PersonUpdateWithoutTicketsInput!
}

input PersonUpsertWithoutVenueInput {
    create: PersonCreateWithoutVenueInput!
    update: PersonUpdateWithoutVenueInput!
}

input PersonWhereInput {
    AND: [PersonWhereInput!]
    NOT: [PersonWhereInput!]
    OR: [PersonWhereInput!]
    Person: PersonListRelationFilter
    Venue: VenueListRelationFilter
    age: IntNullableFilter
    createdAt: DateTimeFilter
    email: StringFilter
    firstName: StringFilter
    guardian: PersonRelationFilter
    id: StringFilter
    lastName: StringFilter
    metadata: JsonNullableFilter
    personId: StringNullableFilter
    phone: StringNullableFilter
    tickets: TicketListRelationFilter
    updatedAt: DateTimeFilter
}

input PersonWhereUniqueInput {
    id: String
}

input SponsorCreateInput {
    Event: EventCreateNestedOneWithoutSponsorsInput
    amount: Int!
    createdAt: DateTime
    id: String
    logoImageUri: String!
    metadata: JSON
    name: String!
    updatedAt: DateTime
}

input SponsorCreateManyEventInput {
    amount: Int!
    createdAt: DateTime
    id: String
    logoImageUri: String!
    metadata: JSON
    name: String!
    updatedAt: DateTime
}

input SponsorCreateManyEventInputEnvelope {
    data: [SponsorCreateManyEventInput!]!
    skipDuplicates: Boolean
}

input SponsorCreateManyInput {
    amount: Int!
    createdAt: DateTime
    eventId: String
    id: String
    logoImageUri: String!
    metadata: JSON
    name: String!
    updatedAt: DateTime
}

input SponsorCreateNestedManyWithoutEventInput {
    connect: [SponsorWhereUniqueInput!]
    connectOrCreate: [SponsorCreateOrConnectWithoutEventInput!]
    create: [SponsorCreateWithoutEventInput!]
    createMany: SponsorCreateManyEventInputEnvelope
}

input SponsorCreateOrConnectWithoutEventInput {
    create: SponsorCreateWithoutEventInput!
    where: SponsorWhereUniqueInput!
}

input SponsorCreateWithoutEventInput {
    amount: Int!
    createdAt: DateTime
    id: String
    logoImageUri: String!
    metadata: JSON
    name: String!
    updatedAt: DateTime
}

input SponsorListRelationFilter {
    every: SponsorWhereInput
    none: SponsorWhereInput
    some: SponsorWhereInput
}

input SponsorOrderByInput {
    amount: SortOrder
    createdAt: SortOrder
    eventId: SortOrder
    id: SortOrder
    logoImageUri: SortOrder
    metadata: SortOrder
    name: SortOrder
    updatedAt: SortOrder
}

input SponsorScalarWhereInput {
    AND: [SponsorScalarWhereInput!]
    NOT: [SponsorScalarWhereInput!]
    OR: [SponsorScalarWhereInput!]
    amount: IntFilter
    createdAt: DateTimeFilter
    eventId: StringNullableFilter
    id: StringFilter
    logoImageUri: StringFilter
    metadata: JsonNullableFilter
    name: StringFilter
    updatedAt: DateTimeFilter
}

input SponsorScalarWhereWithAggregatesInput {
    AND: [SponsorScalarWhereWithAggregatesInput!]
    NOT: [SponsorScalarWhereWithAggregatesInput!]
    OR: [SponsorScalarWhereWithAggregatesInput!]
    amount: IntWithAggregatesFilter
    createdAt: DateTimeWithAggregatesFilter
    eventId: StringNullableWithAggregatesFilter
    id: StringWithAggregatesFilter
    logoImageUri: StringWithAggregatesFilter
    metadata: JsonNullableWithAggregatesFilter
    name: StringWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
}

input SponsorUpdateInput {
    Event: EventUpdateOneWithoutSponsorsInput
    amount: IntFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    logoImageUri: StringFieldUpdateOperationsInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input SponsorUpdateManyMutationInput {
    amount: IntFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    logoImageUri: StringFieldUpdateOperationsInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input SponsorUpdateManyWithWhereWithoutEventInput {
    data: SponsorUpdateManyMutationInput!
    where: SponsorScalarWhereInput!
}

input SponsorUpdateManyWithoutEventInput {
    connect: [SponsorWhereUniqueInput!]
    connectOrCreate: [SponsorCreateOrConnectWithoutEventInput!]
    create: [SponsorCreateWithoutEventInput!]
    createMany: SponsorCreateManyEventInputEnvelope
    delete: [SponsorWhereUniqueInput!]
    deleteMany: [SponsorScalarWhereInput!]
    disconnect: [SponsorWhereUniqueInput!]
    set: [SponsorWhereUniqueInput!]
    update: [SponsorUpdateWithWhereUniqueWithoutEventInput!]
    updateMany: [SponsorUpdateManyWithWhereWithoutEventInput!]
    upsert: [SponsorUpsertWithWhereUniqueWithoutEventInput!]
}

input SponsorUpdateWithWhereUniqueWithoutEventInput {
    data: SponsorUpdateWithoutEventInput!
    where: SponsorWhereUniqueInput!
}

input SponsorUpdateWithoutEventInput {
    amount: IntFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    logoImageUri: StringFieldUpdateOperationsInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input SponsorUpsertWithWhereUniqueWithoutEventInput {
    create: SponsorCreateWithoutEventInput!
    update: SponsorUpdateWithoutEventInput!
    where: SponsorWhereUniqueInput!
}

input SponsorWhereInput {
    AND: [SponsorWhereInput!]
    Event: EventRelationFilter
    NOT: [SponsorWhereInput!]
    OR: [SponsorWhereInput!]
    amount: IntFilter
    createdAt: DateTimeFilter
    eventId: StringNullableFilter
    id: StringFilter
    logoImageUri: StringFilter
    metadata: JsonNullableFilter
    name: StringFilter
    updatedAt: DateTimeFilter
}

input SponsorWhereUniqueInput {
    id: String
}

input StringFieldUpdateOperationsInput {
    set: String
}

input StringFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringFilter
    notIn: [String!]
    startsWith: String
}

input StringNullableFilter {
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringNullableFilter
    notIn: [String!]
    startsWith: String
}

input StringNullableListFilter {
    equals: [String!]
    has: String
    hasEvery: [String!]
    hasSome: [String!]
    isEmpty: Boolean
}

input StringNullableWithAggregatesFilter {
    _count: NestedIntNullableFilter
    _max: NestedStringNullableFilter
    _min: NestedStringNullableFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringNullableWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input StringWithAggregatesFilter {
    _count: NestedIntFilter
    _max: NestedStringFilter
    _min: NestedStringFilter
    contains: String
    endsWith: String
    equals: String
    gt: String
    gte: String
    in: [String!]
    lt: String
    lte: String
    mode: QueryMode
    not: NestedStringWithAggregatesFilter
    notIn: [String!]
    startsWith: String
}

input TicketCreateInput {
    couponCode: String
    createdAt: DateTime
    event: EventCreateNestedOneWithoutTicketsInput!
    id: String
    metadata: JSON
    payment: PaymentCreateNestedOneWithoutTicketInput
    person: PersonCreateNestedOneWithoutTicketsInput!
    type: TicketType
    updatedAt: DateTime
    waiverSigned: Boolean
}

input TicketCreateManyEventInput {
    couponCode: String
    createdAt: DateTime
    id: String
    metadata: JSON
    paymentId: String
    personId: String!
    type: TicketType
    updatedAt: DateTime
    waiverSigned: Boolean
}

input TicketCreateManyEventInputEnvelope {
    data: [TicketCreateManyEventInput!]!
    skipDuplicates: Boolean
}

input TicketCreateManyInput {
    couponCode: String
    createdAt: DateTime
    eventId: String!
    id: String
    metadata: JSON
    paymentId: String
    personId: String!
    type: TicketType
    updatedAt: DateTime
    waiverSigned: Boolean
}

input TicketCreateManyPaymentInput {
    couponCode: String
    createdAt: DateTime
    eventId: String!
    id: String
    metadata: JSON
    personId: String!
    type: TicketType
    updatedAt: DateTime
    waiverSigned: Boolean
}

input TicketCreateManyPaymentInputEnvelope {
    data: [TicketCreateManyPaymentInput!]!
    skipDuplicates: Boolean
}

input TicketCreateManyPersonInput {
    couponCode: String
    createdAt: DateTime
    eventId: String!
    id: String
    metadata: JSON
    paymentId: String
    type: TicketType
    updatedAt: DateTime
    waiverSigned: Boolean
}

input TicketCreateManyPersonInputEnvelope {
    data: [TicketCreateManyPersonInput!]!
    skipDuplicates: Boolean
}

input TicketCreateNestedManyWithoutEventInput {
    connect: [TicketWhereUniqueInput!]
    connectOrCreate: [TicketCreateOrConnectWithoutEventInput!]
    create: [TicketCreateWithoutEventInput!]
    createMany: TicketCreateManyEventInputEnvelope
}

input TicketCreateNestedManyWithoutPaymentInput {
    connect: [TicketWhereUniqueInput!]
    connectOrCreate: [TicketCreateOrConnectWithoutPaymentInput!]
    create: [TicketCreateWithoutPaymentInput!]
    createMany: TicketCreateManyPaymentInputEnvelope
}

input TicketCreateNestedManyWithoutPersonInput {
    connect: [TicketWhereUniqueInput!]
    connectOrCreate: [TicketCreateOrConnectWithoutPersonInput!]
    create: [TicketCreateWithoutPersonInput!]
    createMany: TicketCreateManyPersonInputEnvelope
}

input TicketCreateOrConnectWithoutEventInput {
    create: TicketCreateWithoutEventInput!
    where: TicketWhereUniqueInput!
}

input TicketCreateOrConnectWithoutPaymentInput {
    create: TicketCreateWithoutPaymentInput!
    where: TicketWhereUniqueInput!
}

input TicketCreateOrConnectWithoutPersonInput {
    create: TicketCreateWithoutPersonInput!
    where: TicketWhereUniqueInput!
}

input TicketCreateWithoutEventInput {
    couponCode: String
    createdAt: DateTime
    id: String
    metadata: JSON
    payment: PaymentCreateNestedOneWithoutTicketInput
    person: PersonCreateNestedOneWithoutTicketsInput!
    type: TicketType
    updatedAt: DateTime
    waiverSigned: Boolean
}

input TicketCreateWithoutPaymentInput {
    couponCode: String
    createdAt: DateTime
    event: EventCreateNestedOneWithoutTicketsInput!
    id: String
    metadata: JSON
    person: PersonCreateNestedOneWithoutTicketsInput!
    type: TicketType
    updatedAt: DateTime
    waiverSigned: Boolean
}

input TicketCreateWithoutPersonInput {
    couponCode: String
    createdAt: DateTime
    event: EventCreateNestedOneWithoutTicketsInput!
    id: String
    metadata: JSON
    payment: PaymentCreateNestedOneWithoutTicketInput
    type: TicketType
    updatedAt: DateTime
    waiverSigned: Boolean
}

input TicketListRelationFilter {
    every: TicketWhereInput
    none: TicketWhereInput
    some: TicketWhereInput
}

input TicketOrderByInput {
    couponCode: SortOrder
    createdAt: SortOrder
    eventId: SortOrder
    id: SortOrder
    metadata: SortOrder
    paymentId: SortOrder
    personId: SortOrder
    type: SortOrder
    updatedAt: SortOrder
    waiverSigned: SortOrder
}

input TicketScalarWhereInput {
    AND: [TicketScalarWhereInput!]
    NOT: [TicketScalarWhereInput!]
    OR: [TicketScalarWhereInput!]
    couponCode: StringNullableFilter
    createdAt: DateTimeFilter
    eventId: StringFilter
    id: StringFilter
    metadata: JsonNullableFilter
    paymentId: StringNullableFilter
    personId: StringFilter
    type: EnumTicketTypeFilter
    updatedAt: DateTimeFilter
    waiverSigned: BoolFilter
}

input TicketScalarWhereWithAggregatesInput {
    AND: [TicketScalarWhereWithAggregatesInput!]
    NOT: [TicketScalarWhereWithAggregatesInput!]
    OR: [TicketScalarWhereWithAggregatesInput!]
    couponCode: StringNullableWithAggregatesFilter
    createdAt: DateTimeWithAggregatesFilter
    eventId: StringWithAggregatesFilter
    id: StringWithAggregatesFilter
    metadata: JsonNullableWithAggregatesFilter
    paymentId: StringNullableWithAggregatesFilter
    personId: StringWithAggregatesFilter
    type: EnumTicketTypeWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
    waiverSigned: BoolWithAggregatesFilter
}

input TicketUpdateInput {
    couponCode: NullableStringFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    event: EventUpdateOneRequiredWithoutTicketsInput
    id: StringFieldUpdateOperationsInput
    metadata: JSON
    payment: PaymentUpdateOneWithoutTicketInput
    person: PersonUpdateOneRequiredWithoutTicketsInput
    type: EnumTicketTypeFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    waiverSigned: BoolFieldUpdateOperationsInput
}

input TicketUpdateManyMutationInput {
    couponCode: NullableStringFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    metadata: JSON
    type: EnumTicketTypeFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    waiverSigned: BoolFieldUpdateOperationsInput
}

input TicketUpdateManyWithWhereWithoutEventInput {
    data: TicketUpdateManyMutationInput!
    where: TicketScalarWhereInput!
}

input TicketUpdateManyWithWhereWithoutPaymentInput {
    data: TicketUpdateManyMutationInput!
    where: TicketScalarWhereInput!
}

input TicketUpdateManyWithWhereWithoutPersonInput {
    data: TicketUpdateManyMutationInput!
    where: TicketScalarWhereInput!
}

input TicketUpdateManyWithoutEventInput {
    connect: [TicketWhereUniqueInput!]
    connectOrCreate: [TicketCreateOrConnectWithoutEventInput!]
    create: [TicketCreateWithoutEventInput!]
    createMany: TicketCreateManyEventInputEnvelope
    delete: [TicketWhereUniqueInput!]
    deleteMany: [TicketScalarWhereInput!]
    disconnect: [TicketWhereUniqueInput!]
    set: [TicketWhereUniqueInput!]
    update: [TicketUpdateWithWhereUniqueWithoutEventInput!]
    updateMany: [TicketUpdateManyWithWhereWithoutEventInput!]
    upsert: [TicketUpsertWithWhereUniqueWithoutEventInput!]
}

input TicketUpdateManyWithoutPaymentInput {
    connect: [TicketWhereUniqueInput!]
    connectOrCreate: [TicketCreateOrConnectWithoutPaymentInput!]
    create: [TicketCreateWithoutPaymentInput!]
    createMany: TicketCreateManyPaymentInputEnvelope
    delete: [TicketWhereUniqueInput!]
    deleteMany: [TicketScalarWhereInput!]
    disconnect: [TicketWhereUniqueInput!]
    set: [TicketWhereUniqueInput!]
    update: [TicketUpdateWithWhereUniqueWithoutPaymentInput!]
    updateMany: [TicketUpdateManyWithWhereWithoutPaymentInput!]
    upsert: [TicketUpsertWithWhereUniqueWithoutPaymentInput!]
}

input TicketUpdateManyWithoutPersonInput {
    connect: [TicketWhereUniqueInput!]
    connectOrCreate: [TicketCreateOrConnectWithoutPersonInput!]
    create: [TicketCreateWithoutPersonInput!]
    createMany: TicketCreateManyPersonInputEnvelope
    delete: [TicketWhereUniqueInput!]
    deleteMany: [TicketScalarWhereInput!]
    disconnect: [TicketWhereUniqueInput!]
    set: [TicketWhereUniqueInput!]
    update: [TicketUpdateWithWhereUniqueWithoutPersonInput!]
    updateMany: [TicketUpdateManyWithWhereWithoutPersonInput!]
    upsert: [TicketUpsertWithWhereUniqueWithoutPersonInput!]
}

input TicketUpdateWithWhereUniqueWithoutEventInput {
    data: TicketUpdateWithoutEventInput!
    where: TicketWhereUniqueInput!
}

input TicketUpdateWithWhereUniqueWithoutPaymentInput {
    data: TicketUpdateWithoutPaymentInput!
    where: TicketWhereUniqueInput!
}

input TicketUpdateWithWhereUniqueWithoutPersonInput {
    data: TicketUpdateWithoutPersonInput!
    where: TicketWhereUniqueInput!
}

input TicketUpdateWithoutEventInput {
    couponCode: NullableStringFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    metadata: JSON
    payment: PaymentUpdateOneWithoutTicketInput
    person: PersonUpdateOneRequiredWithoutTicketsInput
    type: EnumTicketTypeFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    waiverSigned: BoolFieldUpdateOperationsInput
}

input TicketUpdateWithoutPaymentInput {
    couponCode: NullableStringFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    event: EventUpdateOneRequiredWithoutTicketsInput
    id: StringFieldUpdateOperationsInput
    metadata: JSON
    person: PersonUpdateOneRequiredWithoutTicketsInput
    type: EnumTicketTypeFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    waiverSigned: BoolFieldUpdateOperationsInput
}

input TicketUpdateWithoutPersonInput {
    couponCode: NullableStringFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    event: EventUpdateOneRequiredWithoutTicketsInput
    id: StringFieldUpdateOperationsInput
    metadata: JSON
    payment: PaymentUpdateOneWithoutTicketInput
    type: EnumTicketTypeFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
    waiverSigned: BoolFieldUpdateOperationsInput
}

input TicketUpsertWithWhereUniqueWithoutEventInput {
    create: TicketCreateWithoutEventInput!
    update: TicketUpdateWithoutEventInput!
    where: TicketWhereUniqueInput!
}

input TicketUpsertWithWhereUniqueWithoutPaymentInput {
    create: TicketCreateWithoutPaymentInput!
    update: TicketUpdateWithoutPaymentInput!
    where: TicketWhereUniqueInput!
}

input TicketUpsertWithWhereUniqueWithoutPersonInput {
    create: TicketCreateWithoutPersonInput!
    update: TicketUpdateWithoutPersonInput!
    where: TicketWhereUniqueInput!
}

input TicketWhereInput {
    AND: [TicketWhereInput!]
    NOT: [TicketWhereInput!]
    OR: [TicketWhereInput!]
    couponCode: StringNullableFilter
    createdAt: DateTimeFilter
    event: EventRelationFilter
    eventId: StringFilter
    id: StringFilter
    metadata: JsonNullableFilter
    payment: PaymentRelationFilter
    paymentId: StringNullableFilter
    person: PersonRelationFilter
    personId: StringFilter
    type: EnumTicketTypeFilter
    updatedAt: DateTimeFilter
    waiverSigned: BoolFilter
}

input TicketWhereUniqueInput {
    id: String
}

input VenueCreateInput {
    address: String!
    capacity: Int!
    contact: PersonCreateNestedOneWithoutVenueInput
    createdAt: DateTime
    events: EventCreateNestedManyWithoutVenueInput
    id: String
    mapLink: String!
    metadata: JSON
    name: String!
    updatedAt: DateTime
}

input VenueCreateManyContactInput {
    address: String!
    capacity: Int!
    createdAt: DateTime
    id: String
    mapLink: String!
    metadata: JSON
    name: String!
    updatedAt: DateTime
}

input VenueCreateManyContactInputEnvelope {
    data: [VenueCreateManyContactInput!]!
    skipDuplicates: Boolean
}

input VenueCreateManyInput {
    address: String!
    capacity: Int!
    createdAt: DateTime
    id: String
    mapLink: String!
    metadata: JSON
    name: String!
    personId: String
    updatedAt: DateTime
}

input VenueCreateNestedManyWithoutContactInput {
    connect: [VenueWhereUniqueInput!]
    connectOrCreate: [VenueCreateOrConnectWithoutContactInput!]
    create: [VenueCreateWithoutContactInput!]
    createMany: VenueCreateManyContactInputEnvelope
}

input VenueCreateNestedOneWithoutEventsInput {
    connect: VenueWhereUniqueInput
    connectOrCreate: VenueCreateOrConnectWithoutEventsInput
    create: VenueCreateWithoutEventsInput
}

input VenueCreateOrConnectWithoutContactInput {
    create: VenueCreateWithoutContactInput!
    where: VenueWhereUniqueInput!
}

input VenueCreateOrConnectWithoutEventsInput {
    create: VenueCreateWithoutEventsInput!
    where: VenueWhereUniqueInput!
}

input VenueCreateWithoutContactInput {
    address: String!
    capacity: Int!
    createdAt: DateTime
    events: EventCreateNestedManyWithoutVenueInput
    id: String
    mapLink: String!
    metadata: JSON
    name: String!
    updatedAt: DateTime
}

input VenueCreateWithoutEventsInput {
    address: String!
    capacity: Int!
    contact: PersonCreateNestedOneWithoutVenueInput
    createdAt: DateTime
    id: String
    mapLink: String!
    metadata: JSON
    name: String!
    updatedAt: DateTime
}

input VenueListRelationFilter {
    every: VenueWhereInput
    none: VenueWhereInput
    some: VenueWhereInput
}

input VenueOrderByInput {
    address: SortOrder
    capacity: SortOrder
    createdAt: SortOrder
    id: SortOrder
    mapLink: SortOrder
    metadata: SortOrder
    name: SortOrder
    personId: SortOrder
    updatedAt: SortOrder
}

input VenueRelationFilter {
    is: VenueWhereInput
    isNot: VenueWhereInput
}

input VenueScalarWhereInput {
    AND: [VenueScalarWhereInput!]
    NOT: [VenueScalarWhereInput!]
    OR: [VenueScalarWhereInput!]
    address: StringFilter
    capacity: IntFilter
    createdAt: DateTimeFilter
    id: StringFilter
    mapLink: StringFilter
    metadata: JsonNullableFilter
    name: StringFilter
    personId: StringNullableFilter
    updatedAt: DateTimeFilter
}

input VenueScalarWhereWithAggregatesInput {
    AND: [VenueScalarWhereWithAggregatesInput!]
    NOT: [VenueScalarWhereWithAggregatesInput!]
    OR: [VenueScalarWhereWithAggregatesInput!]
    address: StringWithAggregatesFilter
    capacity: IntWithAggregatesFilter
    createdAt: DateTimeWithAggregatesFilter
    id: StringWithAggregatesFilter
    mapLink: StringWithAggregatesFilter
    metadata: JsonNullableWithAggregatesFilter
    name: StringWithAggregatesFilter
    personId: StringNullableWithAggregatesFilter
    updatedAt: DateTimeWithAggregatesFilter
}

input VenueUpdateInput {
    address: StringFieldUpdateOperationsInput
    capacity: IntFieldUpdateOperationsInput
    contact: PersonUpdateOneWithoutVenueInput
    createdAt: DateTimeFieldUpdateOperationsInput
    events: EventUpdateManyWithoutVenueInput
    id: StringFieldUpdateOperationsInput
    mapLink: StringFieldUpdateOperationsInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input VenueUpdateManyMutationInput {
    address: StringFieldUpdateOperationsInput
    capacity: IntFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    mapLink: StringFieldUpdateOperationsInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input VenueUpdateManyWithWhereWithoutContactInput {
    data: VenueUpdateManyMutationInput!
    where: VenueScalarWhereInput!
}

input VenueUpdateManyWithoutContactInput {
    connect: [VenueWhereUniqueInput!]
    connectOrCreate: [VenueCreateOrConnectWithoutContactInput!]
    create: [VenueCreateWithoutContactInput!]
    createMany: VenueCreateManyContactInputEnvelope
    delete: [VenueWhereUniqueInput!]
    deleteMany: [VenueScalarWhereInput!]
    disconnect: [VenueWhereUniqueInput!]
    set: [VenueWhereUniqueInput!]
    update: [VenueUpdateWithWhereUniqueWithoutContactInput!]
    updateMany: [VenueUpdateManyWithWhereWithoutContactInput!]
    upsert: [VenueUpsertWithWhereUniqueWithoutContactInput!]
}

input VenueUpdateOneWithoutEventsInput {
    connect: VenueWhereUniqueInput
    connectOrCreate: VenueCreateOrConnectWithoutEventsInput
    create: VenueCreateWithoutEventsInput
    delete: Boolean
    disconnect: Boolean
    update: VenueUpdateWithoutEventsInput
    upsert: VenueUpsertWithoutEventsInput
}

input VenueUpdateWithWhereUniqueWithoutContactInput {
    data: VenueUpdateWithoutContactInput!
    where: VenueWhereUniqueInput!
}

input VenueUpdateWithoutContactInput {
    address: StringFieldUpdateOperationsInput
    capacity: IntFieldUpdateOperationsInput
    createdAt: DateTimeFieldUpdateOperationsInput
    events: EventUpdateManyWithoutVenueInput
    id: StringFieldUpdateOperationsInput
    mapLink: StringFieldUpdateOperationsInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input VenueUpdateWithoutEventsInput {
    address: StringFieldUpdateOperationsInput
    capacity: IntFieldUpdateOperationsInput
    contact: PersonUpdateOneWithoutVenueInput
    createdAt: DateTimeFieldUpdateOperationsInput
    id: StringFieldUpdateOperationsInput
    mapLink: StringFieldUpdateOperationsInput
    metadata: JSON
    name: StringFieldUpdateOperationsInput
    updatedAt: DateTimeFieldUpdateOperationsInput
}

input VenueUpsertWithWhereUniqueWithoutContactInput {
    create: VenueCreateWithoutContactInput!
    update: VenueUpdateWithoutContactInput!
    where: VenueWhereUniqueInput!
}

input VenueUpsertWithoutEventsInput {
    create: VenueCreateWithoutEventsInput!
    update: VenueUpdateWithoutEventsInput!
}

input VenueWhereInput {
    AND: [VenueWhereInput!]
    NOT: [VenueWhereInput!]
    OR: [VenueWhereInput!]
    address: StringFilter
    capacity: IntFilter
    contact: PersonRelationFilter
    createdAt: DateTimeFilter
    events: EventListRelationFilter
    id: StringFilter
    mapLink: StringFilter
    metadata: JsonNullableFilter
    name: StringFilter
    personId: StringNullableFilter
    updatedAt: DateTimeFilter
}

input VenueWhereUniqueInput {
    id: String
}


"The javascript `Date` as string. Type represents date and time as the ISO Date string."
scalar DateTime

"The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON
